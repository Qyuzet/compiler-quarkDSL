---
# COMP6062001 – Compilation Techniques

## Final Project: Application of Compilation Principles
---

## **Project Weight & Deadline**

- **Weight:** 30% of the final grade
- **Due:** Week 13
- **Group Size:** Maximum 4 students per group

---

## **Project Description**

The project requires you to apply compiler design principles to a practical problem.
You may:

- Create a **compiler** for a language so that it becomes executable.
- Or build a **translator** that converts one language to another.

During the project, you are also evaluated on coding, research, teamwork, presentation, and writing skills.

---

## **Project Requirements**

### You must:

- **Choose a specific problem** requiring lexing and parsing algorithms, with potential code optimization and machine code generation.
- **Implement a lexer and one parsing algorithm**, such as:

  - Recursive Descent Parsing (LL(1))
  - Top-down Table-driven Parsing (LL(1))
  - Bottom-up Table-driven Parsing (LALR or LR(1))

- **Explain your algorithm design** and why it fits the problem.
- **Provide analysis** of chosen algorithms (if relevant—e.g., if you hand-coded your compiler).
- **Demonstrate your implementation** and report your results.

---

## **Suggested Topics**

- Custom “COOL”-like language interpreter/compiler
- HTML Checker / Parser
- Malicious Code Detection
- Translating LaTeX to HTML
- Graph-drawing tool
- Audio/video to text (English or Indonesian)
- Audio-command user interface
- And others

---

## **Instructions for Solution Implementation**

- Work in a group of 2–4 members.
- Divide work clearly from the beginning.
- The final product must be an **application software**.
- Any language and relevant libraries may be used.
- **Acknowledge external sources** (code, images, methods, etc.).
- **If more than 60% of your code is external, it may be considered plagiarism.**

---

## **Policy for AI Usage**

You may use AI assistance, **but** you must:

- Acknowledge **how AI contributed** to your project.
- Clearly state **which code is yours and which is AI-generated**.
- Provide the **link to your ChatGPT prompts**.

Failure to comply results in **heavy point deduction**.

---

## **Project Milestones & Grading**

| No  | Milestone Deliverable         | Week | Weight |
| --- | ----------------------------- | ---- | ------ |
| 1   | Project Idea Presentation     | 4–7  | 5%     |
| 2   | Project Proposal Presentation | 10   | 15%    |
| 3   | Project Final Presentation    | 13   | 80%    |
|     | **Total**                     |      | 100%   |

---

## **Week 10 – Project Milestone Requirements**

### Submit:

- Project proposal (max 10 pages)

### Present:

- Prepared slides
- Progress report: accomplishments, issues, next steps

---

## **Week 13 – Final Presentation Requirements**

### Present:

- Presentation slides
- Live demo
- Q&A session

### Submit (Upload):

- Presentation slides
- Project Report (max 20 pages, excluding code)
- GitHub link to program code
- Demo video (max 5 minutes)

---

## **Project Report Guidelines**

Max 20 pages (excluding code), single-spaced. Must include:

1. **Introduction**

   - Background and motivation
   - Problem description

2. **Related Work**

   - Similar work done previously

3. **Implementation**

   - Formal description:

     - **REGEX** for tokens
     - **CFG/BNF/EBNF** for grammar

   - Compiler or translator design
   - Virtual Machine (if applicable)
   - Complexity analysis of algorithms and data structures

4. **Evaluation**

   - Implementation details
   - Comprehensive test cases

5. **Discussions**

6. **Conclusion & Recommendation**

7. **Program Manual**

   - How to run the program (with screenshots)

8. **Demo Video Link** (5 mins)

9. **GitHub / ZIP link to source code**

---

## **Marking Guide**

### **1. Interestingness of the Problem**

- Poor → Old problem + slow algorithm + small dataset
- Fair → Old problem + fast algorithm + small dataset
- Good → Old problem + fast algorithm + medium dataset
- Excellent → New applied problem + fast algorithms + medium dataset

### **2. Suitability of Data Structures & Algorithms**

- Poor → Familiar but inappropriate
- Fair → Familiar & appropriate
- Good → Sophisticated choices but not fully optimized
- Excellent → Most suitable data structures selected

### **3. Quality of Implementation**

- Poor → No documentation, cannot compile
- Fair → Minimal documentation, can run but buggy
- Good → Well-documented, runs well
- Excellent → Clean documentation, bug-free, user-friendly

### **4. Difficulty of Implementation**

- Poor → 60% public code
- Fair → 40% public code
- Good → 20% public code
- Excellent → Mostly original code

### **5. Teamwork**

- Poor → Both individual & overall scope not done
- Fair → Only overall scope done
- Good → Individual & overall scopes done well
- Excellent → Strong overall teamwork

### **6. Documentation & Presentation**

- Poor → Report missing
- Fair → Acceptable but incomplete
- Good → Few writing deficiencies
- Excellent → Complete, high-quality report

---

**End of Document**

---
