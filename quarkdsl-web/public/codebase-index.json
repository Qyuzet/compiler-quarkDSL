{
  "generatedAt": "2026-01-04T19:45:50.313Z",
  "chunks": [
    {
      "id": "docs/data-marshalling-design.md:1-80",
      "filePath": "docs/data-marshalling-design.md",
      "fileName": "data-marshalling-design.md",
      "content": "# Data Marshalling Design - QuarkDSL\n\n**Purpose:** Automatic conversion between GPU and Quantum domains\n\n---\n\n## ðŸŽ¯ Problem Statement\n\nWhen calling across domains, we need to convert data:\n\n```rust\n@gpu\nfn preprocess(data: [float]) -> [float] { ... }\n\n@quantum\nfn quantum_circuit(params: [float]) -> int { ... }\n\nfn main() {\n    let features = preprocess(data);      // GPU: [float]\n    let result = quantum_circuit(features); // Need: GPU â†’ Quantum conversion!\n}\n```\n\n**Challenge:** GPU arrays â‰  Quantum states\n\n---\n\n## ðŸ“Š Data Type Mapping\n\n| QuarkDSL Type   | GPU (WGSL)   | Quantum (Qiskit)   | Conversion Method   |\n| --------------- | ------------ | ------------------ | ------------------- |\n| `[float]`       | `array<f32>` | Angle encoding     | `ry(qubit, angle)`  |\n| `[int]`         | `array<i32>` | Basis encoding     | `x(qubit)` if bit=1 |\n| `tensor<float>` | `array<f32>` | Amplitude encoding | Statevector         |\n| `qstate`        | N/A          | `QuantumCircuit`   | Direct              |\n| `int` (result)  | `i32`        | Measurement        | `measure()`         |\n\n---\n\n## ðŸ”„ Conversion Strategies\n\n### **1. GPU â†’ Quantum: Angle Encoding** (Default)\n\n**Use case:** Encode classical features into quantum states\n\n**Method:** Each float value â†’ rotation angle on qubit\n\n```python\n# GPU output: [0.5, 0.3, 0.7, 0.2]\n# Quantum encoding:\ncircuit.ry(0.5, qr[0])  # qubit 0 â† 0.5\ncircuit.ry(0.3, qr[1])  # qubit 1 â† 0.3\ncircuit.ry(0.7, qr[2])  # qubit 2 â† 0.7\ncircuit.ry(0.2, qr[3])  # qubit 3 â† 0.2\n```\n\n**Pros:**\n\n- âœ… Simple and efficient\n- âœ… Works for any float values\n- âœ… Common in VQE/QAOA\n\n**Cons:**\n\n- âš ï¸ Requires N qubits for N values\n\n---\n\n### **2. GPU â†’ Quantum: Amplitude Encoding**\n\n**Use case:** Encode large vectors efficiently\n\n**Method:** Encode N values into âˆšN qubits using amplitudes\n\n```python\n# GPU output: [0.5, 0.5, 0.5, 0.5]  # 4 values\n# Quantum encoding: 2 qubits (2^2 = 4 amplitudes)\ncircuit.initialize([0.5, 0.5, 0.5, 0.5], qr)\n```\n",
      "type": "markdown",
      "keywords": [
        "data",
        "marshalling",
        "design",
        "preprocess",
        "quantum_circuit",
        "main",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "ir",
        "statement",
        "if",
        "qubit",
        "measure"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "docs/data-marshalling-design.md:71-150",
      "filePath": "docs/data-marshalling-design.md",
      "fileName": "data-marshalling-design.md",
      "content": "**Use case:** Encode large vectors efficiently\n\n**Method:** Encode N values into âˆšN qubits using amplitudes\n\n```python\n# GPU output: [0.5, 0.5, 0.5, 0.5]  # 4 values\n# Quantum encoding: 2 qubits (2^2 = 4 amplitudes)\ncircuit.initialize([0.5, 0.5, 0.5, 0.5], qr)\n```\n\n**Pros:**\n\n- âœ… Exponentially efficient (N values â†’ logâ‚‚(N) qubits)\n- âœ… Good for large datasets\n\n**Cons:**\n\n- âš ï¸ Requires normalization (sum of squares = 1)\n- âš ï¸ More complex\n\n---\n\n### **3. Quantum â†’ GPU: Measurement Extraction**\n\n**Use case:** Get quantum results back to classical\n\n**Method:** Measure qubits â†’ extract counts â†’ convert to array\n\n```python\n# Quantum measurement\ncircuit.measure(qr, cr)\njob = backend.run(circuit, shots=1024)\ncounts = job.result().get_counts()\n\n# Extract to GPU array\n# counts = {'00': 512, '01': 256, '10': 128, '11': 128}\n# â†’ [512, 256, 128, 128]\n```\n\n**Pros:**\n\n- âœ… Standard quantum workflow\n- âœ… Preserves probabilistic nature\n\n**Cons:**\n\n- âš ï¸ Requires multiple shots\n- âš ï¸ Lossy (quantum â†’ classical)\n\n---\n\n## ðŸ—ï¸ Implementation Strategy\n\n### **Phase 5A: Detect Cross-Domain Calls** âœ… (Already done!)\n\nWe already detect cross-domain calls in typecheck:\n\n```\nINFO: Cross-domain call from Classical to Gpu function 'gpu_matmul'\nINFO: Cross-domain call from Classical to Quantum function 'quantum_encode'\n```\n\n### **Phase 5B: Generate Conversion Code**\n\n**In IR lowering (`src/middle/lower.rs`):**\n\nWhen we see a cross-domain call, insert conversion instructions:\n\n```rust\n// Before (current):\n%4 = call quantum_encode(%3)\n\n// After (with conversion):\n%3_converted = gpu_to_quantum(%3)  // NEW: Conversion instruction\n%4 = call quantum_encode(%3_converted)\n```\n\n### **Phase 5C: Backend Code Generation**\n\n**GPU Backend (`src/backend/wgsl.rs`):**",
      "type": "markdown",
      "keywords": [
        "data",
        "marshalling",
        "design",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "check",
        "ir",
        "lower",
        "backend",
        "middle",
        "function",
        "qubit",
        "measure"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "docs/data-marshalling-design.md:141-220",
      "filePath": "docs/data-marshalling-design.md",
      "fileName": "data-marshalling-design.md",
      "content": "%4 = call quantum_encode(%3)\n\n// After (with conversion):\n%3_converted = gpu_to_quantum(%3)  // NEW: Conversion instruction\n%4 = call quantum_encode(%3_converted)\n```\n\n### **Phase 5C: Backend Code Generation**\n\n**GPU Backend (`src/backend/wgsl.rs`):**\n\n- Generate WGSL compute shader\n- Export results to buffer\n- Return to Python orchestrator\n\n**Quantum Backend (`src/backend/quantum.rs`):**\n\n- Generate Qiskit circuit\n- Add encoding gates (ry, initialize)\n- Add measurement\n- Return to Python orchestrator\n\n**Python Orchestrator (NEW: `src/backend/orchestrator.rs`):**\n\n- Generate Python script that:\n  1. Runs GPU code (WebGPU)\n  2. Extracts GPU results\n  3. Encodes into quantum circuit\n  4. Runs quantum code (Qiskit)\n  5. Extracts quantum results\n  6. Returns final result\n\n---\n\n## ðŸ“ Example: Full Pipeline\n\n### **QuarkDSL Code:**\n\n```rust\n@gpu\nfn preprocess(data: [float]) -> [float] {\n    let result = [0.0, 0.0, 0.0, 0.0];\n    for i in 0..4 {\n        result[i] = data[i] * 2.0;\n    }\n    return result;\n}\n\n@quantum\nfn quantum_process(params: [float]) -> int {\n    ry(0, params[0]);\n    ry(1, params[1]);\n    cx(0, 1);\n    return measure(0);\n}\n\nfn main() -> int {\n    let data = [0.5, 0.3, 0.7, 0.2];\n    let features = preprocess(data);        // GPU\n    let result = quantum_process(features); // GPU â†’ Quantum\n    return result;\n}\n```\n\n### **Generated Python Orchestrator:**\n\n```python\nimport numpy as np\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\n# Step 1: Run GPU code\ndef preprocess_gpu(data):\n    # WGSL shader execution (WebGPU)\n    result = data * 2.0  # Simplified\n    return result\n\n# Step 2: GPU â†’ Quantum conversion\ndef encode_to_quantum(params):\n    qr = QuantumRegister(2, 'q')",
      "type": "markdown",
      "keywords": [
        "data",
        "marshalling",
        "design",
        "preprocess",
        "quantum_process",
        "main",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "ir",
        "backend",
        "orchestrator",
        "if",
        "gate",
        "measure",
        "buffer"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "docs/data-marshalling-design.md:211-284",
      "filePath": "docs/data-marshalling-design.md",
      "fileName": "data-marshalling-design.md",
      "content": "\n# Step 1: Run GPU code\ndef preprocess_gpu(data):\n    # WGSL shader execution (WebGPU)\n    result = data * 2.0  # Simplified\n    return result\n\n# Step 2: GPU â†’ Quantum conversion\ndef encode_to_quantum(params):\n    qr = QuantumRegister(2, 'q')\n    cr = ClassicalRegister(2, 'c')\n    circuit = QuantumCircuit(qr, cr)\n\n    # Angle encoding\n    circuit.ry(params[0], qr[0])\n    circuit.ry(params[1], qr[1])\n    circuit.cx(qr[0], qr[1])\n    circuit.measure(qr[0], cr[0])\n\n    return circuit\n\n# Step 3: Run quantum code\ndef quantum_process(circuit):\n    service = QiskitRuntimeService()\n    backend = service.backend(\"ibm_brisbane\")\n    job = backend.run(circuit, shots=1024)\n    counts = job.result().get_counts()\n\n    # Extract result (most common measurement)\n    result = int(max(counts, key=counts.get)[0])\n    return result\n\n# Main orchestration\ndef main():\n    data = np.array([0.5, 0.3, 0.7, 0.2])\n\n    # GPU execution\n    features = preprocess_gpu(data)\n\n    # Quantum execution\n    circuit = encode_to_quantum(features)\n    result = quantum_process(circuit)\n\n    return result\n\nif __name__ == \"__main__\":\n    print(main())\n```\n\n---\n\n## Implementation Status\n\nAll phases are complete:\n\n1. **Phase 5A:** Detect cross-domain calls - COMPLETE\n2. **Phase 5B:** Add conversion IR instructions - COMPLETE\n3. **Phase 5C:** Generate conversion code in backends - COMPLETE\n4. **Phase 5D:** Generate Python orchestrator - COMPLETE\n5. **Phase 5E:** Test end-to-end - COMPLETE\n6. **Phase 6:** TypeScript VM with quantum simulation - COMPLETE\n\n### TypeScript VM Implementation\n\nThe TypeScript VM provides an alternative execution path with built-in quantum simulation:\n\n- Stack-based bytecode interpreter\n- 8-qubit quantum state vector simulator\n- Quantum gates: H, X, Y, Z, RX, RY, RZ, CNOT, SWAP, Toffoli\n- Probabilistic measurement with state collapse\n- Web playground for interactive development\n\nSee `quarkdsl-web/lib/vm/` for implementation details.\n",
      "type": "markdown",
      "keywords": [
        "data",
        "marshalling",
        "design",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "type",
        "ir",
        "backend",
        "orchestrator",
        "if",
        "qubit",
        "gate",
        "measure"
      ],
      "startLine": 211,
      "endLine": 284
    },
    {
      "id": "docs/hybrid-design.md:1-80",
      "filePath": "docs/hybrid-design.md",
      "fileName": "hybrid-design.md",
      "content": "# QuarkDSL Hybrid Language Design\n\n## 1. Core Concepts\n\n### Domain Annotations\n\nFunctions can be annotated with their execution domain:\n\n```rust\n@gpu\nfn matrix_multiply(a: [float], b: [float]) -> [float] {\n    // Executes on GPU, generates WGSL\n}\n\n@quantum\nfn apply_hadamard(qubits: [qubit]) -> [qubit] {\n    // Executes on quantum computer, generates Qiskit\n}\n\n// No annotation = classical CPU\nfn preprocess(data: [float]) -> [float] {\n    // Executes on CPU\n}\n```\n\n### Hybrid Workflows\n\nFunctions can call across domains - compiler handles conversions:\n\n```rust\nfn hybrid_pipeline(data: [float]) -> [float] {\n    let features = gpu_extract(data);      // GPU\n    let qstate = quantum_encode(features); // Auto: GPU â†’ Quantum\n    let result = quantum_vqe(qstate);      // Quantum\n    let output = gpu_classify(result);     // Auto: Quantum â†’ GPU\n    return output;\n}\n```\n\n## 2. Type System Extensions\n\n### New Types\n\n- `tensor<T>` - GPU tensor (WGSL buffer)\n- `qstate` - Quantum state (Qiskit QuantumCircuit)\n- `qubit` - Single qubit reference\n\n### Type Compatibility\n\n```rust\n// Explicit conversions\nlet gpu_data: tensor<float> = [1.0, 2.0, 3.0];\nlet qstate: qstate = to_quantum(gpu_data);  // GPU â†’ Quantum\nlet result: tensor<float> = to_gpu(qstate); // Quantum â†’ GPU\n\n// Implicit conversions (when calling across domains)\n@quantum\nfn quantum_op(q: qstate) -> qstate { ... }\n\n@gpu\nfn gpu_op(t: tensor<float>) -> tensor<float> { ... }\n\nfn hybrid() {\n    let t = gpu_op([1.0, 2.0]);\n    let q = quantum_op(t);  // Compiler inserts: to_quantum(t)\n    let result = gpu_op(q); // Compiler inserts: to_gpu(q)\n}\n```\n\n## 3. Standard Library\n\n### GPU Operations (WGSL backend)\n\n```rust\n@gpu fn matmul(a: tensor<float>, b: tensor<float>) -> tensor<float>\n@gpu fn softmax(x: tensor<float>) -> tensor<float>\n@gpu fn relu(x: tensor<float>) -> tensor<float>\n@gpu fn reduce_sum(x: tensor<float>) -> float\n```\n",
      "type": "markdown",
      "keywords": [
        "hybrid",
        "design",
        "matrix_multiply",
        "apply_hadamard",
        "preprocess",
        "hybrid_pipeline",
        "quantum_op",
        "gpu_op",
        "matmul",
        "softmax",
        "relu",
        "reduce_sum",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "ir",
        "backend",
        "function",
        "if",
        "qubit",
        "buffer"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "docs/hybrid-design.md:71-150",
      "filePath": "docs/hybrid-design.md",
      "fileName": "hybrid-design.md",
      "content": "\n### GPU Operations (WGSL backend)\n\n```rust\n@gpu fn matmul(a: tensor<float>, b: tensor<float>) -> tensor<float>\n@gpu fn softmax(x: tensor<float>) -> tensor<float>\n@gpu fn relu(x: tensor<float>) -> tensor<float>\n@gpu fn reduce_sum(x: tensor<float>) -> float\n```\n\n### Quantum Operations (Qiskit backend)\n\n```rust\n@quantum fn h(q: qubit) -> qubit           // Hadamard\n@quantum fn cx(ctrl: qubit, targ: qubit)   // CNOT\n@quantum fn ry(q: qubit, theta: float)     // RY rotation\n@quantum fn measure(q: qubit) -> int       // Measurement\n```\n\n### Hybrid Algorithms\n\n```rust\n// Variational Quantum Eigensolver\nfn vqe(hamiltonian: tensor<float>, ansatz: fn(tensor<float>) -> qstate) -> float {\n    let params = init_params_gpu();\n    for i in 0..100 {\n        let energy = vqe_step(params, hamiltonian, ansatz);\n        params = adam_update_gpu(params, energy);\n    }\n    return energy;\n}\n\n// Quantum Approximate Optimization Algorithm\nfn qaoa(cost_hamiltonian: tensor<float>, layers: int) -> tensor<float> {\n    let params = init_params_gpu();\n    for i in 0..100 {\n        let cost = qaoa_step(params, cost_hamiltonian, layers);\n        params = optimize_gpu(params, cost);\n    }\n    return params;\n}\n```\n\n## 4. Example: VQE (Variational Quantum Eigensolver)\n\n### QuarkDSL Code\n\n```rust\n@quantum\nfn ansatz(params: [float], qubits: [qubit]) -> [qubit] {\n    for i in 0..len(qubits) {\n        ry(qubits[i], params[i]);\n    }\n    for i in 0..len(qubits)-1 {\n        cx(qubits[i], qubits[i+1]);\n    }\n    return qubits;\n}\n\n@quantum\nfn measure_energy(qubits: [qubit], hamiltonian: [float]) -> float {\n    let counts = measure_all(qubits);\n    return expectation_value(counts, hamiltonian);\n}\n\n@gpu\nfn optimize_params(params: tensor<float>, gradient: tensor<float>) -> tensor<float> {\n    let lr = 0.01;\n    return params - lr * gradient;\n}\n\nfn vqe_main() -> tensor<float> {\n    // Initialize on GPU\n    let params = init_random_gpu(4);\n    let hamiltonian = [1.0, 0.5, 0.5, 1.0];\n\n    // Optimization loop\n    for iter in 0..100 {\n        // GPU â†’ Quantum (automatic)\n        let qubits = ansatz(params, [q0, q1, q2, q3]);",
      "type": "markdown",
      "keywords": [
        "hybrid",
        "design",
        "matmul",
        "softmax",
        "relu",
        "reduce_sum",
        "h",
        "cx",
        "ry",
        "measure",
        "vqe",
        "qaoa",
        "ansatz",
        "measure_energy",
        "optimize_params",
        "vqe_main",
        "wgsl",
        "quantum",
        "gpu",
        "optimize",
        "backend",
        "loop",
        "qubit"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "docs/hybrid-design.md:141-220",
      "filePath": "docs/hybrid-design.md",
      "fileName": "hybrid-design.md",
      "content": "\nfn vqe_main() -> tensor<float> {\n    // Initialize on GPU\n    let params = init_random_gpu(4);\n    let hamiltonian = [1.0, 0.5, 0.5, 1.0];\n\n    // Optimization loop\n    for iter in 0..100 {\n        // GPU â†’ Quantum (automatic)\n        let qubits = ansatz(params, [q0, q1, q2, q3]);\n\n        // Quantum execution\n        let energy = measure_energy(qubits, hamiltonian);\n\n        // Quantum â†’ GPU (automatic)\n        let grad = compute_gradient_gpu(energy);\n\n        // GPU optimization\n        params = optimize_params(params, grad);\n    }\n\n    return params;\n}\n```\n\n### Generated Code (Hybrid Orchestration)\n\n```python\nimport torch\nfrom qiskit import QuantumCircuit, execute\n\ndef vqe_main():\n    # GPU initialization\n    params = torch.randn(4).cuda()\n    hamiltonian = torch.tensor([1.0, 0.5, 0.5, 1.0]).cuda()\n\n    for iter in range(100):\n        # AUTO: GPU â†’ Quantum conversion\n        params_cpu = params.cpu().numpy()\n\n        # Quantum execution\n        circuit = QuantumCircuit(4)\n        for i in range(4):\n            circuit.ry(params_cpu[i], i)\n        for i in range(3):\n            circuit.cx(i, i+1)\n\n        result = execute(circuit, backend).result()\n        energy_cpu = compute_expectation(result, hamiltonian.cpu().numpy())\n\n        # AUTO: Quantum â†’ GPU conversion\n        energy = torch.tensor(energy_cpu).cuda()\n\n        # GPU optimization\n        grad = torch.autograd.grad(energy, params)[0]\n        params = params - 0.01 * grad\n\n    return params\n```\n\n## 5. Compilation Strategy\n\n### Domain Detection\n\n1. Parse `@gpu` and `@quantum` annotations\n2. Build call graph with domain information\n3. Detect cross-domain calls\n4. Insert conversion nodes in IR\n\n### Code Generation\n\n1. **GPU functions** - Generate WGSL compute shaders\n2. **Quantum functions** - Generate Qiskit circuits\n3. **Hybrid orchestrator** - Generate Python glue code with:\n   - GPU execution (via WebGPU or PyTorch)\n   - Quantum execution (via Qiskit)\n   - Automatic data marshalling\n\n### Optimization\n",
      "type": "markdown",
      "keywords": [
        "hybrid",
        "design",
        "vqe_main",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "optimize",
        "ir",
        "backend",
        "orchestrator",
        "function",
        "loop",
        "qubit",
        "measure"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "docs/hybrid-design.md:211-248",
      "filePath": "docs/hybrid-design.md",
      "fileName": "hybrid-design.md",
      "content": "\n1. **GPU functions** - Generate WGSL compute shaders\n2. **Quantum functions** - Generate Qiskit circuits\n3. **Hybrid orchestrator** - Generate Python glue code with:\n   - GPU execution (via WebGPU or PyTorch)\n   - Quantum execution (via Qiskit)\n   - Automatic data marshalling\n\n### Optimization\n\n1. **Fusion**: Combine consecutive GPU operations\n2. **Batching**: Batch multiple quantum circuits\n3. **Caching**: Cache conversion results when possible\n4. **Pipelining**: Overlap GPU and Quantum execution\n\n## 6. Implementation Status\n\nAll features are complete:\n\n1. Lexer with `@gpu`, `@quantum` tokens - COMPLETE\n2. Parser with annotation support - COMPLETE\n3. `tensor<T>` and `qstate` types in AST - COMPLETE\n4. Type checker for cross-domain calls - COMPLETE\n5. IR with domain markers - COMPLETE\n6. Hybrid code generation - COMPLETE\n7. TypeScript VM with quantum simulation - COMPLETE\n\n### TypeScript VM\n\nThe TypeScript VM provides an alternative execution path:\n\n- Stack-based bytecode interpreter\n- 8-qubit quantum state vector simulator\n- Quantum gates: H, X, Y, Z, RX, RY, RZ, CNOT, SWAP, Toffoli\n- Web playground for interactive development\n\nSee `quarkdsl-web/lib/vm/` for implementation details.\n",
      "type": "markdown",
      "keywords": [
        "hybrid",
        "design",
        "lexer",
        "parser",
        "ast",
        "token",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "type",
        "check",
        "ir",
        "orchestrator",
        "function",
        "qubit",
        "gate"
      ],
      "startLine": 211,
      "endLine": 248
    },
    {
      "id": "docs/IBM_QUANTUM_INTEGRATION.md:1-80",
      "filePath": "docs/IBM_QUANTUM_INTEGRATION.md",
      "fileName": "IBM_QUANTUM_INTEGRATION.md",
      "content": "# IBM Quantum Hardware Integration\n\nQuarkDSL supports execution on real IBM Quantum hardware.\n\n---\n\n## Configuration\n\n### Generated Code Configuration\n\nAll generated Python code includes a configuration flag:\n\n```python\nUSE_QUANTUM_COMPUTER = False  # Set to True to use IBM Quantum hardware\nIBM_API_KEY = \"krPjNWz0BsR_PSI0UVVG_VxIFSA27a5SaEgpLlI22-F-\"\n```\n\n### Switching Between Simulator and Hardware\n\n| Mode | Configuration | Execution |\n|------|---------------|-----------|\n| **Simulator** (default) | `USE_QUANTUM_COMPUTER = False` | Local Qiskit Aer simulator |\n| **IBM Quantum Hardware** | `USE_QUANTUM_COMPUTER = True` | Real IBM Quantum computer |\n\n---\n\n## Usage\n\n### Step 1: Compile QuarkDSL Code\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t orchestrator -o demo.py\n```\n\n### Step 2: Edit Configuration (Optional)\n\nOpen `demo.py` and set:\n\n```python\nUSE_QUANTUM_COMPUTER = True  # Enable IBM Quantum hardware\n```\n\n### Step 3: Install Dependencies\n\n```bash\npip install qiskit qiskit-ibm-runtime qiskit-aer numpy\n```\n\n### Step 4: Run\n\n#### Using Simulator (default)\n\n```bash\npython demo.py\n```\n\nOutput:\n```\nUsing local Qiskit Aer simulator\nCounts: {'00': 512, '11': 512}\nResult: 0\n```\n\n#### Using IBM Quantum Hardware\n\n```bash\npython demo.py\n```\n\nOutput:\n```\nConnecting to IBM Quantum...\nUsing IBM Quantum backend: ibm_brisbane\nJob ID: abc123xyz\nWaiting for results...\nCounts: {'00': 498, '11': 526}\nResult: 3\n```\n\n---",
      "type": "markdown",
      "keywords": [
        "ibm",
        "quantum",
        "integration",
        "compile",
        "gpu",
        "backend",
        "orchestrator",
        "if",
        "hybrid"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "docs/IBM_QUANTUM_INTEGRATION.md:71-150",
      "filePath": "docs/IBM_QUANTUM_INTEGRATION.md",
      "fileName": "IBM_QUANTUM_INTEGRATION.md",
      "content": "```\nConnecting to IBM Quantum...\nUsing IBM Quantum backend: ibm_brisbane\nJob ID: abc123xyz\nWaiting for results...\nCounts: {'00': 498, '11': 526}\nResult: 3\n```\n\n---\n\n## How It Works\n\n### Simulator Mode (`USE_QUANTUM_COMPUTER = False`)\n\n```python\ndef run_quantum_circuit(circuit, shots=1024):\n    print(\"Using local Qiskit Aer simulator\")\n    simulator = AerSimulator()\n    job = simulator.run(circuit, shots=shots)\n    result = job.result()\n    counts = result.get_counts()\n    return counts\n```\n\n### Hardware Mode (`USE_QUANTUM_COMPUTER = True`)\n\n```python\ndef run_quantum_circuit(circuit, shots=1024):\n    service = QiskitRuntimeService(channel=\"ibm_quantum\", token=IBM_API_KEY)\n    backend = service.least_busy(operational=True, simulator=False)\n    print(f\"Using IBM Quantum backend: {backend.name}\")\n    \n    sampler = Sampler(backend)\n    job = sampler.run([circuit], shots=shots)\n    result = job.result()\n    \n    pub_result = result[0]\n    counts_dict = pub_result.data.meas.get_counts()\n    return counts_dict\n```\n\n---\n\n## Backend Selection\n\n### Automatic Selection\n\nThe code automatically selects the least busy IBM Quantum backend:\n\n```python\nbackend = service.least_busy(operational=True, simulator=False)\n```\n\n### Manual Backend Selection (Advanced)\n\nEdit generated code to specify a backend:\n\n```python\nbackend = service.backend(\"ibm_brisbane\")  # Specific backend\n```\n\n---\n\n## API Key Management\n\n### Current Setup\n\nAPI key is embedded in generated code:\n\n```python\nIBM_API_KEY = \"krPjNWz0BsR_PSI0UVVG_VxIFSA27a5SaEgpLlI22-F-\"\n```\n\n### Best Practice (Production)\n\nUse environment variables:\n\n```python\nimport os",
      "type": "markdown",
      "keywords": [
        "ibm",
        "quantum",
        "integration",
        "ast",
        "token",
        "ir",
        "backend",
        "variable",
        "if"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "docs/IBM_QUANTUM_INTEGRATION.md:141-220",
      "filePath": "docs/IBM_QUANTUM_INTEGRATION.md",
      "fileName": "IBM_QUANTUM_INTEGRATION.md",
      "content": "```python\nIBM_API_KEY = \"krPjNWz0BsR_PSI0UVVG_VxIFSA27a5SaEgpLlI22-F-\"\n```\n\n### Best Practice (Production)\n\nUse environment variables:\n\n```python\nimport os\nIBM_API_KEY = os.getenv(\"IBM_QUANTUM_API_KEY\", \"your-key-here\")\n```\n\nSet environment variable:\n\n```bash\nexport IBM_QUANTUM_API_KEY=\"krPjNWz0BsR_PSI0UVVG_VxIFSA27a5SaEgpLlI22-F-\"\npython demo.py\n```\n\n---\n\n## Execution Time\n\n| Mode | Typical Time |\n|------|--------------|\n| Simulator | < 1 second |\n| IBM Quantum Hardware | 1-10 minutes (queue time + execution) |\n\n---\n\n## Troubleshooting\n\n### Error: Invalid API Key\n\n```\nIBMAccountError: Invalid token\n```\n\n**Solution:** Verify API key in generated code.\n\n### Error: No Backend Available\n\n```\nQiskitBackendNotFoundError: No backend found\n```\n\n**Solution:** Check IBM Quantum account has access to backends.\n\n### Error: Job Failed\n\n```\nRuntimeJobFailureError: Job failed\n```\n\n**Solution:** Check circuit is compatible with hardware (gate set, qubit count).\n\n---\n\n## Example Output Comparison\n\n### Simulator Output\n\n```\nUsing local Qiskit Aer simulator\nCounts: {'00': 512, '11': 512}\n```\n\n### Hardware Output\n\n```\nConnecting to IBM Quantum...\nUsing IBM Quantum backend: ibm_brisbane\nJob ID: abc123xyz456\nWaiting for results...\nCounts: {'00': 498, '01': 13, '10': 15, '11': 498}\n```\n\nNote: Hardware results include noise and errors.\n",
      "type": "markdown",
      "keywords": [
        "ibm",
        "quantum",
        "integration",
        "token",
        "check",
        "error",
        "ir",
        "backend",
        "variable",
        "if",
        "qubit",
        "gate"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "docs/IBM_QUANTUM_INTEGRATION.md:211-240",
      "filePath": "docs/IBM_QUANTUM_INTEGRATION.md",
      "fileName": "IBM_QUANTUM_INTEGRATION.md",
      "content": "```\nConnecting to IBM Quantum...\nUsing IBM Quantum backend: ibm_brisbane\nJob ID: abc123xyz456\nWaiting for results...\nCounts: {'00': 498, '01': 13, '10': 15, '11': 498}\n```\n\nNote: Hardware results include noise and errors.\n\n---\n\n## Supported Backends\n\nAll generated code works with:\n\n- Qiskit Aer (simulator)\n- IBM Quantum hardware (127+ qubit systems)\n- IBM Quantum simulators (cloud-based)\n\n---\n\n## Notes\n\n- Hardware execution requires valid IBM Quantum account\n- Queue times vary based on backend availability\n- Hardware results include quantum noise\n- Simulator results are ideal (no noise)\n\n",
      "type": "markdown",
      "keywords": [
        "ibm",
        "quantum",
        "integration",
        "error",
        "ir",
        "backend",
        "qubit"
      ],
      "startLine": 211,
      "endLine": 240
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:1-80",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "# QuarkDSL Project Proposal\n\n**Course:** COMP6062001 â€“ Compilation Techniques  \n**Project:** QuarkDSL - Unified Hybrid Quantum-Classical Compiler  \n**Week:** 10 Milestone Submission  \n**Date:** [Insert Date]\n\n---\n\n## Table of Contents\n\n1. [Introduction](#1-introduction)\n2. [Problem Statement](#2-problem-statement)\n3. [Proposed Solution](#3-proposed-solution)\n4. [Language Design](#4-language-design)\n5. [Compiler Architecture](#5-compiler-architecture)\n6. [Implementation Details](#6-implementation-details)\n7. [Progress Report](#7-progress-report)\n8. [Challenges & Solutions](#8-challenges--solutions)\n9. [Timeline & Next Steps](#9-timeline--next-steps)\n10. [References](#10-references)\n\n---\n\n## 1. Introduction\n\n### 1.1 Background\n\nQuantum computing is emerging as a powerful paradigm for solving complex computational problems. However, practical quantum algorithms often require hybrid workflows that combine:\n\n- **Classical preprocessing** (data preparation, feature extraction)\n- **Quantum computation** (quantum algorithms, circuit execution)\n- **Classical postprocessing** (result analysis, optimization)\n\nCurrent tools require developers to manually orchestrate these workflows using multiple frameworks (PyTorch, Qiskit, NumPy), leading to:\n\n- Manual data conversion between frameworks\n- Error-prone boilerplate code\n- No cross-domain optimization\n- Steep learning curve\n\n### 1.2 Motivation\n\nQuarkDSL addresses this problem by providing a **unified language** for hybrid quantum-classical programming with:\n\n- Domain annotations for execution targeting\n- Automatic data marshalling between GPU and quantum domains\n- Cross-domain type checking\n- Multi-backend code generation\n\nThis project demonstrates advanced compiler techniques while solving a real research problem in quantum computing.\n\n---\n\n## 2. Problem Statement\n\n### 2.1 Current Approach\n\nHybrid quantum-classical workflows currently require:\n\n```python\n# Example: Manual hybrid workflow\nimport torch\nfrom qiskit import QuantumCircuit, execute, Aer\n\n# 1. GPU preprocessing\ndata = torch.randn(100).cuda()\nfeatures = neural_network(data)\n\n# 2. Manual conversion - TEDIOUS!\nfeatures_cpu = features.cpu().numpy()\n\n# 3. Quantum encoding - MANUAL!\ncircuit = QuantumCircuit(4)\nfor i, val in enumerate(features_cpu[:4]):\n    circuit.ry(val, i)\ncircuit.cx(0, 1)\n\n# 4. Execution\nbackend = Aer.get_backend('qasm_simulator')",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "compile",
        "quantum",
        "gpu",
        "type",
        "check",
        "error",
        "ir",
        "backend",
        "statement",
        "if",
        "hybrid"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:71-150",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "features_cpu = features.cpu().numpy()\n\n# 3. Quantum encoding - MANUAL!\ncircuit = QuantumCircuit(4)\nfor i, val in enumerate(features_cpu[:4]):\n    circuit.ry(val, i)\ncircuit.cx(0, 1)\n\n# 4. Execution\nbackend = Aer.get_backend('qasm_simulator')\njob = execute(circuit, backend, shots=1024)\nresult = job.result()\n\n# 5. Manual extraction - TEDIOUS!\ncounts = result.get_counts()\noutput = int(max(counts, key=counts.get), 2)\n```\n\n**Problems:**\n\n- 50+ lines of boilerplate\n- 3+ frameworks required\n- Manual type conversions\n- Error-prone\n- No optimization across domains\n\n### 2.2 Research Gap\n\nNo existing compiler provides:\n\n- Unified syntax for GPU + Quantum\n- Automatic data marshalling at compile time\n- Cross-domain optimization\n- Type-safe hybrid workflows\n\n---\n\n## 3. Proposed Solution\n\n### 3.1 QuarkDSL Language\n\nQuarkDSL provides a unified language with domain annotations:\n\n```rust\n@gpu\nfn preprocess(data: [float]) -> [float] {\n    // GPU computation\n    let result = [0.0, 0.0, 0.0, 0.0];\n    for i in 0..4 {\n        result[i] = data[i] * 2.0;\n    }\n    return result;\n}\n\n@quantum\nfn quantum_encode(features: [float]) -> int {\n    // Quantum computation\n    ry(0, features[0]);\n    ry(1, features[1]);\n    cx(0, 1);\n    return measure(0);\n}\n\nfn main() -> int {\n    let data = [1.0, 2.0, 3.0, 4.0];\n    let features = preprocess(data);      // GPU\n    let result = quantum_encode(features); // Quantum (AUTO-CONVERSION!)\n    return result;\n}\n```\n\n**Benefits:**\n\n- 10 lines vs 50+ lines\n- Single language\n- Automatic conversions\n- Type-safe\n- Optimizable\n\n### 3.2 Key Features",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "preprocess",
        "quantum_encode",
        "main",
        "compile",
        "quantum",
        "gpu",
        "type",
        "error",
        "ir",
        "backend",
        "if",
        "measure",
        "hybrid"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:141-220",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "\n**Benefits:**\n\n- 10 lines vs 50+ lines\n- Single language\n- Automatic conversions\n- Type-safe\n- Optimizable\n\n### 3.2 Key Features\n\n1. **Domain Annotations:** `@gpu`, `@quantum` for execution targeting\n2. **Automatic Data Marshalling:** Compiler inserts conversions automatically\n3. **Cross-Domain Type Checking:** Validates types across domains\n4. **Multi-Backend Code Generation:** WGSL (GPU), Qiskit (Quantum), Python (Orchestrator)\n5. **Executable Output:** Generates working Python code\n\n---\n\n## 4. Language Design\n\n### 4.1 Type System\n\n| Type        | Domain  | Description             |\n| ----------- | ------- | ----------------------- |\n| `int`       | All     | 32-bit integer          |\n| `float`     | All     | 64-bit floating point   |\n| `bool`      | All     | Boolean                 |\n| `[T]`       | All     | Array of type T         |\n| `tensor<T>` | GPU     | GPU tensor              |\n| `qstate`    | Quantum | Quantum state           |\n| `qubit`     | Quantum | Single qubit (internal) |\n\n### 4.2 Grammar (EBNF)\n\n```ebnf\nprogram     ::= function*\nfunction    ::= domain? \"fn\" IDENT \"(\" params \")\" \"->\" type block\ndomain      ::= \"@gpu\" | \"@quantum\"\nparams      ::= (param (\",\" param)*)?\nparam       ::= IDENT \":\" type\ntype        ::= \"int\" | \"float\" | \"bool\" | \"void\" | \"[\" type \"]\"\n              | \"tensor\" \"<\" type \">\" | \"qstate\"\nblock       ::= \"{\" statement* \"}\"\nstatement   ::= let_stmt | if_stmt | for_stmt | return_stmt | expr_stmt\nlet_stmt    ::= \"let\" IDENT \"=\" expression \";\"\nif_stmt     ::= \"if\" expression block (\"else\" block)?\nfor_stmt    ::= \"for\" IDENT \"in\" expression \"..\" expression block\nreturn_stmt ::= \"return\" expression \";\"\nexpr_stmt   ::= expression \";\"\nexpression  ::= binary_op | call | array_index | literal | IDENT\nbinary_op   ::= expression (\"+\" | \"-\" | \"*\" | \"/\" | \"==\" | \"<\" | \">\") expression\ncall        ::= IDENT \"(\" args \")\"\narray_index ::= expression \"[\" expression \"]\"\nliteral     ::= INT | FLOAT | BOOL | array_literal\narray_literal ::= \"[\" (expression (\",\" expression)*)? \"]\"\n```\n\n### 4.3 Lexer Tokens\n\n```rust\n// Domain annotations\n@gpu, @quantum\n\n// Keywords\nfn, let, if, else, for, in, return\n\n// Types\nint, float, bool, void, tensor, qstate\n\n// Operators\n+, -, *, /, ==, <, >, =, ;, :, ,, ->, .., [, ], {, }, (, )\n\n// Literals\nINT, FLOAT, BOOL, IDENT\n```\n\n---\n\n## 5. Compiler Architecture",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "lexer",
        "token",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "check",
        "backend",
        "orchestrator",
        "expression",
        "statement",
        "function",
        "if",
        "qubit"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:211-290",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "// Operators\n+, -, *, /, ==, <, >, =, ;, :, ,, ->, .., [, ], {, }, (, )\n\n// Literals\nINT, FLOAT, BOOL, IDENT\n```\n\n---\n\n## 5. Compiler Architecture\n\n### 5.1 Pipeline Overview\n\n**Native Compiler (Rust):**\n\n```\nQuarkDSL Source (.tgpu)\n    â†“\nLexer (logos) - Tokenization\n    â†“\nParser (Recursive Descent) - AST Generation\n    â†“\nType Checker - Cross-domain validation\n    â†“\nIR Lowering (SSA) - Automatic conversion insertion\n    â†“\nOptimization (DCE, CSE)\n    â†“\nCode Generation\n    â”œâ”€â”€ WGSL (GPU)\n    â”œâ”€â”€ Qiskit (Quantum)\n    â””â”€â”€ Python Orchestrator (Hybrid)\n```\n\n**TypeScript VM (Web/Node.js):**\n\n```\nQuarkDSL Source (.tgpu)\n    â†“\nLexer (TypeScript) - Tokenization\n    â†“\nParser (Recursive Descent) - AST Generation\n    â†“\nCompiler - Bytecode Generation\n    â†“\nVM Execution\n    â”œâ”€â”€ Classical (stack-based)\n    â”œâ”€â”€ GPU (array simulation)\n    â””â”€â”€ Quantum (state vector simulation)\n```\n\n### 5.2 Parsing Algorithm\n\n**Algorithm:** Recursive Descent (LL(1))\n\n**Rationale:**\n\n- Simple to implement and understand\n- Efficient for our grammar (no left recursion)\n- Easy to extend with new features\n- Good error messages\n- Suitable for hand-written parsers\n\n**Complexity:** O(n) where n is the number of tokens\n\n### 5.3 IR Design\n\n**SSA-Based Intermediate Representation:**\n\n```\nfn hybrid_pipeline(input: [float]) -> int {\n  entry:\n    %0 = input                                    // Parameter\n    %1 = [1, 2, 3, 4]                            // Constant\n    %2 = convert_Classical_to_Gpu(%0, AngleEncoding)  // AUTO!\n    %3 = convert_Classical_to_Gpu(%1, AngleEncoding)  // AUTO!\n    %4 = call gpu_matmul(%2, %3)                 // GPU call\n    %5 = %4                                       // Assignment\n    %6 = convert_Classical_to_Quantum(%5, AngleEncoding) // AUTO!\n    %7 = call quantum_encode(%6)                 // Quantum call",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "hybrid_pipeline",
        "lexer",
        "parser",
        "ast",
        "token",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "check",
        "error",
        "ir",
        "lower",
        "orchestrator",
        "hybrid"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:281-360",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "fn hybrid_pipeline(input: [float]) -> int {\n  entry:\n    %0 = input                                    // Parameter\n    %1 = [1, 2, 3, 4]                            // Constant\n    %2 = convert_Classical_to_Gpu(%0, AngleEncoding)  // AUTO!\n    %3 = convert_Classical_to_Gpu(%1, AngleEncoding)  // AUTO!\n    %4 = call gpu_matmul(%2, %3)                 // GPU call\n    %5 = %4                                       // Assignment\n    %6 = convert_Classical_to_Quantum(%5, AngleEncoding) // AUTO!\n    %7 = call quantum_encode(%6)                 // Quantum call\n    return %7\n}\n```\n\n**Key Features:**\n\n- Static Single Assignment (SSA) form\n- Domain markers (@gpu, @quantum)\n- DomainConversion instruction (automatic!)\n- Type information preserved\n\n---\n\n## 6. Implementation Details\n\n### 6.1 Technology Stack\n\n- **Language:** Rust (for compiler implementation)\n- **Lexer:** logos library (regex-based tokenization)\n- **Parser:** Hand-written recursive descent\n- **IR:** Custom SSA-based representation\n- **Backends:** WGSL, Qiskit (Python), Python orchestrator\n\n### 6.2 Data Structures\n\n**AST Node:**\n\n```rust\npub struct Function {\n    pub name: String,\n    pub domain: Domain,  // Classical, Gpu, Quantum\n    pub params: Vec<Parameter>,\n    pub return_type: Type,\n    pub body: Block,\n}\n```\n\n**IR Instruction:**\n\n```rust\npub enum Instruction {\n    Assign { dest: SSAVar, value: Value },\n    BinaryOp { dest: SSAVar, op: BinOp, left: Value, right: Value },\n    Call { dest: Option<SSAVar>, function: String, args: Vec<Value> },\n    DomainConversion {\n        dest: SSAVar,\n        source: Value,\n        from_domain: Domain,\n        to_domain: Domain,\n        encoding: ConversionEncoding,\n    },\n    // ... more instructions\n}\n```\n\n### 6.3 Automatic Conversion Insertion\n\n**Algorithm:**\n\n1. **First Pass:** Collect all function domains into HashMap\n2. **Second Pass:** Lower AST to IR\n   - For each function call:\n     - Check if target domain differs from current domain\n     - If yes, insert DomainConversion instruction\n     - Skip for built-in quantum functions (h, ry, cx, etc.)\n\n**Complexity:** O(n) where n is the number of AST nodes\n\n---\n",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "hybrid_pipeline",
        "function",
        "instruction",
        "lexer",
        "parser",
        "ast",
        "token",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "check",
        "ir",
        "lower",
        "backend",
        "orchestrator",
        "if",
        "hybrid"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:351-430",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "2. **Second Pass:** Lower AST to IR\n   - For each function call:\n     - Check if target domain differs from current domain\n     - If yes, insert DomainConversion instruction\n     - Skip for built-in quantum functions (h, ry, cx, etc.)\n\n**Complexity:** O(n) where n is the number of AST nodes\n\n---\n\n## 7. Progress Report\n\n### 7.1 Completed Phases\n\nâœ… **Phase 1: Design (100%)**\n\n- Hybrid language design\n- Domain annotations syntax\n- Type system design\n- Data marshalling strategy\n\nâœ… **Phase 2: Frontend (100%)**\n\n- Lexer with domain tokens\n- Recursive descent parser\n- AST with domain markers\n- Error handling\n\nâœ… **Phase 3: Type System (100%)**\n\n- Cross-domain call detection\n- Type compatibility rules\n- Built-in quantum functions\n\nâœ… **Phase 4: IR & Optimization (100%)**\n\n- SSA-based IR\n- Automatic conversion insertion\n- Dead Code Elimination (DCE)\n- Common Subexpression Elimination (CSE)\n\nâœ… **Phase 5: Code Generation (100%)**\n\n- WGSL backend (GPU compute shaders)\n- Qiskit backend (quantum circuits)\n- Python orchestrator backend (hybrid execution)\n\nâœ… **Phase 6: TypeScript Virtual Machine (100%)**\n\n- Stack-based bytecode interpreter\n- 8-qubit quantum state vector simulator\n- Quantum gates: H, X, Y, Z, RX, RY, RZ, CNOT, SWAP, Toffoli\n- Web playground for interactive development\n- Browser and Node.js compatible\n\n### 7.2 Statistics\n\n- **Total Lines of Code:** ~6,500\n- **Rust Code:** ~2,800 lines\n- **TypeScript Code:** ~3,000 lines\n- **Documentation:** ~700 lines\n- **Build Status:** 0 errors, 0 warnings\n- **Test Status:** All tests passing\n\n### 7.3 Test Results\n\n```\nBuild: PASS\nParse: PASS (all examples)\nLower: PASS (IR generation with auto-conversions)\nWGSL Backend: PASS\nQuantum Backend: PASS\nOrchestrator Backend: PASS\nVQE Example: PASS (complex hybrid workflow)\nPython Execution: PASS\nTypeScript VM: PASS\nQuantum Simulator: PASS\nWeb Playground: PASS\n```\n",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "lexer",
        "parser",
        "ast",
        "token",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "type",
        "check",
        "error",
        "ir",
        "lower",
        "backend",
        "frontend",
        "orchestrator",
        "expression",
        "function",
        "if",
        "qubit",
        "gate",
        "hybrid"
      ],
      "startLine": 351,
      "endLine": 430
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:421-500",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "WGSL Backend: PASS\nQuantum Backend: PASS\nOrchestrator Backend: PASS\nVQE Example: PASS (complex hybrid workflow)\nPython Execution: PASS\nTypeScript VM: PASS\nQuantum Simulator: PASS\nWeb Playground: PASS\n```\n\n---\n\n## 8. Challenges & Solutions\n\n### 8.1 Challenge 1: Cross-Domain Type Checking\n\n**Problem:** How to validate types across GPU/Quantum boundaries?\n\n**Solution:** Extended type checker with domain-aware rules:\n\n- Track function domains in symbol table\n- Validate cross-domain calls\n- Ensure type compatibility for conversions\n\n### 8.2 Challenge 2: Automatic Conversion Insertion\n\n**Problem:** When and where to insert conversions?\n\n**Solution:** Two-pass IR lowering:\n\n1. First pass: Collect all function domains\n2. Second pass: Insert conversions at domain boundaries\n\n### 8.3 Challenge 3: Multi-Backend Code Generation\n\n**Problem:** Single IR â†’ 3 different output languages\n\n**Solution:** Modular backend architecture:\n\n- Shared IR representation\n- Backend-specific code generators\n- Common helper functions\n\n### 8.4 Challenge 4: Data Marshalling Strategies\n\n**Problem:** How to convert GPU tensors â†” Quantum states?\n\n**Solution:** Multiple encoding strategies:\n\n- **Angle Encoding:** Classical float â†’ Quantum rotation (ry gate)\n- **Amplitude Encoding:** Classical vector â†’ Quantum statevector\n- **Measurement Extraction:** Quantum counts â†’ Classical int\n\n---\n\n## 9. Timeline & Next Steps\n\n### 9.1 Completed Work\n\n- [x] Native Rust compiler with 3 backends\n- [x] TypeScript Virtual Machine with quantum simulator\n- [x] Web playground for interactive development\n- [x] 8-qubit quantum state vector simulation\n- [x] Full quantum gate set (H, X, Y, Z, RX, RY, RZ, CNOT, SWAP, Toffoli)\n\n### 9.2 Future Enhancements\n\n- [ ] Standard library for common patterns (VQE, QAOA)\n- [ ] Enhanced error messages with line numbers\n- [ ] More optimization passes (constant folding, loop unrolling)\n- [ ] Increase qubit limit in VM simulator\n- [ ] WebGPU integration for GPU operations\n\n### 9.3 Final Deliverables\n\n- [x] GitHub repository\n- [x] Web playground\n- [ ] Final presentation slides\n- [ ] Project report (max 20 pages)\n- [ ] Demo video (5 minutes)",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "check",
        "error",
        "ir",
        "lower",
        "backend",
        "orchestrator",
        "function",
        "loop",
        "if",
        "qubit",
        "gate",
        "measure",
        "hybrid"
      ],
      "startLine": 421,
      "endLine": 500
    },
    {
      "id": "docs/PROJECT_PROPOSAL.md:491-520",
      "filePath": "docs/PROJECT_PROPOSAL.md",
      "fileName": "PROJECT_PROPOSAL.md",
      "content": "- [ ] Increase qubit limit in VM simulator\n- [ ] WebGPU integration for GPU operations\n\n### 9.3 Final Deliverables\n\n- [x] GitHub repository\n- [x] Web playground\n- [ ] Final presentation slides\n- [ ] Project report (max 20 pages)\n- [ ] Demo video (5 minutes)\n\n### 9.4 Current Status\n\n**Overall Progress:** 100% Complete\n**Confidence Level:** HIGH\n\n---\n\n## 10. References\n\n1. Qiskit Documentation: https://qiskit.org/documentation/\n2. WebGPU Specification: https://www.w3.org/TR/webgpu/\n3. SSA Form: Cytron et al., \"Efficiently Computing Static Single Assignment Form\"\n4. Recursive Descent Parsing: Aho, Sethi, Ullman, \"Compilers: Principles, Techniques, and Tools\"\n5. VQE Algorithm: Peruzzo et al., \"A variational eigenvalue solver on a photonic quantum processor\"\n\n---\n\n**End of Proposal**\n",
      "type": "markdown",
      "keywords": [
        "project",
        "proposal",
        "compile",
        "quantum",
        "gpu",
        "if",
        "qubit"
      ],
      "startLine": 491,
      "endLine": 520
    },
    {
      "id": "examples/bell_state.tgpu:1-14",
      "filePath": "examples/bell_state.tgpu",
      "fileName": "bell_state.tgpu",
      "content": "fn h(q: int) -> void {\n    return;\n}\n\nfn cx(ctrl: int, target: int) -> void {\n    return;\n}\n\nfn main() -> int {\n    h(0);\n    cx(0, 1);\n    return 0;\n}\n",
      "type": "example",
      "keywords": [
        "bell",
        "state",
        "h",
        "cx",
        "main"
      ],
      "startLine": 1,
      "endLine": 14
    },
    {
      "id": "examples/bell_state_quantum.tgpu:1-15",
      "filePath": "examples/bell_state_quantum.tgpu",
      "fileName": "bell_state_quantum.tgpu",
      "content": "fn h(q: int) -> void {\n    return;\n}\n\nfn cx(ctrl: int, target: int) -> void {\n    return;\n}\n\nfn main() -> int {\n    h(0);\n    cx(0, 1);\n    return 0;\n}\n\n",
      "type": "example",
      "keywords": [
        "bell",
        "state",
        "quantum",
        "h",
        "cx",
        "main"
      ],
      "startLine": 1,
      "endLine": 15
    },
    {
      "id": "examples/bell_state_unix.tgpu:1-19",
      "filePath": "examples/bell_state_unix.tgpu",
      "fileName": "bell_state_unix.tgpu",
      "content": "fn h(q: int) -> void {\n    return;\n}\n\nfn cx(ctrl: int, target: int) -> void {\n    return;\n}\n\nfn create_bell_state() -> int {\n    h(0);\n    cx(0, 1);\n    return 0;\n}\n\nfn main() -> int {\n    return create_bell_state();\n}\n\n",
      "type": "example",
      "keywords": [
        "bell",
        "state",
        "unix",
        "h",
        "cx",
        "create_bell_state",
        "main"
      ],
      "startLine": 1,
      "endLine": 19
    },
    {
      "id": "examples/hybrid_simple.tgpu:1-54",
      "filePath": "examples/hybrid_simple.tgpu",
      "fileName": "hybrid_simple.tgpu",
      "content": "// Simple Hybrid Example\n// Demonstrates GPU + Quantum + Classical workflow\n\n// GPU function: Matrix multiplication\n@gpu\nfn gpu_matmul(a: [float], b: [float]) -> [float] {\n    let result = [0.0, 0.0, 0.0, 0.0];\n    for i in 0..4 {\n        result[i] = a[i] * b[i];\n    }\n    return result;\n}\n\n// Quantum function: Quantum encoding\n@quantum\nfn quantum_encode(data: [float]) -> int {\n    // Encode classical data into quantum state\n    ry(0, data[0]);\n    ry(1, data[1]);\n    cx(0, 1);\n    return 0;\n}\n\n// Quantum function: Quantum processing\n@quantum\nfn quantum_process() -> int {\n    h(0);\n    h(1);\n    cx(0, 1);\n    return measure(0);\n}\n\n// Classical orchestrator\nfn hybrid_pipeline(input: [float]) -> int {\n    // Step 1: GPU preprocessing\n    let weights = [1.0, 2.0, 3.0, 4.0];\n    let features = gpu_matmul(input, weights);\n    \n    // Step 2: Quantum encoding (auto: GPU â†’ Quantum)\n    quantum_encode(features);\n    \n    // Step 3: Quantum processing\n    let result = quantum_process();\n    \n    return result;\n}\n\nfn main() -> int {\n    let data = [0.5, 0.3, 0.7, 0.2];\n    let output = hybrid_pipeline(data);\n    return output;\n}\n\n",
      "type": "example",
      "keywords": [
        "hybrid",
        "simple",
        "gpu_matmul",
        "quantum_encode",
        "quantum_process",
        "hybrid_pipeline",
        "main",
        "quantum",
        "gpu",
        "orchestrator",
        "function",
        "measure"
      ],
      "startLine": 1,
      "endLine": 54
    },
    {
      "id": "examples/hybrid_vqe.tgpu:1-81",
      "filePath": "examples/hybrid_vqe.tgpu",
      "fileName": "hybrid_vqe.tgpu",
      "content": "// Hybrid VQE Example - Variational Quantum Eigensolver\n// Demonstrates GPU + Quantum hybrid workflow\n\n// GPU function: Initialize parameters\n@gpu\nfn init_params() -> [float] {\n    return [0.1, 0.2, 0.3, 0.4];\n}\n\n// Quantum function: Variational ansatz\n@quantum\nfn ansatz(params: [float]) -> int {\n    // Apply parameterized rotations\n    ry(0, params[0]);\n    ry(1, params[1]);\n    ry(2, params[2]);\n    ry(3, params[3]);\n    \n    // Entangling layer\n    cx(0, 1);\n    cx(1, 2);\n    cx(2, 3);\n    \n    return 0;\n}\n\n// Quantum function: Measure energy\n@quantum\nfn measure_hamiltonian() -> float {\n    // Measure all qubits\n    let m0 = measure(0);\n    let m1 = measure(1);\n    let m2 = measure(2);\n    let m3 = measure(3);\n    \n    // Compute expectation value (simplified)\n    return 0.5;\n}\n\n// GPU function: Optimize parameters\n@gpu\nfn adam_update(params: [float], gradient: [float]) -> [float] {\n    let lr = 0.01;\n    let updated = [0.0, 0.0, 0.0, 0.0];\n    \n    for i in 0..4 {\n        updated[i] = params[i] - lr * gradient[i];\n    }\n    \n    return updated;\n}\n\n// Classical orchestrator: Hybrid VQE loop\nfn vqe_main() -> [float] {\n    // Initialize on GPU\n    let params = init_params();\n    \n    // VQE optimization loop\n    for iter in 0..10 {\n        // Quantum: Run ansatz (auto GPU â†’ Quantum conversion)\n        ansatz(params);\n        \n        // Quantum: Measure energy\n        let energy = measure_hamiltonian();\n        \n        // GPU: Compute gradient (simplified)\n        let gradient = [0.01, 0.01, 0.01, 0.01];\n        \n        // GPU: Update parameters (auto Quantum â†’ GPU conversion)\n        params = adam_update(params, gradient);\n    }\n    \n    return params;\n}\n\nfn main() -> int {\n    let optimal_params = vqe_main();\n    return 0;\n}\n\n",
      "type": "example",
      "keywords": [
        "hybrid",
        "vqe",
        "init_params",
        "ansatz",
        "measure_hamiltonian",
        "adam_update",
        "vqe_main",
        "main",
        "quantum",
        "gpu",
        "optimize",
        "orchestrator",
        "function",
        "loop",
        "if",
        "qubit",
        "measure"
      ],
      "startLine": 1,
      "endLine": 81
    },
    {
      "id": "examples/quantum_test.tgpu:1-15",
      "filePath": "examples/quantum_test.tgpu",
      "fileName": "quantum_test.tgpu",
      "content": "fn h(q: int) -> void {\n    return;\n}\n\nfn cx(ctrl: int, target: int) -> void {\n    return;\n}\n\nfn main() -> int {\n    h(0);\n    cx(0, 1);\n    return 0;\n}\n\n",
      "type": "example",
      "keywords": [
        "quantum",
        "test",
        "h",
        "cx",
        "main"
      ],
      "startLine": 1,
      "endLine": 15
    },
    {
      "id": "examples/simple_array.tgpu:1-21",
      "filePath": "examples/simple_array.tgpu",
      "fileName": "simple_array.tgpu",
      "content": "// Simple array addition example for GPU backend\n\nfn add_arrays(a: [int], b: [int]) -> [int] {\n    let size = 10;\n    let result = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    \n    for i in 0..size {\n        result[i] = a[i] + b[i];\n    }\n    \n    return result;\n}\n\nfn main() -> int {\n    let arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let arr2 = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];\n    let sum = add_arrays(arr1, arr2);\n    return sum[0];\n}\n\n",
      "type": "example",
      "keywords": [
        "simple",
        "array",
        "add_arrays",
        "main",
        "gpu",
        "backend"
      ],
      "startLine": 1,
      "endLine": 21
    },
    {
      "id": "examples/simple_gpu.tgpu:1-26",
      "filePath": "examples/simple_gpu.tgpu",
      "fileName": "simple_gpu.tgpu",
      "content": "@gpu\nfn preprocess(x: [float]) -> [float] {\n    let result = [0.0, 0.0];\n    for i in 0..2 {\n        result[i] = x[i] * 2.0;\n    }\n    return result;\n}\n\n@gpu\nfn add_arrays(a: [float], b: [float]) -> [float] {\n    let result = [0.0, 0.0];\n    for i in 0..2 {\n        result[i] = a[i] + b[i];\n    }\n    return result;\n}\n\nfn main(input: [float]) -> [float] {\n    let doubled = preprocess(input);\n    let weights = [1.0, 2.0];\n    let final = add_arrays(doubled, weights);\n    return final;\n}\n\n",
      "type": "example",
      "keywords": [
        "simple",
        "gpu",
        "preprocess",
        "add_arrays",
        "main"
      ],
      "startLine": 1,
      "endLine": 26
    },
    {
      "id": "examples/test_loop.tgpu:1-24",
      "filePath": "examples/test_loop.tgpu",
      "fileName": "test_loop.tgpu",
      "content": "@gpu\nfn preprocess(x: [float]) -> [float] {\n    let result = [0.0, 0.0];\n    for i in 0..2 {\n        result[i] = x[i] * 2.0;\n    }\n    return result;\n}\n\n@quantum\nfn encode(data: [float]) -> int {\n    ry(0, data[0]);\n    ry(1, data[1]);\n    cx(0, 1);\n    return 0;\n}\n\nfn main(input: [float]) -> int {\n    let features = preprocess(input);\n    encode(features);\n    return 0;\n}\n\n",
      "type": "example",
      "keywords": [
        "test",
        "loop",
        "preprocess",
        "encode",
        "main",
        "quantum",
        "gpu"
      ],
      "startLine": 1,
      "endLine": 24
    },
    {
      "id": "examples/with_print.tgpu:1-29",
      "filePath": "examples/with_print.tgpu",
      "fileName": "with_print.tgpu",
      "content": "@gpu\nfn preprocess(x: [float]) -> [float] {\n    let result = [0.0, 0.0];\n    for i in 0..2 {\n        result[i] = x[i] * 2.0;\n    }\n    return result;\n}\n\n@gpu\nfn add_arrays(a: [float], b: [float]) -> [float] {\n    let result = [0.0, 0.0];\n    for i in 0..2 {\n        result[i] = a[i] + b[i];\n    }\n    return result;\n}\n\nfn main(input: [float]) -> [float] {\n    print_array(input);\n    let doubled = preprocess(input);\n    print_array(doubled);\n    let weights = [1.0, 2.0];\n    let final = add_arrays(doubled, weights);\n    print_array(final);\n    return final;\n}\n\n",
      "type": "example",
      "keywords": [
        "with",
        "print",
        "preprocess",
        "add_arrays",
        "main",
        "gpu"
      ],
      "startLine": 1,
      "endLine": 29
    },
    {
      "id": "project-requirements.md:1-80",
      "filePath": "project-requirements.md",
      "fileName": "project-requirements.md",
      "content": "---\r\n# COMP6062001 â€“ Compilation Techniques\r\n\r\n## Final Project: Application of Compilation Principles\r\n---\r\n\r\n## **Project Weight & Deadline**\r\n\r\n- **Weight:** 30% of the final grade\r\n- **Due:** Week 13\r\n- **Group Size:** Maximum 4 students per group\r\n\r\n---\r\n\r\n## **Project Description**\r\n\r\nThe project requires you to apply compiler design principles to a practical problem.\r\nYou may:\r\n\r\n- Create a **compiler** for a language so that it becomes executable.\r\n- Or build a **translator** that converts one language to another.\r\n\r\nDuring the project, you are also evaluated on coding, research, teamwork, presentation, and writing skills.\r\n\r\n---\r\n\r\n## **Project Requirements**\r\n\r\n### You must:\r\n\r\n- **Choose a specific problem** requiring lexing and parsing algorithms, with potential code optimization and machine code generation.\r\n- **Implement a lexer and one parsing algorithm**, such as:\r\n\r\n  - Recursive Descent Parsing (LL(1))\r\n  - Top-down Table-driven Parsing (LL(1))\r\n  - Bottom-up Table-driven Parsing (LALR or LR(1))\r\n\r\n- **Explain your algorithm design** and why it fits the problem.\r\n- **Provide analysis** of chosen algorithms (if relevantâ€”e.g., if you hand-coded your compiler).\r\n- **Demonstrate your implementation** and report your results.\r\n\r\n---\r\n\r\n## **Suggested Topics**\r\n\r\n- Custom â€œCOOLâ€-like language interpreter/compiler\r\n- HTML Checker / Parser\r\n- Malicious Code Detection\r\n- Translating LaTeX to HTML\r\n- Graph-drawing tool\r\n- Audio/video to text (English or Indonesian)\r\n- Audio-command user interface\r\n- And others\r\n\r\n---\r\n\r\n## **Instructions for Solution Implementation**\r\n\r\n- Work in a group of 2â€“4 members.\r\n- Divide work clearly from the beginning.\r\n- The final product must be an **application software**.\r\n- Any language and relevant libraries may be used.\r\n- **Acknowledge external sources** (code, images, methods, etc.).\r\n- **If more than 60% of your code is external, it may be considered plagiarism.**\r\n\r\n---\r\n\r\n## **Policy for AI Usage**\r\n\r\nYou may use AI assistance, **but** you must:\r\n\r\n- Acknowledge **how AI contributed** to your project.\r\n- Clearly state **which code is yours and which is AI-generated**.\r\n- Provide the **link to your ChatGPT prompts**.\r\n\r\nFailure to comply results in **heavy point deduction**.\r\n\r\n---\r\n\r\n## **Project Milestones & Grading**\r",
      "type": "markdown",
      "keywords": [
        "project",
        "requirements",
        "lexer",
        "parser",
        "compile",
        "check",
        "ir",
        "if"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "project-requirements.md:71-150",
      "filePath": "project-requirements.md",
      "fileName": "project-requirements.md",
      "content": "\r\n- Acknowledge **how AI contributed** to your project.\r\n- Clearly state **which code is yours and which is AI-generated**.\r\n- Provide the **link to your ChatGPT prompts**.\r\n\r\nFailure to comply results in **heavy point deduction**.\r\n\r\n---\r\n\r\n## **Project Milestones & Grading**\r\n\r\n| No  | Milestone Deliverable         | Week | Weight |\r\n| --- | ----------------------------- | ---- | ------ |\r\n| 1   | Project Idea Presentation     | 4â€“7  | 5%     |\r\n| 2   | Project Proposal Presentation | 10   | 15%    |\r\n| 3   | Project Final Presentation    | 13   | 80%    |\r\n|     | **Total**                     |      | 100%   |\r\n\r\n---\r\n\r\n## **Week 10 â€“ Project Milestone Requirements**\r\n\r\n### Submit:\r\n\r\n- Project proposal (max 10 pages)\r\n\r\n### Present:\r\n\r\n- Prepared slides\r\n- Progress report: accomplishments, issues, next steps\r\n\r\n---\r\n\r\n## **Week 13 â€“ Final Presentation Requirements**\r\n\r\n### Present:\r\n\r\n- Presentation slides\r\n- Live demo\r\n- Q&A session\r\n\r\n### Submit (Upload):\r\n\r\n- Presentation slides\r\n- Project Report (max 20 pages, excluding code)\r\n- GitHub link to program code\r\n- Demo video (max 5 minutes)\r\n\r\n---\r\n\r\n## **Project Report Guidelines**\r\n\r\nMax 20 pages (excluding code), single-spaced. Must include:\r\n\r\n1. **Introduction**\r\n\r\n   - Background and motivation\r\n   - Problem description\r\n\r\n2. **Related Work**\r\n\r\n   - Similar work done previously\r\n\r\n3. **Implementation**\r\n\r\n   - Formal description:\r\n\r\n     - **REGEX** for tokens\r\n     - **CFG/BNF/EBNF** for grammar\r\n\r\n   - Compiler or translator design\r\n   - Virtual Machine (if applicable)\r\n   - Complexity analysis of algorithms and data structures\r\n\r\n4. **Evaluation**\r\n\r\n   - Implementation details\r\n   - Comprehensive test cases\r\n\r\n5. **Discussions**\r",
      "type": "markdown",
      "keywords": [
        "project",
        "requirements",
        "token",
        "compile",
        "ir",
        "if"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "project-requirements.md:141-213",
      "filePath": "project-requirements.md",
      "fileName": "project-requirements.md",
      "content": "   - Compiler or translator design\r\n   - Virtual Machine (if applicable)\r\n   - Complexity analysis of algorithms and data structures\r\n\r\n4. **Evaluation**\r\n\r\n   - Implementation details\r\n   - Comprehensive test cases\r\n\r\n5. **Discussions**\r\n\r\n6. **Conclusion & Recommendation**\r\n\r\n7. **Program Manual**\r\n\r\n   - How to run the program (with screenshots)\r\n\r\n8. **Demo Video Link** (5 mins)\r\n\r\n9. **GitHub / ZIP link to source code**\r\n\r\n---\r\n\r\n## **Marking Guide**\r\n\r\n### **1. Interestingness of the Problem**\r\n\r\n- Poor â†’ Old problem + slow algorithm + small dataset\r\n- Fair â†’ Old problem + fast algorithm + small dataset\r\n- Good â†’ Old problem + fast algorithm + medium dataset\r\n- Excellent â†’ New applied problem + fast algorithms + medium dataset\r\n\r\n### **2. Suitability of Data Structures & Algorithms**\r\n\r\n- Poor â†’ Familiar but inappropriate\r\n- Fair â†’ Familiar & appropriate\r\n- Good â†’ Sophisticated choices but not fully optimized\r\n- Excellent â†’ Most suitable data structures selected\r\n\r\n### **3. Quality of Implementation**\r\n\r\n- Poor â†’ No documentation, cannot compile\r\n- Fair â†’ Minimal documentation, can run but buggy\r\n- Good â†’ Well-documented, runs well\r\n- Excellent â†’ Clean documentation, bug-free, user-friendly\r\n\r\n### **4. Difficulty of Implementation**\r\n\r\n- Poor â†’ 60% public code\r\n- Fair â†’ 40% public code\r\n- Good â†’ 20% public code\r\n- Excellent â†’ Mostly original code\r\n\r\n### **5. Teamwork**\r\n\r\n- Poor â†’ Both individual & overall scope not done\r\n- Fair â†’ Only overall scope done\r\n- Good â†’ Individual & overall scopes done well\r\n- Excellent â†’ Strong overall teamwork\r\n\r\n### **6. Documentation & Presentation**\r\n\r\n- Poor â†’ Report missing\r\n- Fair â†’ Acceptable but incomplete\r\n- Good â†’ Few writing deficiencies\r\n- Excellent â†’ Complete, high-quality report\r\n\r\n---\r\n\r\n**End of Document**\r\n\r\n---\r\n",
      "type": "markdown",
      "keywords": [
        "project",
        "requirements",
        "ast",
        "compile",
        "optimize",
        "ir",
        "if"
      ],
      "startLine": 141,
      "endLine": 213
    },
    {
      "id": "README.md:1-80",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "# QuarkDSL\n\nHybrid Quantum-Classical Compiler with TypeScript Virtual Machine\n\n---\n\n## Overview\n\n| Property         | Value                                                               |\n| ---------------- | ------------------------------------------------------------------- |\n| **Type**         | Source-to-source compiler (transpiler) + Virtual Machine            |\n| **Input**        | QuarkDSL (`.tgpu`)                                                  |\n| **Output**       | WGSL (WebGPU Shading Language), Qiskit Python, Python Orchestrator  |\n| **Language**     | Rust (native compiler), TypeScript (VM)                             |\n| **Parser**       | RDP (Recursive Descent Parser), LL(1)-style                         |\n| **Lexer**        | DFA (Deterministic Finite Automaton)-based                          |\n| **IR**           | SSA (Static Single Assignment) / Stack-based bytecode (VM)          |\n| **Backends**     | 3 (WGSL, Quantum, Orchestrator) + TypeScript VM                     |\n| **Optimization** | DCE (Dead Code Elimination), CSE (Common Subexpression Elimination) |\n| **Runtime**      | TypeScript VM with quantum simulator (8 qubits)                     |\n| **Status**       | Complete                                                            |\n\n---\n\n## Grammar (EBNF)\n\n```ebnf\nprogram     ::= function*\nfunction    ::= domain? \"fn\" IDENT \"(\" params \")\" \"->\" type block\ndomain      ::= \"@gpu\" | \"@quantum\"\nparams      ::= (param (\",\" param)*)?\nparam       ::= IDENT \":\" type\ntype        ::= \"int\" | \"float\" | \"bool\" | \"void\" | \"qubit\"\n              | \"[\" type (\"; INT)? \"]\"\n              | \"tensor\" \"<\" type \">\"\n              | \"qstate\"\nblock       ::= \"{\" statement* \"}\"\nstatement   ::= let_stmt | assign_stmt | if_stmt | for_stmt\n              | return_stmt | expr_stmt\nlet_stmt    ::= \"let\" IDENT (\":\" type)? \"=\" expression \";\"\nassign_stmt ::= IDENT (\"[\" expression \"]\")? \"=\" expression \";\"\nif_stmt     ::= \"if\" expression block (\"else\" block)?\nfor_stmt    ::= \"for\" IDENT \"in\" expression \"..\" expression block\nreturn_stmt ::= \"return\" expression? \";\"\nexpr_stmt   ::= expression \";\"\nexpression  ::= or_expr\nor_expr     ::= and_expr (\"||\" and_expr)*\nand_expr    ::= eq_expr (\"&&\" eq_expr)*\neq_expr     ::= cmp_expr ((\"==\" | \"!=\") cmp_expr)*\ncmp_expr    ::= term ((\"<\" | \"<=\" | \">\" | \">=\") term)*\nterm        ::= factor ((\"+\" | \"-\") factor)*\nfactor      ::= unary ((\"*\" | \"/\" | \"%\") unary)*\nunary       ::= (\"-\" | \"!\")? postfix\npostfix     ::= primary (\"[\" expression \"]\" | \"(\" args \")\")*\nprimary     ::= INT | FLOAT | \"true\" | \"false\" | IDENT\n              | \"[\" (expression (\",\" expression)*)? \"]\"\n              | \"(\" expression \")\"\n              | \"map\" \"(\" IDENT \",\" expression \")\"\nargs        ::= (expression (\",\" expression)*)?\n```\n\n---\n\n## Operator Precedence\n\n| Level       | Operators            | Associativity | Description                      |\n| ----------- | -------------------- | ------------- | -------------------------------- |\n| 1 (lowest)  | `\\|\\|`               | Left          | Logical OR                       |\n| 2           | `&&`                 | Left          | Logical AND                      |\n| 3           | `==`, `!=`           | Left          | Equality                         |\n| 4           | `<`, `<=`, `>`, `>=` | Left          | Comparison                       |\n| 5           | `+`, `-`             | Left          | Addition, Subtraction            |\n| 6           | `*`, `/`, `%`        | Left          | Multiplication, Division, Modulo |\n| 7           | `-`, `!`             | Right         | Unary negation, NOT              |\n| 8 (highest) | `[]`, `()`           | Left          | Array index, Function call       |\n\n---\n\n## Tokens\n",
      "type": "markdown",
      "keywords": [
        "readme",
        "lexer",
        "parser",
        "token",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "ir",
        "backend",
        "orchestrator",
        "expression",
        "statement",
        "function",
        "if",
        "qubit",
        "hybrid"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "README.md:71-150",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "| 4           | `<`, `<=`, `>`, `>=` | Left          | Comparison                       |\n| 5           | `+`, `-`             | Left          | Addition, Subtraction            |\n| 6           | `*`, `/`, `%`        | Left          | Multiplication, Division, Modulo |\n| 7           | `-`, `!`             | Right         | Unary negation, NOT              |\n| 8 (highest) | `[]`, `()`           | Left          | Array index, Function call       |\n\n---\n\n## Tokens\n\n### Keywords (8)\n\n```\nfn  let  return  if  else  for  in  map\n```\n\n### Annotations (2)\n\n```\n@gpu  @quantum\n```\n\n### Types (7)\n\n```\nint  float  bool  qubit  void  tensor  qstate\n```\n\n### Operators (19)\n\n```\n+  -  *  /  %  ==  !=  <  <=  >  >=  &&  ||  !  =\n```\n\n### Delimiters (11)\n\n```\n(  )  {  }  [  ]  ,  ;  :  ->  ..\n```\n\n### Literals (5)\n\n| Token   | Regex                     | Example     |\n| ------- | ------------------------- | ----------- |\n| `INT`   | `[0-9]+`                  | `123`       |\n| `FLOAT` | `[0-9]+\\.[0-9]+`          | `3.14`      |\n| `BOOL`  | `true \\| false`           | `true`      |\n| `IDENT` | `[a-zA-Z_][a-zA-Z0-9_]*`  | `foo`       |\n| `ARRAY` | `[` expr (`,` expr)\\* `]` | `[1, 2, 3]` |\n\n### Skip Rules\n\n```regex\n[ \\t\\n\\f]+      // Whitespace\n//[^\\n]*        // Single-line comments\n```\n\n---\n\n## Type System\n\n| Type    | Syntax            | Domain  | Example                  |\n| ------- | ----------------- | ------- | ------------------------ |\n| Integer | `int`             | All     | `let x: int = 5;`        |\n| Float   | `float`           | All     | `let y: float = 3.14;`   |\n| Boolean | `bool`            | All     | `let flag: bool = true;` |\n| Qubit   | `qubit`           | Quantum | `let q: qubit;`          |\n| Void    | `void`            | All     | `fn f() -> void`         |\n| Array   | `[T]` or `[T; N]` | All     | `let arr: [int; 10];`    |\n| Tensor  | `tensor<T>`       | GPU     | `let t: tensor<float>;`  |\n| QState  | `qstate`          | Quantum | `let s: qstate;`         |\n\n---\n\n## Compiler Pipeline\n\n```\n.tgpu Source\n    â†“\nLexer (DFA) â†’ Tokens (47 types)",
      "type": "markdown",
      "keywords": [
        "readme",
        " let",
        "f",
        "lexer",
        "token",
        "compile",
        "quantum",
        "gpu",
        "type",
        "function",
        "if",
        "qubit"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "README.md:141-220",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "| QState  | `qstate`          | Quantum | `let s: qstate;`         |\n\n---\n\n## Compiler Pipeline\n\n```\n.tgpu Source\n    â†“\nLexer (DFA) â†’ Tokens (47 types)\n    â†“\nParser (RDP) â†’ AST (Abstract Syntax Tree)\n    â†“\nType Checker â†’ Validated AST\n    â†“\nIR (Intermediate Representation) Lowering â†’ SSA IR (auto-conversion insertion)\n    â†“\nOptimization â†’ DCE (Dead Code Elimination), CSE (Common Subexpression Elimination)\n    â†“\nCode Generation / Execution\n    â”œâ”€â”€ WGSL (WebGPU Shading Language) Backend (GPU shaders)\n    â”œâ”€â”€ Quantum Backend (Qiskit circuits)\n    â”œâ”€â”€ Orchestrator Backend (Hybrid Python)\n    â””â”€â”€ TypeScript VM (Direct execution with quantum simulation)\n```\n\n---\n\n## Architecture\n\n### Frontend\n\n| Component    | File           | Technology                                   | Output                     |\n| ------------ | -------------- | -------------------------------------------- | -------------------------- |\n| Lexer        | `lexer.rs`     | Logos (DFA - Deterministic Finite Automaton) | Tokens                     |\n| Parser       | `parser.rs`    | RDP (Recursive Descent Parser)               | AST (Abstract Syntax Tree) |\n| Type Checker | `typecheck.rs` | Visitor pattern                              | Validated AST              |\n\n### Middle-end\n\n| Component    | File          | Algorithm                                                           | Output                            |\n| ------------ | ------------- | ------------------------------------------------------------------- | --------------------------------- |\n| IR Lowering  | `lower.rs`    | Two-pass (domain analysis + lowering)                               | SSA (Static Single Assignment) IR |\n| Optimization | `optimize.rs` | DCE (Dead Code Elimination), CSE (Common Subexpression Elimination) | Optimized IR                      |\n| IR Dump      | `dump.rs`     | Pretty-printer                                                      | Human-readable IR                 |\n\n### Backend\n\n| Component    | File              | Target | Output                                    |\n| ------------ | ----------------- | ------ | ----------------------------------------- |\n| WGSL         | `wgsl.rs`         | WebGPU | `.wgsl` (WebGPU Shading Language) shaders |\n| Quantum      | `quantum.rs`      | Qiskit | `.py` circuits                            |\n| Orchestrator | `orchestrator.rs` | Python | `.py` hybrid script                       |\n\n### Runtime (TypeScript VM)\n\n| Component         | File                   | Description                              |\n| ----------------- | ---------------------- | ---------------------------------------- |\n| Lexer             | `lexer.ts`             | DFA-based tokenizer                      |\n| Parser            | `parser.ts`            | Recursive descent parser                 |\n| Compiler          | `compiler.ts`          | AST to bytecode compiler                 |\n| Virtual Machine   | `vm.ts`                | Stack-based bytecode interpreter         |\n| Quantum Simulator | `quantum-simulator.ts` | 8-qubit quantum state simulator          |\n| Quantum Gates     | `quantum-gates.ts`     | H, X, Y, Z, RX, RY, RZ, CNOT, SWAP, etc. |\n\n---\n\n## Parser Design (RDP - Recursive Descent Parser)\n\n### Why Recursive Descent Parser (RDP)\n\n**Definition:** Each grammar rule implemented as a function that calls other functions recursively.\n\n### Implementation Evidence\n\n```rust\n// src/frontend/parser.rs\nfn parse_expression(&mut self) -> Result<Expression> {\n    self.parse_or()  // Calls parse_or\n}",
      "type": "markdown",
      "keywords": [
        "readme",
        "parse_expression",
        "lexer",
        "parser",
        "ast",
        "token",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "type",
        "check",
        "optimize",
        "ir",
        "lower",
        "backend",
        "frontend",
        "middle",
        "orchestrator",
        "expression",
        "function",
        "qubit",
        "gate",
        "hybrid"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "README.md:211-290",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "\n**Definition:** Each grammar rule implemented as a function that calls other functions recursively.\n\n### Implementation Evidence\n\n```rust\n// src/frontend/parser.rs\nfn parse_expression(&mut self) -> Result<Expression> {\n    self.parse_or()  // Calls parse_or\n}\n\nfn parse_or(&mut self) -> Result<Expression> {\n    let mut left = self.parse_and()?;  // Calls parse_and\n    while matches!(self.current(), Some(Token::OrOr)) {\n        self.advance();\n        let right = self.parse_and()?;\n        left = Expression::Binary { op: BinaryOp::Or, left, right };\n    }\n    Ok(left)\n}\n\nfn parse_and(&mut self) -> Result<Expression> {\n    let mut left = self.parse_equality()?;  // Calls parse_equality\n    // ...\n}\n```\n\n### Recursive Call Chain\n\n```\nparse_program()\n  â†’ parse_function()\n    â†’ parse_params()\n    â†’ parse_type()\n    â†’ parse_statements()\n      â†’ parse_statement()\n        â†’ parse_expression()\n          â†’ parse_or()\n            â†’ parse_and()\n              â†’ parse_equality()\n                â†’ parse_comparison()\n                  â†’ parse_term()\n                    â†’ parse_factor()\n                      â†’ parse_unary()\n                        â†’ parse_postfix()\n                          â†’ parse_primary()\n```\n\n### RDP (Recursive Descent Parser) Characteristics\n\n| Feature                       | QuarkDSL Implementation                                       |\n| ----------------------------- | ------------------------------------------------------------- |\n| One function per grammar rule | `parse_function()`, `parse_statement()`, `parse_expression()` |\n| Recursive calls               | Functions call each other recursively                         |\n| Hand-written                  | No parser generator used                                      |\n| Top-down parsing              | Starts from `parse_program()`                                 |\n| Predictive (1 lookahead)      | Uses `self.current()` to decide production                    |\n| LL(1)-style                   | LL(1) - Left-to-right, Leftmost derivation, 1 lookahead       |\n\n### Not RDP (Recursive Descent Parser)\n\n| Type                                                 | Characteristics    | QuarkDSL |\n| ---------------------------------------------------- | ------------------ | -------- |\n| Table-driven LL(1)                                   | Uses parse table   | No       |\n| Bottom-up (LR - Left-to-right, Rightmost derivation) | Shift-reduce       | No       |\n| Generated                                            | Yacc, Bison, ANTLR | No       |\n\n---\n\n## IR (Intermediate Representation) Design\n\n### SSA (Static Single Assignment) Instructions\n\n```rust\nAssign(var, value)              // x = value\nBinOp(result, op, left, right)  // result = left op right\nUnOp(result, op, operand)       // result = op operand\nCall(result, func, args)        // result = func(args)\nArrayIndex(result, array, idx)  // result = array[idx]\nArraySet(array, idx, value)     // array[idx] = value",
      "type": "markdown",
      "keywords": [
        "readme",
        "parse_expression",
        "parse_or",
        "parse_and",
        "parser",
        "token",
        "type",
        "ir",
        "frontend",
        "expression",
        "statement",
        "function",
        "if"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "README.md:281-360",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "\n### SSA (Static Single Assignment) Instructions\n\n```rust\nAssign(var, value)              // x = value\nBinOp(result, op, left, right)  // result = left op right\nUnOp(result, op, operand)       // result = op operand\nCall(result, func, args)        // result = func(args)\nArrayIndex(result, array, idx)  // result = array[idx]\nArraySet(array, idx, value)     // array[idx] = value\nReturn(value)                   // return value\nBranch(cond, then, else)        // if cond { then } else { else }\nLoop(var, start, end, body)     // for var in start..end { body }\nDomainConversion(result, value, from, to)  // result = convert(value)\n```\n\n### Domain Annotations\n\n```rust\nDomain::Classical  // CPU (default)\nDomain::Gpu        // @gpu\nDomain::Quantum    // @quantum\n```\n\n---\n\n## CLI (Command Line Interface)\n\n### Build\n\n```bash\ncargo build\n```\n\n### Parse Only\n\n```bash\ncargo run -- parse examples/hybrid.tgpu\n```\n\n### Lower to IR (Intermediate Representation)\n\n```bash\ncargo run -- lower examples/hybrid.tgpu\n```\n\n### Compile\n\n#### WGSL (WebGPU Shading Language)\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t wgsl -o output.wgsl\n```\n\n#### Quantum (Qiskit)\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t quantum -o output.py\n```\n\n#### Orchestrator (Hybrid Python)\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t orchestrator -o demo.py\n```\n\n### With Optimization\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t orchestrator -o demo.py --optimize\n```\n\n### With IR (Intermediate Representation) Dump\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t orchestrator -o demo.py --dump-ir\n```\n\n### With Both Flags\n",
      "type": "markdown",
      "keywords": [
        "readme",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "optimize",
        "ir",
        "lower",
        "orchestrator",
        "loop",
        "if",
        "hybrid"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "README.md:351-430",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "```\n\n### With IR (Intermediate Representation) Dump\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t orchestrator -o demo.py --dump-ir\n```\n\n### With Both Flags\n\n```bash\ncargo run -- compile examples/hybrid.tgpu -t orchestrator -o demo.py --optimize --dump-ir\n```\n\n### Execute Generated Code\n\n```bash\npython demo.py\n```\n\n### Test\n\n```bash\ncargo test\n```\n\n### Clean\n\n```bash\ncargo clean\n```\n\n---\n\n## TypeScript Virtual Machine\n\nQuarkDSL includes a TypeScript-based virtual machine for direct execution in web browsers and Node.js environments.\n\n### Features\n\n- Stack-based bytecode interpreter\n- 8-qubit quantum simulator with full state vector simulation\n- Quantum gates: H, X, Y, Z, RX, RY, RZ, CNOT, SWAP, Toffoli\n- Measurement with probabilistic collapse\n- GPU function simulation via JavaScript arrays\n\n### Web Playground\n\nThe TypeScript VM powers the interactive web playground at `quarkdsl-web/`. Users can write QuarkDSL code and execute it directly in the browser with real-time quantum simulation.\n\n### VM Architecture\n\n```\nQuarkDSL Source\n    â†“\nLexer (TypeScript) â†’ Tokens\n    â†“\nParser (TypeScript) â†’ AST\n    â†“\nCompiler â†’ Bytecode\n    â†“\nVM Execution\n    â”œâ”€â”€ Classical operations (stack-based)\n    â”œâ”€â”€ GPU operations (array simulation)\n    â””â”€â”€ Quantum operations (state vector simulation)\n```\n\n### Bytecode Instructions\n\n| Opcode          | Description              |\n| --------------- | ------------------------ |\n| PUSH            | Push constant onto stack |\n| POP             | Pop value from stack     |\n| ADD/SUB/MUL/DIV | Arithmetic operations    |\n| LOAD/STORE      | Variable access          |\n| CALL            | Function call            |\n| RETURN          | Return from function     |\n| JUMP/JUMPIF     | Control flow             |\n| QUANTUM_H       | Apply Hadamard gate      |\n| QUANTUM_X/Y/Z   | Apply Pauli gates        |",
      "type": "markdown",
      "keywords": [
        "readme",
        "lexer",
        "parser",
        "ast",
        "token",
        "compile",
        "quantum",
        "gpu",
        "type",
        "optimize",
        "ir",
        "orchestrator",
        "function",
        "variable",
        "if",
        "qubit",
        "gate",
        "measure",
        "hybrid"
      ],
      "startLine": 351,
      "endLine": 430
    },
    {
      "id": "README.md:421-500",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "| --------------- | ------------------------ |\n| PUSH            | Push constant onto stack |\n| POP             | Pop value from stack     |\n| ADD/SUB/MUL/DIV | Arithmetic operations    |\n| LOAD/STORE      | Variable access          |\n| CALL            | Function call            |\n| RETURN          | Return from function     |\n| JUMP/JUMPIF     | Control flow             |\n| QUANTUM_H       | Apply Hadamard gate      |\n| QUANTUM_X/Y/Z   | Apply Pauli gates        |\n| QUANTUM_RY      | Apply RY rotation        |\n| QUANTUM_CNOT    | Apply CNOT gate          |\n| QUANTUM_MEASURE | Measure qubit            |\n\n---\n\n## Example\n\n### Input (`hybrid.tgpu`)\n\n```rust\n@gpu\nfn preprocess(x: [float]) -> [float] {\n    let result = [0.0, 0.0];\n    for i in 0..2 {\n        result[i] = x[i] * 2.0;\n    }\n    return result;\n}\n\n@quantum\nfn encode(data: [float]) -> int {\n    ry(0, data[0]);\n    ry(1, data[1]);\n    return 0;\n}\n\nfn main(input: [float]) -> int {\n    let features = preprocess(input);  // GPU\n    encode(features);                  // Auto-convert: GPU â†’ Quantum\n    return 0;\n}\n```\n\n### Output (Orchestrator)\n\n```python\nimport numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit_aer import AerSimulator\n\n# GPU function (NumPy simulation)\ndef preprocess(x):\n    result = np.zeros(2)\n    for i in range(2):\n        result[i] = x[i] * 2.0\n    return result\n\n# Quantum function (Qiskit)\ndef encode(data):\n    qc = QuantumCircuit(2)\n    qc.ry(data[0], 0)\n    qc.ry(data[1], 1)\n    return 0\n\n# Orchestrator\ndef main(input):\n    features = preprocess(input)\n    # Auto-conversion: GPU tensor â†’ Quantum state\n    encode(features)\n    return 0\n```\n\n---\n\n## Statistics\n\n| Metric                                        | Value  |\n| --------------------------------------------- | ------ |\n| Total LOC (Lines of Code)                     | ~6,500 |",
      "type": "markdown",
      "keywords": [
        "readme",
        "preprocess",
        "encode",
        "main",
        "quantum",
        "gpu",
        "ir",
        "orchestrator",
        "function",
        "variable",
        "if",
        "qubit",
        "gate",
        "measure",
        "hybrid"
      ],
      "startLine": 421,
      "endLine": 500
    },
    {
      "id": "README.md:491-570",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "    return 0\n```\n\n---\n\n## Statistics\n\n| Metric                                        | Value  |\n| --------------------------------------------- | ------ |\n| Total LOC (Lines of Code)                     | ~6,500 |\n| Rust files (native compiler)                  | 13     |\n| TypeScript files (VM)                         | 12     |\n| Token types                                   | 47     |\n| AST (Abstract Syntax Tree) node types         | 8      |\n| IR (Intermediate Representation) instructions | 10     |\n| VM bytecode opcodes                           | 25+    |\n| Optimization passes                           | 2      |\n| Backends                                      | 4      |\n| Quantum gates supported (VM)                  | 10     |\n| Max qubits (VM simulator)                     | 8      |\n| Example programs                              | 7      |\n| Build errors                                  | 0      |\n| Build warnings                                | 0      |\n\n---\n\n## Features\n\n### Automatic Data Marshalling\n\n- GPU (Graphics Processing Unit) tensor â†’ Quantum state (angle encoding)\n- Quantum state â†’ GPU tensor (measurement)\n- Inserted at compile time (IR - Intermediate Representation lowering)\n\n### Cross-Domain Optimization\n\n- DCE (Dead Code Elimination)\n- CSE (Common Subexpression Elimination)\n- Domain-aware optimization\n\n### Multi-Backend\n\n- WGSL (WebGPU Shading Language): GPU compute shaders\n- Qiskit: Quantum circuits\n- Orchestrator: Hybrid execution\n- TypeScript VM: Browser-based execution with quantum simulation\n\n### TypeScript Virtual Machine\n\n- Stack-based bytecode interpreter\n- Full quantum state vector simulation (8 qubits, 256 amplitudes)\n- Quantum gates: H, X, Y, Z, RX, RY, RZ, CNOT, SWAP, Toffoli\n- Probabilistic measurement with state collapse\n- Web playground for interactive development\n\n### IBM Quantum Hardware Support\n\n- Conditional execution: Simulator or real quantum computer\n- Single flag toggle: `USE_QUANTUM_COMPUTER = True/False`\n- Automatic backend selection: Least busy IBM Quantum system\n- Embedded API key: Ready to use\n- Supports 127+ qubit systems: ibm_brisbane, ibm_kyoto, ibm_osaka\n\n---\n\n## Execution\n\n### Compilation\n\n```bash\ncargo run -- compile hybrid.tgpu -t orchestrator -o demo.py\n```\n\n### Execution (Simulation - Default)\n\n```bash\npython demo.py\n# Uses: Qiskit Aer (quantum simulator), NumPy (GPU simulation)\n```\n",
      "type": "markdown",
      "keywords": [
        "readme",
        "ast",
        "token",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "type",
        "error",
        "ir",
        "lower",
        "backend",
        "orchestrator",
        "expression",
        "qubit",
        "gate",
        "measure",
        "hybrid"
      ],
      "startLine": 491,
      "endLine": 570
    },
    {
      "id": "README.md:561-594",
      "filePath": "README.md",
      "fileName": "README.md",
      "content": "cargo run -- compile hybrid.tgpu -t orchestrator -o demo.py\n```\n\n### Execution (Simulation - Default)\n\n```bash\npython demo.py\n# Uses: Qiskit Aer (quantum simulator), NumPy (GPU simulation)\n```\n\n### Execution (IBM Quantum Hardware)\n\n**Step 1:** Edit generated code and set:\n\n```python\nUSE_QUANTUM_COMPUTER = True  # Change from False to True\n```\n\n**Step 2:** Run:\n\n```bash\npython demo.py\n# Uses: Real IBM Quantum hardware (ibm_brisbane, ibm_kyoto, etc.)\n# API Key: krPjNWz0BsR_PSI0UVVG_VxIFSA27a5SaEgpLlI22-F-\n```\n\n**Documentation:** See `docs/IBM_QUANTUM_INTEGRATION.md` for details.\n\n---\n\n## License\n\nMIT\n",
      "type": "markdown",
      "keywords": [
        "readme",
        "compile",
        "quantum",
        "gpu",
        "orchestrator",
        "if",
        "hybrid"
      ],
      "startLine": 561,
      "endLine": 594
    },
    {
      "id": "src/backend/mod.rs:1-4",
      "filePath": "src/backend/mod.rs",
      "fileName": "mod.rs",
      "content": "pub mod wgsl;\npub mod quantum;\npub mod orchestrator;\n",
      "type": "rust",
      "keywords": [
        "mod",
        "wgsl",
        "quantum",
        "orchestrator"
      ],
      "startLine": 1,
      "endLine": 4
    },
    {
      "id": "src/backend/orchestrator.rs:1-80",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "/// Python Orchestrator Backend - Generates hybrid execution code\n///\n/// This backend generates Python code that orchestrates:\n/// 1. GPU execution (WGSL via WebGPU)\n/// 2. Quantum execution (Qiskit)\n/// 3. Data marshalling between domains\n\nuse super::super::middle::ir::*;\nuse anyhow::Result;\n\npub fn generate_orchestrator(module: &Module) -> Result<String> {\n    let mut output = String::new();\n\n    // Python imports\n    output.push_str(\"#!/usr/bin/env python3\\n\");\n    output.push_str(\"\\\"\\\"\\\"QuarkDSL Hybrid Orchestrator - Auto-generated\\\"\\\"\\\"\\n\\n\");\n    output.push_str(\"import numpy as np\\n\");\n    output.push_str(\"try:\\n\");\n    output.push_str(\"    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\\n\");\n    output.push_str(\"    from qiskit_aer import AerSimulator\\n\");\n    output.push_str(\"    from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler\\n\");\n    output.push_str(\"    QISKIT_AVAILABLE = True\\n\");\n    output.push_str(\"except ImportError:\\n\");\n    output.push_str(\"    QISKIT_AVAILABLE = False\\n\");\n    output.push_str(\"    print(\\\"Warning: Qiskit not installed. Quantum functions will not work.\\\")\\n\\n\");\n\n    // Configuration\n    output.push_str(\"# ============================================================================\\n\");\n    output.push_str(\"# Configuration\\n\");\n    output.push_str(\"# ============================================================================\\n\");\n    output.push_str(\"# Environment Variables:\\n\");\n    output.push_str(\"#   DEBUG_MODE=true              - Enable debug output\\n\");\n    output.push_str(\"#   USE_QUANTUM_COMPUTER=true    - Use IBM Quantum (requires IBM_API_KEY)\\n\");\n    output.push_str(\"#   USE_CLOUD_SIMULATOR=true     - Use IBM Cloud Simulator (fast, default when USE_QUANTUM_COMPUTER=true)\\n\");\n    output.push_str(\"#   USE_CLOUD_SIMULATOR=false    - Use real quantum hardware (slow, requires queue time)\\n\");\n    output.push_str(\"#   IBM_API_KEY=your_key         - IBM Quantum API key\\n\");\n    output.push_str(\"# ============================================================================\\n\\n\");\n    output.push_str(\"import os\\n\\n\");\n    output.push_str(\"DEBUG_MODE = os.getenv(\\\"DEBUG_MODE\\\", \\\"false\\\").lower() == \\\"true\\\"\\n\");\n    output.push_str(\"USE_QUANTUM_COMPUTER = os.getenv(\\\"USE_QUANTUM_COMPUTER\\\", \\\"false\\\").lower() == \\\"true\\\"\\n\");\n    output.push_str(\"IBM_API_KEY = os.getenv(\\\"IBM_API_KEY\\\", \\\"\\\")\\n\\n\");\n    output.push_str(\"if USE_QUANTUM_COMPUTER and not IBM_API_KEY:\\n\");\n    output.push_str(\"    raise ValueError(\\\"IBM_API_KEY environment variable must be set when USE_QUANTUM_COMPUTER=true\\\")\\n\\n\");\n\n    // Generate helper functions\n    output.push_str(&generate_helpers());\n\n    // Generate function implementations\n    for func in &module.functions {\n        output.push_str(&generate_function(func)?);\n        output.push_str(\"\\n\");\n    }\n\n    Ok(output)\n}\n\nfn generate_helpers() -> String {\n    r#\"# ============================================================================\n# Helper Functions for Domain Conversions\n# ============================================================================\n\ndef encode_angle(data):\n    \"\"\"Convert classical array to quantum state using angle encoding\"\"\"\n    if isinstance(data, (int, float)):\n        return float(data)\n    return np.array(data, dtype=float)\n\ndef encode_amplitude(data):\n    \"\"\"Convert classical array to quantum state using amplitude encoding\"\"\"\n    data = np.array(data, dtype=float)\n    # Normalize to unit vector\n    norm = np.linalg.norm(data)\n    if norm > 0:\n        data = data / norm\n    return data\n\ndef extract_measurement(counts):\n    \"\"\"Extract classical value from quantum measurement counts\"\"\"\n    # Get most common measurement result\n    if not counts:",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_orchestrator",
        "generate_helpers",
        "ast",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "error",
        "ir",
        "lower",
        "backend",
        "middle",
        "function",
        "variable",
        "if",
        "measure",
        "hybrid"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/backend/orchestrator.rs:71-150",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "    # Normalize to unit vector\n    norm = np.linalg.norm(data)\n    if norm > 0:\n        data = data / norm\n    return data\n\ndef extract_measurement(counts):\n    \"\"\"Extract classical value from quantum measurement counts\"\"\"\n    # Get most common measurement result\n    if not counts:\n        return 0\n    most_common = max(counts, key=counts.get)\n    # Convert binary string to int\n    return int(most_common, 2)\n\ndef run_quantum_circuit(circuit, shots=1024):\n    \"\"\"Execute quantum circuit and return counts\"\"\"\n    if not QISKIT_AVAILABLE:\n        print(\"Error: Qiskit is required for quantum circuit execution\")\n        print(\"Install with: pip install qiskit qiskit-aer qiskit-ibm-runtime\")\n        return {}\n\n    if USE_QUANTUM_COMPUTER:\n        # Use IBM Quantum hardware or cloud simulator\n        from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n        import time\n\n        # Track if we've already shown the fallback message\n        global _aer_fallback_shown\n        if '_aer_fallback_shown' not in globals():\n            _aer_fallback_shown = False\n\n        service = QiskitRuntimeService(channel=\"ibm_quantum_platform\", token=IBM_API_KEY)\n\n        # Check if we should use cloud simulator (faster) or real hardware (slower but real quantum)\n        use_cloud_simulator = os.getenv(\"USE_CLOUD_SIMULATOR\", \"true\").lower() == \"true\"\n\n        if use_cloud_simulator:\n            # Try to get IBM cloud simulator, fall back to local Aer if not available\n            try:\n                available_backends = service.backends(simulator=True)\n                if available_backends:\n                    backend = available_backends[0]\n                    if not _aer_fallback_shown:\n                        print(f\"Using IBM Cloud Simulator: {backend.name}\")\n                        _aer_fallback_shown = True\n                else:\n                    raise Exception(\"No cloud simulator available\")\n            except Exception as e:\n                if not _aer_fallback_shown:\n                    print(\"Using local Aer simulator (IBM Cloud Simulator not available in free tier)\")\n                    if DEBUG_MODE:\n                        print(f\"  Debug: {e}\")\n                    _aer_fallback_shown = True\n                simulator = AerSimulator()\n                job = simulator.run(circuit, shots=shots)\n                result = job.result()\n                counts = result.get_counts()\n                return counts\n        else:\n            backend = service.least_busy(operational=True, simulator=False)\n            if not _aer_fallback_shown:\n                print(f\"\\\\n{'='*60}\")\n                print(f\"Using real IBM Quantum hardware: {backend.name}\")\n                print(\"WARNING: Jobs may take minutes to hours due to queue times\")\n                print(f\"{'='*60}\\\\n\")\n                _aer_fallback_shown = True\n\n        # Transpile circuit for target hardware\n        pm = generate_preset_pass_manager(backend=backend, optimization_level=3)\n        transpiled_circuit = pm.run(circuit)\n\n        if DEBUG_MODE:\n            print(f\"Original circuit depth: {circuit.depth()}\")\n            print(f\"Transpiled circuit depth: {transpiled_circuit.depth()}\")\n\n        sampler = Sampler(backend)\n        job = sampler.run([transpiled_circuit], shots=shots)\n\n        print(f\"\\\\n{'='*60}\")",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "ast",
        "token",
        "quantum",
        "check",
        "error",
        "ir",
        "lower",
        "backend",
        "if",
        "measure"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/backend/orchestrator.rs:141-220",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "        transpiled_circuit = pm.run(circuit)\n\n        if DEBUG_MODE:\n            print(f\"Original circuit depth: {circuit.depth()}\")\n            print(f\"Transpiled circuit depth: {transpiled_circuit.depth()}\")\n\n        sampler = Sampler(backend)\n        job = sampler.run([transpiled_circuit], shots=shots)\n\n        print(f\"\\\\n{'='*60}\")\n        print(f\"Job submitted to IBM Quantum\")\n        print(f\"Job ID: {job.job_id()}\")\n        print(f\"Backend: {backend.name}\")\n        print(f\"{'='*60}\\\\n\")\n\n        # Wait for result with animated status updates\n        animation_chars = ['â ‹', 'â ™', 'â ¹', 'â ¸', 'â ¼', 'â ´', 'â ¦', 'â §', 'â ‡', 'â ']\n        animation_idx = 0\n        wait_time = 0\n\n        while job.status() not in ['DONE', 'ERROR', 'CANCELLED']:\n            status = job.status()\n            elapsed_min = wait_time // 60\n            elapsed_sec = wait_time % 60\n\n            if not use_cloud_simulator:\n                print(f\"\\\\r{animation_chars[animation_idx]} Waiting for quantum job... \"\n                      f\"Status: {status} | Elapsed: {elapsed_min}m {elapsed_sec}s\", end='', flush=True)\n            else:\n                print(f\"\\\\r{animation_chars[animation_idx]} Processing... Status: {status}\", end='', flush=True)\n\n            animation_idx = (animation_idx + 1) % len(animation_chars)\n            time.sleep(1)\n            wait_time += 1\n\n        print(f\"\\\\r{'âœ“'} Job completed! Status: {job.status()}\" + \" \" * 50)\n        print()\n\n        if job.status() == 'DONE':\n            result = job.result()\n\n            # Extract counts from SamplerV2 result\n            pub_result = result[0]\n            data_bin = pub_result.data\n\n            # Get the first measurement register (DataBin contains all classical registers)\n            register_names = list(data_bin.__dict__.keys())\n            if register_names:\n                first_register = getattr(data_bin, register_names[0])\n                counts_dict = first_register.get_counts()\n            else:\n                counts_dict = {}\n\n            return counts_dict\n        else:\n            print(f\"Job failed with status: {job.status()}\")\n            return {}\n    else:\n        # Use local simulator\n        if DEBUG_MODE:\n            print(\"Using local Qiskit Aer simulator\")\n        simulator = AerSimulator()\n        job = simulator.run(circuit, shots=shots)\n        result = job.result()\n        counts = result.get_counts()\n        return counts\n\n# ============================================================================\n# GPU Simulation (Simplified - replace with actual WebGPU)\n# ============================================================================\n\ndef simulate_gpu_function(func_name, *args):\n    \"\"\"Simulate GPU execution (placeholder for WebGPU)\"\"\"\n    # In real implementation, this would:\n    # 1. Compile WGSL shader\n    # 2. Upload data to GPU\n    # 3. Execute compute shader\n    # 4. Download results\n    # For now, just execute on CPU\n    return None  # Will be replaced by actual function calls",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "error",
        "ir",
        "backend",
        "function",
        "if",
        "measure"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "src/backend/orchestrator.rs:211-290",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "\ndef simulate_gpu_function(func_name, *args):\n    \"\"\"Simulate GPU execution (placeholder for WebGPU)\"\"\"\n    # In real implementation, this would:\n    # 1. Compile WGSL shader\n    # 2. Upload data to GPU\n    # 3. Execute compute shader\n    # 4. Download results\n    # For now, just execute on CPU\n    return None  # Will be replaced by actual function calls\n\n\n\"#.to_string()\n}\n\nfn generate_function(func: &IRFunction) -> Result<String> {\n    let mut output = String::new();\n\n    // Function signature\n    output.push_str(&format!(\"def {}(\", func.name));\n    for (i, (name, _ty)) in func.params.iter().enumerate() {\n        if i > 0 {\n            output.push_str(\", \");\n        }\n        output.push_str(name);\n    }\n    output.push_str(\"):\\n\");\n\n    // Docstring with domain info\n    output.push_str(&format!(\"    \\\"\\\"\\\"Domain: {:?}\\\"\\\"\\\"\\n\", func.domain));\n\n    // Function body based on domain\n    match func.domain {\n        crate::frontend::ast::Domain::Gpu => {\n            output.push_str(&generate_gpu_function_body(func)?);\n        }\n        crate::frontend::ast::Domain::Quantum => {\n            output.push_str(&generate_quantum_function_body(func)?);\n        }\n        crate::frontend::ast::Domain::Classical => {\n            output.push_str(&generate_classical_function_body(func)?);\n        }\n    }\n\n    Ok(output)\n}\n\nfn generate_gpu_function_body(func: &IRFunction) -> Result<String> {\n    let mut output = String::new();\n    output.push_str(\"    # GPU function - NumPy simulation\\n\");\n\n    // Build variable name mapping (parameters use their names, others use v{})\n    let mut var_names = std::collections::HashMap::new();\n    for (i, (param_name, _)) in func.params.iter().enumerate() {\n        var_names.insert(i, param_name.clone());\n    }\n\n    // Build inline map for single-use variables\n    let inline_map = build_inline_map(func);\n\n    // Generate instructions (skip inlined ones)\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            // Skip instructions that define variables to be inlined\n            if let Some(dest) = get_dest_var(inst) {\n                if inline_map.contains_key(&dest.id) {\n                    continue;\n                }\n            }\n            output.push_str(&generate_python_instruction_with_inline(inst, &var_names, &inline_map)?);\n        }\n        output.push_str(&generate_python_terminator_with_inline(&block.terminator, &var_names, &inline_map)?);\n    }\n\n    Ok(output)\n}\n\nfn generate_quantum_function_body(func: &IRFunction) -> Result<String> {\n    let mut output = String::new();\n",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_function",
        "generate_gpu_function_body",
        "generate_quantum_function_body",
        "ast",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "ir",
        "frontend",
        "function",
        "variable",
        "if"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "src/backend/orchestrator.rs:281-360",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "        }\n        output.push_str(&generate_python_terminator_with_inline(&block.terminator, &var_names, &inline_map)?);\n    }\n\n    Ok(output)\n}\n\nfn generate_quantum_function_body(func: &IRFunction) -> Result<String> {\n    let mut output = String::new();\n\n    // Estimate qubits needed\n    let num_qubits = estimate_qubits(func);\n\n    output.push_str(&format!(\"    # Quantum function - {} qubits\\n\", num_qubits));\n    output.push_str(\"    if not QISKIT_AVAILABLE:\\n\");\n    output.push_str(\"        print(\\\"Error: Qiskit is required for quantum functions\\\")\\n\");\n    output.push_str(\"        print(\\\"Install with: pip install qiskit qiskit-aer qiskit-ibm-runtime\\\")\\n\");\n    output.push_str(\"        return 0\\n\\n\");\n    output.push_str(&format!(\"    qr = QuantumRegister({}, 'q')\\n\", num_qubits));\n    output.push_str(&format!(\"    cr = ClassicalRegister({}, 'c')\\n\", num_qubits));\n    output.push_str(\"    circuit = QuantumCircuit(qr, cr)\\n\\n\");\n\n    // Build variable name mapping\n    let mut var_names = std::collections::HashMap::new();\n    for (i, (param_name, _)) in func.params.iter().enumerate() {\n        var_names.insert(i, param_name.clone());\n    }\n\n    // Build inline map for single-use variables\n    let inline_map = build_inline_map(func);\n\n    // Track variables that come from measure() calls (including transitive assigns)\n    let mut measure_vars = std::collections::HashSet::new();\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Instruction::Call { function, dest, .. } = inst {\n                if function == \"measure\" {\n                    if let Some(d) = dest {\n                        measure_vars.insert(d.id);\n                    }\n                }\n            }\n        }\n    }\n\n    // Also track variables assigned from measure vars\n    let mut changed = true;\n    while changed {\n        changed = false;\n        for block in &func.blocks {\n            for inst in &block.instructions {\n                if let Instruction::Assign { dest, value } = inst {\n                    if let Value::Var(var) = value {\n                        if measure_vars.contains(&var.id) && !measure_vars.contains(&dest.id) {\n                            measure_vars.insert(dest.id);\n                            changed = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Generate quantum operations (skip inlined ones and measure-related instructions)\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            // Skip measure() calls - we do global measurement at the end\n            if let Instruction::Call { function, .. } = inst {\n                if function == \"measure\" {\n                    continue;\n                }\n            }\n\n            // Skip all Assign instructions in quantum functions - they're not needed for circuit building\n            if matches!(inst, Instruction::Assign { .. }) {\n                continue;\n            }\n\n            // Skip instructions that define variables to be inlined\n            if let Some(dest) = get_dest_var(inst) {",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_quantum_function_body",
        "quantum",
        "error",
        "ir",
        "function",
        "variable",
        "if",
        "qubit",
        "measure"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "src/backend/orchestrator.rs:351-430",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "                }\n            }\n\n            // Skip all Assign instructions in quantum functions - they're not needed for circuit building\n            if matches!(inst, Instruction::Assign { .. }) {\n                continue;\n            }\n\n            // Skip instructions that define variables to be inlined\n            if let Some(dest) = get_dest_var(inst) {\n                if inline_map.contains_key(&dest.id) {\n                    continue;\n                }\n            }\n            output.push_str(&generate_quantum_instruction_with_inline(inst, &var_names, &inline_map)?);\n        }\n    }\n\n    // Add measurements\n    output.push_str(\"\\n    # Measurements\\n\");\n    output.push_str(\"    circuit.measure(qr, cr)\\n\");\n    output.push_str(\"    counts = run_quantum_circuit(circuit)\\n\");\n    output.push_str(\"    result = extract_measurement(counts)\\n\");\n    output.push_str(\"    return result\\n\");\n\n    Ok(output)\n}\n\nfn generate_classical_function_body(func: &IRFunction) -> Result<String> {\n    let mut output = String::new();\n    output.push_str(\"    # Classical orchestration function\\n\");\n\n    // Build variable name mapping\n    let mut var_names = std::collections::HashMap::new();\n    for (i, (param_name, _)) in func.params.iter().enumerate() {\n        var_names.insert(i, param_name.clone());\n    }\n\n    // Build inline map for single-use variables\n    let inline_map = build_inline_map(func);\n\n    // Generate instructions (skip inlined ones)\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            // Skip instructions that define variables to be inlined\n            if let Some(dest) = get_dest_var(inst) {\n                if inline_map.contains_key(&dest.id) {\n                    continue;\n                }\n            }\n            output.push_str(&generate_python_instruction_with_inline(inst, &var_names, &inline_map)?);\n        }\n        output.push_str(&generate_python_terminator_with_inline(&block.terminator, &var_names, &inline_map)?);\n    }\n\n    Ok(output)\n}\n\nfn generate_python_instruction(inst: &Instruction) -> Result<String> {\n    generate_python_instruction_with_names(inst, &std::collections::HashMap::new())\n}\n\nfn generate_python_instruction_with_inline(inst: &Instruction, var_names: &std::collections::HashMap<usize, String>, inline_map: &std::collections::HashMap<usize, String>) -> Result<String> {\n    let code = match inst {\n        Instruction::Assign { dest, value } => {\n            format!(\"    {} = {}\\n\", var_name(dest.id, var_names), python_value_with_inline(value, var_names, inline_map))\n        }\n        Instruction::BinaryOp { dest, op, left, right } => {\n            let op_str = match op {\n                BinOp::Add => \"+\",\n                BinOp::Sub => \"-\",\n                BinOp::Mul => \"*\",\n                BinOp::Div => \"/\",\n                BinOp::Mod => \"%\",\n                BinOp::Eq => \"==\",\n                BinOp::Ne => \"!=\",\n                BinOp::Lt => \"<\",\n                BinOp::Le => \"<=\",\n                BinOp::Gt => \">\",\n                BinOp::Ge => \">=\",",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_classical_function_body",
        "generate_python_instruction",
        "generate_python_instruction_with_inline",
        "quantum",
        "ir",
        "function",
        "variable",
        "if",
        "measure"
      ],
      "startLine": 351,
      "endLine": 430
    },
    {
      "id": "src/backend/orchestrator.rs:421-500",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "                BinOp::Sub => \"-\",\n                BinOp::Mul => \"*\",\n                BinOp::Div => \"/\",\n                BinOp::Mod => \"%\",\n                BinOp::Eq => \"==\",\n                BinOp::Ne => \"!=\",\n                BinOp::Lt => \"<\",\n                BinOp::Le => \"<=\",\n                BinOp::Gt => \">\",\n                BinOp::Ge => \">=\",\n                BinOp::And => \"and\",\n                BinOp::Or => \"or\",\n            };\n            format!(\"    {} = {} {} {}\\n\",\n                var_name(dest.id, var_names),\n                python_value_with_inline(left, var_names, inline_map),\n                op_str,\n                python_value_with_inline(right, var_names, inline_map))\n        }\n        Instruction::UnaryOp { dest, op, operand } => {\n            let op_str = match op {\n                UnOp::Neg => \"-\",\n                UnOp::Not => \"not \",\n            };\n            format!(\"    {} = {}{}\\n\", var_name(dest.id, var_names), op_str, python_value_with_inline(operand, var_names, inline_map))\n        }\n        Instruction::Load { dest, array, index } => {\n            format!(\"    {} = {}[{}]\\n\",\n                var_name(dest.id, var_names),\n                var_name(array.id, var_names),\n                python_value_with_inline(index, var_names, inline_map))\n        }\n        Instruction::Store { array, index, value } => {\n            format!(\"    {}[{}] = {}\\n\",\n                var_name(array.id, var_names),\n                python_value_with_inline(index, var_names, inline_map),\n                python_value_with_inline(value, var_names, inline_map))\n        }\n        Instruction::Call { dest, function, args } => {\n            let args_str = args.iter()\n                .map(|arg| python_value_with_inline(arg, var_names, inline_map))\n                .collect::<Vec<_>>()\n                .join(\", \");\n            let mut result = String::new();\n\n            // Handle built-in print functions\n            if function == \"print\" || function == \"print_float\" || function == \"print_array\" {\n                result.push_str(&format!(\"    print({})\\n\", args_str));\n            } else if let Some(d) = dest {\n                result.push_str(&format!(\"    {} = {}({})\\n\", var_name(d.id, var_names), function, args_str));\n                result.push_str(&format!(\"    if DEBUG_MODE:\\n        print(f\\\"  {}({}) = {{{}}}\\\")\\n\",\n                    function, args_str, var_name(d.id, var_names)));\n            } else {\n                result.push_str(&format!(\"    {}({})\\n\", function, args_str));\n                result.push_str(&format!(\"    if DEBUG_MODE:\\n        print(f\\\"  {}({})\\\")\\n\", function, args_str));\n            }\n            result\n        }\n        Instruction::DomainConversion { dest, source, from_domain, to_domain, encoding } => {\n            format!(\"    {} = encode_angle({})\\n\",\n                var_name(dest.id, var_names),\n                python_value_with_inline(source, var_names, inline_map))\n        }\n        _ => String::new(),\n    };\n    Ok(code)\n}\n\nfn generate_python_instruction_with_names(inst: &Instruction, var_names: &std::collections::HashMap<usize, String>) -> Result<String> {\n    let code = match inst {\n        Instruction::Assign { dest, value } => {\n            format!(\"    {} = {}\\n\", var_name(dest.id, var_names), python_value_with_names(value, var_names))\n        }\n        Instruction::BinaryOp { dest, op, left, right } => {\n            let op_str = match op {\n                BinOp::Add => \"+\",\n                BinOp::Sub => \"-\",\n                BinOp::Mul => \"*\",\n                BinOp::Div => \"/\",\n                BinOp::Mod => \"%\",",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_python_instruction_with_names",
        "function",
        "if"
      ],
      "startLine": 421,
      "endLine": 500
    },
    {
      "id": "src/backend/orchestrator.rs:491-570",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "        Instruction::Assign { dest, value } => {\n            format!(\"    {} = {}\\n\", var_name(dest.id, var_names), python_value_with_names(value, var_names))\n        }\n        Instruction::BinaryOp { dest, op, left, right } => {\n            let op_str = match op {\n                BinOp::Add => \"+\",\n                BinOp::Sub => \"-\",\n                BinOp::Mul => \"*\",\n                BinOp::Div => \"/\",\n                BinOp::Mod => \"%\",\n                BinOp::Eq => \"==\",\n                BinOp::Ne => \"!=\",\n                BinOp::Lt => \"<\",\n                BinOp::Le => \"<=\",\n                BinOp::Gt => \">\",\n                BinOp::Ge => \">=\",\n                BinOp::And => \"and\",\n                BinOp::Or => \"or\",\n            };\n            format!(\"    {} = {} {} {}\\n\",\n                var_name(dest.id, var_names),\n                python_value_with_names(left, var_names),\n                op_str,\n                python_value_with_names(right, var_names))\n        }\n        Instruction::UnaryOp { dest, op, operand } => {\n            let op_str = match op {\n                UnOp::Neg => \"-\",\n                UnOp::Not => \"not \",\n            };\n            format!(\"    {} = {}{}\\n\", var_name(dest.id, var_names), op_str, python_value_with_names(operand, var_names))\n        }\n        Instruction::Load { dest, array, index } => {\n            format!(\"    {} = {}[{}]\\n\",\n                var_name(dest.id, var_names),\n                var_name(array.id, var_names),\n                python_value_with_names(index, var_names))\n        }\n        Instruction::Store { array, index, value } => {\n            format!(\"    {}[{}] = {}\\n\",\n                var_name(array.id, var_names),\n                python_value_with_names(index, var_names),\n                python_value_with_names(value, var_names))\n        }\n        Instruction::Call { dest, function, args } => {\n            let args_str = args.iter()\n                .map(|a| python_value_with_names(a, var_names))\n                .collect::<Vec<_>>()\n                .join(\", \");\n            if let Some(d) = dest {\n                format!(\"    {} = {}({})\\n\", var_name(d.id, var_names), function, args_str)\n            } else {\n                format!(\"    {}({})\\n\", function, args_str)\n            }\n        }\n        Instruction::DomainConversion { dest, source, from_domain, to_domain, encoding } => {\n            let conv_fn = match (from_domain, to_domain, encoding) {\n                (_, _, ConversionEncoding::AngleEncoding) => \"encode_angle\",\n                (_, _, ConversionEncoding::AmplitudeEncoding) => \"encode_amplitude\",\n                (_, _, ConversionEncoding::MeasurementExtract) => \"extract_measurement\",\n            };\n            format!(\"    {} = {}({})\\n\", var_name(dest.id, var_names), conv_fn, python_value_with_names(source, var_names))\n        }\n        Instruction::Phi { .. } => {\n            \"    # phi node\\n\".to_string()\n        }\n    };\n    Ok(code)\n}\n\nfn generate_python_terminator(term: &Terminator) -> Result<String> {\n    generate_python_terminator_with_names(term, &std::collections::HashMap::new())\n}\n\nfn generate_python_terminator_with_names(term: &Terminator, var_names: &std::collections::HashMap<usize, String>) -> Result<String> {\n    let code = match term {\n        Terminator::Return(val) => {\n            format!(\"    return {}\\n\", python_value_with_names(val, var_names))\n        }\n        Terminator::ReturnVoid => {",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_python_terminator",
        "generate_python_terminator_with_names",
        "function",
        "if",
        "measure"
      ],
      "startLine": 491,
      "endLine": 570
    },
    {
      "id": "src/backend/orchestrator.rs:561-640",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "fn generate_python_terminator(term: &Terminator) -> Result<String> {\n    generate_python_terminator_with_names(term, &std::collections::HashMap::new())\n}\n\nfn generate_python_terminator_with_names(term: &Terminator, var_names: &std::collections::HashMap<usize, String>) -> Result<String> {\n    let code = match term {\n        Terminator::Return(val) => {\n            format!(\"    return {}\\n\", python_value_with_names(val, var_names))\n        }\n        Terminator::ReturnVoid => {\n            \"    return None\\n\".to_string()\n        }\n        Terminator::Branch { condition, true_label, false_label } => {\n            format!(\"    if {}:\\n        goto {}\\n    else:\\n        goto {}\\n\",\n                python_value_with_names(condition, var_names), true_label, false_label)\n        }\n        Terminator::Jump(label) => {\n            format!(\"    goto {}\\n\", label)\n        }\n    };\n    Ok(code)\n}\n\nfn generate_python_terminator_with_inline(term: &Terminator, var_names: &std::collections::HashMap<usize, String>, inline_map: &std::collections::HashMap<usize, String>) -> Result<String> {\n    let code = match term {\n        Terminator::Return(val) => {\n            format!(\"    return {}\\n\", python_value_with_inline(val, var_names, inline_map))\n        }\n        Terminator::ReturnVoid => {\n            \"    return None\\n\".to_string()\n        }\n        Terminator::Branch { condition, true_label, false_label } => {\n            format!(\"    if {}:\\n        goto {}\\n    else:\\n        goto {}\\n\",\n                python_value_with_inline(condition, var_names, inline_map), true_label, false_label)\n        }\n        Terminator::Jump(label) => {\n            format!(\"    goto {}\\n\", label)\n        }\n    };\n    Ok(code)\n}\n\nfn var_name(id: usize, var_names: &std::collections::HashMap<usize, String>) -> String {\n    var_names.get(&id).cloned().unwrap_or_else(|| format!(\"v{}\", id))\n}\n\nfn python_value(val: &Value) -> String {\n    python_value_with_names(val, &std::collections::HashMap::new())\n}\n\nfn python_value_with_names(val: &Value, var_names: &std::collections::HashMap<usize, String>) -> String {\n    match val {\n        Value::Int(n) => format!(\"{}\", n),\n        Value::Float(f) => format!(\"{}\", f),\n        Value::Bool(b) => if *b { \"True\" } else { \"False\" }.to_string(),\n        Value::Var(v) => var_name(v.id, var_names),\n        Value::Array(elements) => {\n            let elems = elements.iter()\n                .map(|e| python_value_with_names(e, var_names))\n                .collect::<Vec<_>>()\n                .join(\", \");\n            format!(\"[{}]\", elems)\n        }\n    }\n}\n\nfn python_value_with_inline(val: &Value, var_names: &std::collections::HashMap<usize, String>, inline_map: &std::collections::HashMap<usize, String>) -> String {\n    match val {\n        Value::Int(n) => format!(\"{}\", n),\n        Value::Float(f) => format!(\"{}\", f),\n        Value::Bool(b) => if *b { \"True\" } else { \"False\" }.to_string(),\n        Value::Var(v) => {\n            // Check if this variable should be inlined\n            if let Some(inlined_expr) = inline_map.get(&v.id) {\n                inlined_expr.clone()\n            } else {\n                var_name(v.id, var_names)\n            }\n        }\n        Value::Array(elements) => {",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_python_terminator",
        "generate_python_terminator_with_names",
        "generate_python_terminator_with_inline",
        "var_name",
        "python_value",
        "python_value_with_names",
        "python_value_with_inline",
        "check",
        "variable",
        "if"
      ],
      "startLine": 561,
      "endLine": 640
    },
    {
      "id": "src/backend/orchestrator.rs:631-710",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "        Value::Bool(b) => if *b { \"True\" } else { \"False\" }.to_string(),\n        Value::Var(v) => {\n            // Check if this variable should be inlined\n            if let Some(inlined_expr) = inline_map.get(&v.id) {\n                inlined_expr.clone()\n            } else {\n                var_name(v.id, var_names)\n            }\n        }\n        Value::Array(elements) => {\n            let elems = elements.iter()\n                .map(|e| python_value_with_inline(e, var_names, inline_map))\n                .collect::<Vec<_>>()\n                .join(\", \");\n            format!(\"[{}]\", elems)\n        }\n    }\n}\n\nfn generate_quantum_instruction(inst: &Instruction) -> Result<String> {\n    generate_quantum_instruction_with_names(inst, &std::collections::HashMap::new())\n}\n\nfn generate_quantum_instruction_with_inline(inst: &Instruction, var_names: &std::collections::HashMap<usize, String>, inline_map: &std::collections::HashMap<usize, String>) -> Result<String> {\n    let code = match inst {\n        Instruction::Load { dest, array, index } => {\n            format!(\"    {} = {}[{}]\\n\",\n                var_name(dest.id, var_names),\n                var_name(array.id, var_names),\n                python_value_with_inline(index, var_names, inline_map))\n        }\n        Instruction::Assign { dest, value } => {\n            format!(\"    {} = {}\\n\", var_name(dest.id, var_names), python_value_with_inline(value, var_names, inline_map))\n        }\n        Instruction::Call { function, args, dest } => {\n            // Map quantum gate calls to Qiskit\n            match function.as_str() {\n                \"h\" | \"hadamard\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        format!(\"    circuit.h(qr[{}])\\n\", qubit)\n                    } else {\n                        \"    # h gate (invalid args)\\n\".to_string()\n                    }\n                }\n                \"x\" | \"pauli_x\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        format!(\"    circuit.x(qr[{}])\\n\", qubit)\n                    } else {\n                        \"    # x gate (invalid args)\\n\".to_string()\n                    }\n                }\n                \"ry\" => {\n                    if args.len() >= 2 {\n                        if let (Some(qubit_val), Some(angle)) = (args.get(0), args.get(1)) {\n                            if let Value::Int(qubit) = qubit_val {\n                                format!(\"    circuit.ry({}, qr[{}])\\n\", python_value_with_inline(angle, var_names, inline_map), qubit)\n                            } else {\n                                \"    # ry gate (invalid qubit)\\n\".to_string()\n                            }\n                        } else {\n                            \"    # ry gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # ry gate (missing args)\\n\".to_string()\n                    }\n                }\n                \"cx\" | \"cnot\" => {\n                    if args.len() >= 2 {\n                        if let (Some(Value::Int(control)), Some(Value::Int(target))) = (args.get(0), args.get(1)) {\n                            format!(\"    circuit.cx(qr[{}], qr[{}])\\n\", control, target)\n                        } else {\n                            \"    # cx gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # cx gate (missing args)\\n\".to_string()\n                    }\n                }\n                _ => String::new(),\n            }\n        }",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_quantum_instruction",
        "generate_quantum_instruction_with_inline",
        "quantum",
        "check",
        "ir",
        "function",
        "variable",
        "if",
        "qubit",
        "gate"
      ],
      "startLine": 631,
      "endLine": 710
    },
    {
      "id": "src/backend/orchestrator.rs:701-780",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "                        } else {\n                            \"    # cx gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # cx gate (missing args)\\n\".to_string()\n                    }\n                }\n                _ => String::new(),\n            }\n        }\n        _ => String::new(),\n    };\n    Ok(code)\n}\n\nfn generate_quantum_instruction_with_names(inst: &Instruction, var_names: &std::collections::HashMap<usize, String>) -> Result<String> {\n    let code = match inst {\n        Instruction::Call { function, args, dest } => {\n            // Map quantum gate calls to Qiskit\n            match function.as_str() {\n                \"h\" | \"hadamard\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        format!(\"    circuit.h(qr[{}])\\n\", qubit)\n                    } else {\n                        \"    # h gate (invalid args)\\n\".to_string()\n                    }\n                }\n                \"x\" | \"pauli_x\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        format!(\"    circuit.x(qr[{}])\\n\", qubit)\n                    } else {\n                        \"    # x gate (invalid args)\\n\".to_string()\n                    }\n                }\n                \"y\" | \"pauli_y\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        format!(\"    circuit.y(qr[{}])\\n\", qubit)\n                    } else {\n                        \"    # y gate (invalid args)\\n\".to_string()\n                    }\n                }\n                \"z\" | \"pauli_z\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        format!(\"    circuit.z(qr[{}])\\n\", qubit)\n                    } else {\n                        \"    # z gate (invalid args)\\n\".to_string()\n                    }\n                }\n                \"rx\" => {\n                    if args.len() >= 2 {\n                        if let (Some(qubit_val), Some(angle)) = (args.get(0), args.get(1)) {\n                            if let Value::Int(qubit) = qubit_val {\n                                format!(\"    circuit.rx({}, qr[{}])\\n\", python_value_with_names(angle, var_names), qubit)\n                            } else {\n                                \"    # rx gate (invalid qubit)\\n\".to_string()\n                            }\n                        } else {\n                            \"    # rx gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # rx gate (missing args)\\n\".to_string()\n                    }\n                }\n                \"ry\" => {\n                    if args.len() >= 2 {\n                        if let (Some(qubit_val), Some(angle)) = (args.get(0), args.get(1)) {\n                            if let Value::Int(qubit) = qubit_val {\n                                format!(\"    circuit.ry({}, qr[{}])\\n\", python_value_with_names(angle, var_names), qubit)\n                            } else {\n                                \"    # ry gate (invalid qubit)\\n\".to_string()\n                            }\n                        } else {\n                            \"    # ry gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # ry gate (missing args)\\n\".to_string()\n                    }\n                }\n                \"rz\" => {\n                    if args.len() >= 2 {",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "generate_quantum_instruction_with_names",
        "quantum",
        "ir",
        "function",
        "if",
        "qubit",
        "gate"
      ],
      "startLine": 701,
      "endLine": 780
    },
    {
      "id": "src/backend/orchestrator.rs:771-850",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "                            }\n                        } else {\n                            \"    # ry gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # ry gate (missing args)\\n\".to_string()\n                    }\n                }\n                \"rz\" => {\n                    if args.len() >= 2 {\n                        if let (Some(qubit_val), Some(angle)) = (args.get(0), args.get(1)) {\n                            if let Value::Int(qubit) = qubit_val {\n                                format!(\"    circuit.rz({}, qr[{}])\\n\", python_value_with_names(angle, var_names), qubit)\n                            } else {\n                                \"    # rz gate (invalid qubit)\\n\".to_string()\n                            }\n                        } else {\n                            \"    # rz gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # rz gate (missing args)\\n\".to_string()\n                    }\n                }\n                \"cx\" | \"cnot\" => {\n                    if args.len() >= 2 {\n                        if let (Some(Value::Int(ctrl)), Some(Value::Int(target))) = (args.get(0), args.get(1)) {\n                            format!(\"    circuit.cx(qr[{}], qr[{}])\\n\", ctrl, target)\n                        } else {\n                            \"    # cx gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # cx gate (missing args)\\n\".to_string()\n                    }\n                }\n                \"cz\" => {\n                    if args.len() >= 2 {\n                        if let (Some(Value::Int(ctrl)), Some(Value::Int(target))) = (args.get(0), args.get(1)) {\n                            format!(\"    circuit.cz(qr[{}], qr[{}])\\n\", ctrl, target)\n                        } else {\n                            \"    # cz gate (invalid args)\\n\".to_string()\n                        }\n                    } else {\n                        \"    # cz gate (missing args)\\n\".to_string()\n                    }\n                }\n                \"measure\" => {\n                    // Store result in variable if dest exists\n                    if let Some(d) = dest {\n                        format!(\"    {} = 0  # measure placeholder\\n\", var_name(d.id, var_names))\n                    } else {\n                        \"    # measure\\n\".to_string()\n                    }\n                }\n                _ => {\n                    format!(\"    # unknown quantum op: {}\\n\", function)\n                }\n            }\n        }\n        Instruction::Load { dest, array, index } => {\n            format!(\"    {} = {}[{}]\\n\",\n                var_name(dest.id, var_names),\n                var_name(array.id, var_names),\n                python_value_with_names(index, var_names))\n        }\n        Instruction::Assign { dest, value } => {\n            format!(\"    {} = {}\\n\", var_name(dest.id, var_names), python_value_with_names(value, var_names))\n        }\n        _ => {\n            format!(\"    # {:?}\\n\", inst)\n        }\n    };\n    Ok(code)\n}\n\nfn get_dest_var(inst: &Instruction) -> Option<SSAVar> {\n    match inst {\n        Instruction::Assign { dest, .. } => Some(*dest),\n        Instruction::BinaryOp { dest, .. } => Some(*dest),\n        Instruction::UnaryOp { dest, .. } => Some(*dest),\n        Instruction::Load { dest, .. } => Some(*dest),",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "get_dest_var",
        "quantum",
        "ir",
        "function",
        "variable",
        "if",
        "qubit",
        "gate",
        "measure"
      ],
      "startLine": 771,
      "endLine": 850
    },
    {
      "id": "src/backend/orchestrator.rs:841-920",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "    };\n    Ok(code)\n}\n\nfn get_dest_var(inst: &Instruction) -> Option<SSAVar> {\n    match inst {\n        Instruction::Assign { dest, .. } => Some(*dest),\n        Instruction::BinaryOp { dest, .. } => Some(*dest),\n        Instruction::UnaryOp { dest, .. } => Some(*dest),\n        Instruction::Load { dest, .. } => Some(*dest),\n        Instruction::Call { dest, .. } => *dest,\n        Instruction::Phi { dest, .. } => Some(*dest),\n        Instruction::DomainConversion { dest, .. } => Some(*dest),\n        _ => None,\n    }\n}\n\nfn collect_used_var_ids(inst: &Instruction, used: &mut std::collections::HashSet<usize>) {\n    match inst {\n        Instruction::Assign { value, .. } => collect_value_vars(value, used),\n        Instruction::BinaryOp { left, right, .. } => {\n            collect_value_vars(left, used);\n            collect_value_vars(right, used);\n        }\n        Instruction::UnaryOp { operand, .. } => collect_value_vars(operand, used),\n        Instruction::Load { array, index, .. } => {\n            used.insert(array.id);\n            collect_value_vars(index, used);\n        }\n        Instruction::Store { array, index, value } => {\n            used.insert(array.id);\n            collect_value_vars(index, used);\n            collect_value_vars(value, used);\n        }\n        Instruction::Call { args, .. } => {\n            for arg in args {\n                collect_value_vars(arg, used);\n            }\n        }\n        Instruction::DomainConversion { source, .. } => collect_value_vars(source, used),\n        _ => {}\n    }\n}\n\nfn collect_value_vars(value: &Value, used: &mut std::collections::HashSet<usize>) {\n    match value {\n        Value::Var(v) => { used.insert(v.id); }\n        Value::Array(elements) => {\n            for elem in elements {\n                collect_value_vars(elem, used);\n            }\n        }\n        _ => {}\n    }\n}\n\nfn estimate_qubits(func: &IRFunction) -> usize {\n    // Simple heuristic: count unique qubit indices\n    let mut max_qubit = 0;\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Instruction::Call { args, .. } = inst {\n                for arg in args {\n                    if let Value::Int(n) = arg {\n                        if *n >= 0 {\n                            max_qubit = max_qubit.max(*n as usize);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    (max_qubit + 1).max(2)\n}\n\n// Build inline map: variables that are used only once and can be inlined\nfn build_inline_map(func: &IRFunction) -> std::collections::HashMap<usize, String> {\n    use std::collections::HashMap;\n\n    // Count uses of each variable",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "get_dest_var",
        "collect_used_var_ids",
        "collect_value_vars",
        "estimate_qubits",
        "build_inline_map",
        "ir",
        "function",
        "variable",
        "if",
        "qubit"
      ],
      "startLine": 841,
      "endLine": 920
    },
    {
      "id": "src/backend/orchestrator.rs:911-990",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "        }\n    }\n    (max_qubit + 1).max(2)\n}\n\n// Build inline map: variables that are used only once and can be inlined\nfn build_inline_map(func: &IRFunction) -> std::collections::HashMap<usize, String> {\n    use std::collections::HashMap;\n\n    // Count uses of each variable\n    let mut use_count: HashMap<usize, usize> = HashMap::new();\n    // Track variables used as arrays in Store/Load (can't be inlined)\n    let mut no_inline_vars: std::collections::HashSet<usize> = std::collections::HashSet::new();\n\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            // Count uses in operands\n            match inst {\n                Instruction::Assign { value, .. } => count_value_uses(value, &mut use_count),\n                Instruction::BinaryOp { left, right, .. } => {\n                    count_value_uses(left, &mut use_count);\n                    count_value_uses(right, &mut use_count);\n                }\n                Instruction::UnaryOp { operand, .. } => count_value_uses(operand, &mut use_count),\n                Instruction::Load { array, index, .. } => {\n                    // Arrays in Load can't be inlined\n                    no_inline_vars.insert(array.id);\n                    count_value_uses(index, &mut use_count);\n                }\n                Instruction::Store { array, index, value, .. } => {\n                    // Arrays in Store can't be inlined\n                    no_inline_vars.insert(array.id);\n                    count_value_uses(index, &mut use_count);\n                    count_value_uses(value, &mut use_count);\n                }\n                Instruction::Call { args, .. } => {\n                    for arg in args {\n                        count_value_uses(arg, &mut use_count);\n                    }\n                }\n                Instruction::DomainConversion { source, .. } => count_value_uses(source, &mut use_count),\n                _ => {}\n            }\n        }\n        // Count uses in terminator\n        match &block.terminator {\n            Terminator::Return(val) => count_value_uses(val, &mut use_count),\n            Terminator::Branch { condition, .. } => count_value_uses(condition, &mut use_count),\n            _ => {}\n        }\n    }\n\n    // Build inline map for single-use variables\n    // Do this in multiple passes to handle dependencies\n    let mut inline_map = HashMap::new();\n\n    // Pass 1: Inline Loads and simple Assigns\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Some(dest) = get_dest_var(inst) {\n                // Skip parameters\n                if dest.id < func.params.len() {\n                    continue;\n                }\n\n                // Skip variables that can't be inlined (used as arrays)\n                if no_inline_vars.contains(&dest.id) {\n                    continue;\n                }\n\n                // Only inline if used exactly once\n                if use_count.get(&dest.id).copied().unwrap_or(0) == 1 {\n                    match inst {\n                        Instruction::Load { dest: _, array, index } => {\n                            // Inline Load as array[index]\n                            let array_name = var_name_from_id(array.id, func);\n                            let index_str = value_to_inline_string(index, func, &inline_map);\n                            inline_map.insert(dest.id, format!(\"{}[{}]\", array_name, index_str));\n                        }\n                        Instruction::Assign { value, .. } => {",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "build_inline_map",
        "ir",
        "function",
        "variable",
        "if",
        "qubit"
      ],
      "startLine": 911,
      "endLine": 990
    },
    {
      "id": "src/backend/orchestrator.rs:981-1060",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "                // Only inline if used exactly once\n                if use_count.get(&dest.id).copied().unwrap_or(0) == 1 {\n                    match inst {\n                        Instruction::Load { dest: _, array, index } => {\n                            // Inline Load as array[index]\n                            let array_name = var_name_from_id(array.id, func);\n                            let index_str = value_to_inline_string(index, func, &inline_map);\n                            inline_map.insert(dest.id, format!(\"{}[{}]\", array_name, index_str));\n                        }\n                        Instruction::Assign { value, .. } => {\n                            // Inline simple assigns\n                            let value_str = value_to_inline_string(value, func, &inline_map);\n                            inline_map.insert(dest.id, value_str);\n                        }\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n\n    // Pass 2: Inline BinaryOps using the inline_map from Pass 1\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Some(dest) = get_dest_var(inst) {\n                // Skip parameters\n                if dest.id < func.params.len() {\n                    continue;\n                }\n\n                // Skip variables that can't be inlined (used as arrays)\n                if no_inline_vars.contains(&dest.id) {\n                    continue;\n                }\n\n                // Only inline if used exactly once and not already inlined\n                if use_count.get(&dest.id).copied().unwrap_or(0) == 1 && !inline_map.contains_key(&dest.id) {\n                    match inst {\n                        Instruction::BinaryOp { op, left, right, .. } => {\n                            // Inline BinaryOp as (left op right)\n                            let left_str = value_to_inline_string(left, func, &inline_map);\n                            let right_str = value_to_inline_string(right, func, &inline_map);\n                            let op_str = match op {\n                                BinOp::Add => \"+\",\n                                BinOp::Sub => \"-\",\n                                BinOp::Mul => \"*\",\n                                BinOp::Div => \"/\",\n                                BinOp::Mod => \"%\",\n                                BinOp::Eq => \"==\",\n                                BinOp::Ne => \"!=\",\n                                BinOp::Lt => \"<\",\n                                BinOp::Le => \"<=\",\n                                BinOp::Gt => \">\",\n                                BinOp::Ge => \">=\",\n                                BinOp::And => \"and\",\n                                BinOp::Or => \"or\",\n                            };\n                            inline_map.insert(dest.id, format!(\"{} {} {}\", left_str, op_str, right_str));\n                        }\n                        _ => {}\n                    }\n                }\n            }\n        }\n    }\n\n    inline_map\n}\n\nfn count_value_uses(value: &Value, use_count: &mut std::collections::HashMap<usize, usize>) {\n    if let Value::Var(v) = value {\n        *use_count.entry(v.id).or_insert(0) += 1;\n    }\n}\n\nfn var_name_from_id(var_id: usize, func: &IRFunction) -> String {\n    // Check if it's a parameter\n    if var_id < func.params.len() {\n        func.params[var_id].0.clone()\n    } else {",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "count_value_uses",
        "var_name_from_id",
        "check",
        "ir",
        "function",
        "variable",
        "if"
      ],
      "startLine": 981,
      "endLine": 1060
    },
    {
      "id": "src/backend/orchestrator.rs:1051-1086",
      "filePath": "src/backend/orchestrator.rs",
      "fileName": "orchestrator.rs",
      "content": "    if let Value::Var(v) = value {\n        *use_count.entry(v.id).or_insert(0) += 1;\n    }\n}\n\nfn var_name_from_id(var_id: usize, func: &IRFunction) -> String {\n    // Check if it's a parameter\n    if var_id < func.params.len() {\n        func.params[var_id].0.clone()\n    } else {\n        format!(\"v{}\", var_id)\n    }\n}\n\nfn value_to_inline_string(value: &Value, func: &IRFunction, inline_map: &std::collections::HashMap<usize, String>) -> String {\n    match value {\n        Value::Var(v) => {\n            if let Some(inlined) = inline_map.get(&v.id) {\n                inlined.clone()\n            } else {\n                var_name_from_id(v.id, func)\n            }\n        }\n        Value::Int(n) => n.to_string(),\n        Value::Float(f) => f.to_string(),\n        Value::Bool(b) => b.to_string(),\n        Value::Array(elements) => {\n            let elem_strs: Vec<String> = elements.iter()\n                .map(|e| value_to_inline_string(e, func, inline_map))\n                .collect();\n            format!(\"[{}]\", elem_strs.join(\", \"))\n        }\n    }\n}\n\n",
      "type": "rust",
      "keywords": [
        "orchestrator",
        "var_name_from_id",
        "value_to_inline_string",
        "check",
        "ir",
        "function",
        "if"
      ],
      "startLine": 1051,
      "endLine": 1086
    },
    {
      "id": "src/backend/quantum.rs:1-80",
      "filePath": "src/backend/quantum.rs",
      "fileName": "quantum.rs",
      "content": "use crate::middle::ir::*;\nuse anyhow::Result;\n\npub fn codegen(module: &Module) -> Result<String> {\n    let mut output = String::new();\n\n    // Qiskit imports\n    output.push_str(\"# Generated Qiskit code\\n\");\n    output.push_str(\"from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\\n\");\n    output.push_str(\"from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler\\n\");\n    output.push_str(\"from qiskit_aer import AerSimulator\\n\");\n    output.push_str(\"import sys\\n\\n\");\n\n    // Configuration\n    output.push_str(\"# ============================================================================\\n\");\n    output.push_str(\"# Configuration\\n\");\n    output.push_str(\"# ============================================================================\\n\\n\");\n    output.push_str(\"USE_QUANTUM_COMPUTER = False  # Set to True to use IBM Quantum hardware\\n\");\n    output.push_str(\"IBM_API_KEY = \\\"krPjNWz0BsR_PSI0UVVG_VxIFSA27a5SaEgpLlI22-F-\\\"  # IBM Quantum API key\\n\\n\");\n\n    // Generate circuit from main function\n    if let Some(main_func) = module.functions.iter().find(|f| f.name == \"main\") {\n        output.push_str(&codegen_quantum_circuit(main_func)?);\n    } else {\n        // Generate from first function\n        if let Some(func) = module.functions.first() {\n            output.push_str(&codegen_quantum_circuit(func)?);\n        }\n    }\n\n    // Runtime execution code\n    output.push_str(\"\\n# ============================================================================\\n\");\n    output.push_str(\"# Execution\\n\");\n    output.push_str(\"# ============================================================================\\n\\n\");\n    output.push_str(\"if __name__ == '__main__':\\n\");\n    output.push_str(\"    if USE_QUANTUM_COMPUTER:\\n\");\n    output.push_str(\"        # Use IBM Quantum hardware\\n\");\n    output.push_str(\"        print(\\\"Connecting to IBM Quantum...\\\")\\n\");\n    output.push_str(\"        service = QiskitRuntimeService(channel=\\\"ibm_quantum\\\", token=IBM_API_KEY)\\n\");\n    output.push_str(\"        backend = service.least_busy(operational=True, simulator=False)\\n\");\n    output.push_str(\"        print(f\\\"Using IBM Quantum backend: {backend.name}\\\")\\n\");\n    output.push_str(\"        \\n\");\n    output.push_str(\"        sampler = Sampler(backend)\\n\");\n    output.push_str(\"        job = sampler.run([circuit], shots=1024)\\n\");\n    output.push_str(\"        print(f\\\"Job ID: {job.job_id()}\\\")\\n\");\n    output.push_str(\"        print(\\\"Waiting for results...\\\")\\n\");\n    output.push_str(\"        result = job.result()\\n\");\n    output.push_str(\"        \\n\");\n    output.push_str(\"        # Extract counts from SamplerV2 result\\n\");\n    output.push_str(\"        pub_result = result[0]\\n\");\n    output.push_str(\"        counts = pub_result.data.meas.get_counts()\\n\");\n    output.push_str(\"        print(f\\\"Counts: {counts}\\\")\\n\");\n    output.push_str(\"    else:\\n\");\n    output.push_str(\"        # Use local simulator\\n\");\n    output.push_str(\"        print(\\\"Using local Qiskit Aer simulator\\\")\\n\");\n    output.push_str(\"        backend = AerSimulator()\\n\");\n    output.push_str(\"        result = backend.run(circuit, shots=1024).result()\\n\");\n    output.push_str(\"        counts = result.get_counts()\\n\");\n    output.push_str(\"        print(f\\\"Counts: {counts}\\\")\\n\");\n\n    Ok(output)\n}\n\nfn codegen_quantum_circuit(func: &IRFunction) -> Result<String> {\n    let mut output = String::new();\n\n    // Estimate number of qubits needed\n    let num_qubits = estimate_qubits(func);\n    let num_classical = num_qubits; // Same number of classical bits for measurement\n\n    output.push_str(&format!(\"# Function: {}\\n\", func.name));\n    output.push_str(&format!(\"qr = QuantumRegister({}, 'q')\\n\", num_qubits));\n    output.push_str(&format!(\"cr = ClassicalRegister({}, 'c')\\n\", num_classical));\n    output.push_str(\"circuit = QuantumCircuit(qr, cr)\\n\\n\");\n\n    // Process instructions\n    for block in &func.blocks {\n        output.push_str(&format!(\"# Block: {}\\n\", block.label));\n\n        for inst in &block.instructions {",
      "type": "rust",
      "keywords": [
        "quantum",
        "codegen",
        "codegen_quantum_circuit",
        "ast",
        "token",
        "ir",
        "backend",
        "middle",
        "function",
        "if",
        "qubit",
        "measure"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/backend/quantum.rs:71-150",
      "filePath": "src/backend/quantum.rs",
      "fileName": "quantum.rs",
      "content": "    output.push_str(&format!(\"# Function: {}\\n\", func.name));\n    output.push_str(&format!(\"qr = QuantumRegister({}, 'q')\\n\", num_qubits));\n    output.push_str(&format!(\"cr = ClassicalRegister({}, 'c')\\n\", num_classical));\n    output.push_str(\"circuit = QuantumCircuit(qr, cr)\\n\\n\");\n\n    // Process instructions\n    for block in &func.blocks {\n        output.push_str(&format!(\"# Block: {}\\n\", block.label));\n\n        for inst in &block.instructions {\n            if let Some(quantum_op) = try_codegen_quantum_instruction(inst) {\n                output.push_str(&format!(\"{}\\n\", quantum_op));\n            } else {\n                // Classical instruction - add as comment\n                output.push_str(&format!(\"# Classical: {:?}\\n\", inst));\n            }\n        }\n    }\n\n    // Add measurements at the end\n    output.push_str(\"\\n# Measurements\\n\");\n    output.push_str(&format!(\"circuit.measure(qr, cr)\\n\"));\n\n    Ok(output)\n}\n\nfn try_codegen_quantum_instruction(inst: &Instruction) -> Option<String> {\n    match inst {\n        Instruction::DomainConversion { dest, source, encoding, .. } => {\n            // Generate quantum encoding based on conversion type\n            match encoding {\n                crate::middle::ir::ConversionEncoding::AngleEncoding => {\n                    // Angle encoding: encode classical values as rotation angles\n                    Some(format!(\n                        \"# Angle encoding: {} = encode_angle({})\",\n                        dest.id, codegen_value(source)\n                    ))\n                }\n                crate::middle::ir::ConversionEncoding::AmplitudeEncoding => {\n                    // Amplitude encoding: encode as quantum state amplitudes\n                    Some(format!(\n                        \"# Amplitude encoding: {} = encode_amplitude({})\",\n                        dest.id, codegen_value(source)\n                    ))\n                }\n                crate::middle::ir::ConversionEncoding::MeasurementExtract => {\n                    // Measurement extraction: extract classical values from quantum\n                    Some(format!(\n                        \"# Measurement extract: {} = extract({})\",\n                        dest.id, codegen_value(source)\n                    ))\n                }\n            }\n        }\n        Instruction::Call { function, args, .. } => {\n            // Map function calls to quantum gates\n            match function.as_str() {\n                \"h\" | \"hadamard\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        return Some(format!(\"circuit.h({})\", qubit));\n                    }\n                }\n                \"x\" | \"pauli_x\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        return Some(format!(\"circuit.x({})\", qubit));\n                    }\n                }\n                \"y\" | \"pauli_y\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        return Some(format!(\"circuit.y({})\", qubit));\n                    }\n                }\n                \"z\" | \"pauli_z\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        return Some(format!(\"circuit.z({})\", qubit));\n                    }\n                }\n                \"cx\" | \"cnot\" => {\n                    if args.len() >= 2 {\n                        if let (Some(Value::Int(ctrl)), Some(Value::Int(target))) =",
      "type": "rust",
      "keywords": [
        "quantum",
        "try_codegen_quantum_instruction",
        "codegen",
        "type",
        "ir",
        "middle",
        "function",
        "if",
        "qubit",
        "gate",
        "measure"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/backend/quantum.rs:141-220",
      "filePath": "src/backend/quantum.rs",
      "fileName": "quantum.rs",
      "content": "                    }\n                }\n                \"z\" | \"pauli_z\" => {\n                    if let Some(Value::Int(qubit)) = args.first() {\n                        return Some(format!(\"circuit.z({})\", qubit));\n                    }\n                }\n                \"cx\" | \"cnot\" => {\n                    if args.len() >= 2 {\n                        if let (Some(Value::Int(ctrl)), Some(Value::Int(target))) =\n                            (args.get(0), args.get(1))\n                        {\n                            return Some(format!(\"circuit.cx({}, {})\", ctrl, target));\n                        }\n                    }\n                }\n                \"cz\" => {\n                    if args.len() >= 2 {\n                        if let (Some(Value::Int(ctrl)), Some(Value::Int(target))) =\n                            (args.get(0), args.get(1))\n                        {\n                            return Some(format!(\"circuit.cz({}, {})\", ctrl, target));\n                        }\n                    }\n                }\n                \"rx\" => {\n                    if args.len() >= 2 {\n                        if let (Some(angle), Some(Value::Int(qubit))) = (args.get(0), args.get(1))\n                        {\n                            return Some(format!(\"circuit.rx({}, {})\", codegen_value(angle), qubit));\n                        }\n                    }\n                }\n                \"ry\" => {\n                    if args.len() >= 2 {\n                        if let (Some(angle), Some(Value::Int(qubit))) = (args.get(0), args.get(1))\n                        {\n                            return Some(format!(\"circuit.ry({}, {})\", codegen_value(angle), qubit));\n                        }\n                    }\n                }\n                \"rz\" => {\n                    if args.len() >= 2 {\n                        if let (Some(angle), Some(Value::Int(qubit))) = (args.get(0), args.get(1))\n                        {\n                            return Some(format!(\"circuit.rz({}, {})\", codegen_value(angle), qubit));\n                        }\n                    }\n                }\n                _ => {}\n            }\n            None\n        }\n        _ => None,\n    }\n}\n\nfn codegen_value(val: &Value) -> String {\n    match val {\n        Value::Int(n) => format!(\"{}\", n),\n        Value::Float(f) => format!(\"{}\", f),\n        Value::Bool(b) => format!(\"{}\", b),\n        Value::Var(v) => format!(\"v{}\", v.id),\n        Value::Array(_) => \"[]\".to_string(),\n    }\n}\n\nfn estimate_qubits(func: &IRFunction) -> usize {\n    // Simple heuristic: count unique qubit indices in quantum operations\n    let mut max_qubit = 0;\n\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Instruction::Call { args, .. } = inst {\n                for arg in args {\n                    if let Value::Int(n) = arg {\n                        if *n >= 0 {\n                            max_qubit = max_qubit.max(*n as usize);\n                        }\n                    }",
      "type": "rust",
      "keywords": [
        "quantum",
        "codegen_value",
        "estimate_qubits",
        "codegen",
        "ir",
        "function",
        "if",
        "qubit"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "src/backend/quantum.rs:211-229",
      "filePath": "src/backend/quantum.rs",
      "fileName": "quantum.rs",
      "content": "\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Instruction::Call { args, .. } = inst {\n                for arg in args {\n                    if let Value::Int(n) = arg {\n                        if *n >= 0 {\n                            max_qubit = max_qubit.max(*n as usize);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    (max_qubit + 1).max(2) // At least 2 qubits\n}\n\n",
      "type": "rust",
      "keywords": [
        "quantum",
        "ast",
        "if",
        "qubit"
      ],
      "startLine": 211,
      "endLine": 229
    },
    {
      "id": "src/backend/wgsl.rs:1-80",
      "filePath": "src/backend/wgsl.rs",
      "fileName": "wgsl.rs",
      "content": "use crate::middle::ir::*;\nuse anyhow::Result;\n\npub fn codegen(module: &Module) -> Result<String> {\n    let mut output = String::new();\n\n    output.push_str(\"// Generated WGSL code\\n\\n\");\n\n    for func in &module.functions {\n        output.push_str(&codegen_function(func)?);\n        output.push('\\n');\n    }\n\n    Ok(output)\n}\n\nfn codegen_function(func: &IRFunction) -> Result<String> {\n    let mut output = String::new();\n\n    // Function signature\n    output.push_str(&format!(\"fn {}(\", func.name));\n    for (i, (name, ty)) in func.params.iter().enumerate() {\n        if i > 0 {\n            output.push_str(\", \");\n        }\n        output.push_str(&format!(\"{}: {}\", name, wgsl_type(ty)));\n    }\n    output.push_str(&format!(\") -> {} {{\\n\", wgsl_type(&func.return_type)));\n\n    // Variable declarations (collect all SSA vars)\n    let mut declared_vars = std::collections::HashSet::new();\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Some(dest) = get_dest_var(inst) {\n                if declared_vars.insert(dest.id) {\n                    output.push_str(&format!(\"  var {}: {};\\n\", var_name(dest), infer_var_type(inst)));\n                }\n            }\n        }\n    }\n\n    output.push('\\n');\n\n    // Blocks (WGSL doesn't have explicit blocks, so we flatten)\n    for block in &func.blocks {\n        if block.label != \"entry\" {\n            output.push_str(&format!(\"  // {}\\n\", block.label));\n        }\n\n        for inst in &block.instructions {\n            output.push_str(&format!(\"  {}\\n\", codegen_instruction(inst)?));\n        }\n\n        output.push_str(&format!(\"  {}\\n\", codegen_terminator(&block.terminator)?));\n    }\n\n    output.push_str(\"}\\n\");\n    Ok(output)\n}\n\nfn codegen_instruction(inst: &Instruction) -> Result<String> {\n    match inst {\n        Instruction::Assign { dest, value } => {\n            Ok(format!(\"{} = {};\", var_name(*dest), codegen_value(value)))\n        }\n        Instruction::BinaryOp {\n            dest,\n            op,\n            left,\n            right,\n        } => Ok(format!(\n            \"{} = {} {} {};\",\n            var_name(*dest),\n            codegen_value(left),\n            wgsl_binop(*op),\n            codegen_value(right)\n        )),\n        Instruction::UnaryOp { dest, op, operand } => Ok(format!(\n            \"{} = {}({});\",\n            var_name(*dest),",
      "type": "rust",
      "keywords": [
        "wgsl",
        "codegen",
        "codegen_function",
        "codegen_instruction",
        "type",
        "ir",
        "middle",
        "function",
        "variable",
        "if"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/backend/wgsl.rs:71-150",
      "filePath": "src/backend/wgsl.rs",
      "fileName": "wgsl.rs",
      "content": "        } => Ok(format!(\n            \"{} = {} {} {};\",\n            var_name(*dest),\n            codegen_value(left),\n            wgsl_binop(*op),\n            codegen_value(right)\n        )),\n        Instruction::UnaryOp { dest, op, operand } => Ok(format!(\n            \"{} = {}({});\",\n            var_name(*dest),\n            wgsl_unop(*op),\n            codegen_value(operand)\n        )),\n        Instruction::Load { dest, array, index } => Ok(format!(\n            \"{} = {}[{}];\",\n            var_name(*dest),\n            var_name(*array),\n            codegen_value(index)\n        )),\n        Instruction::Store {\n            array,\n            index,\n            value,\n        } => Ok(format!(\n            \"{}[{}] = {};\",\n            var_name(*array),\n            codegen_value(index),\n            codegen_value(value)\n        )),\n        Instruction::Call {\n            dest,\n            function,\n            args,\n        } => {\n            let args_str = args\n                .iter()\n                .map(codegen_value)\n                .collect::<Vec<_>>()\n                .join(\", \");\n            if let Some(d) = dest {\n                Ok(format!(\"{} = {}({});\", var_name(*d), function, args_str))\n            } else {\n                Ok(format!(\"{}({});\", function, args_str))\n            }\n        }\n        Instruction::Phi { .. } => {\n            // Phi nodes should be eliminated before codegen\n            Ok(\"// phi node\".to_string())\n        }\n        Instruction::DomainConversion { dest, source, from_domain, to_domain, encoding } => {\n            // Domain conversions are handled by orchestrator, not in WGSL\n            // Just pass through the value\n            Ok(format!(\n                \"{} = {}; // conversion {:?} -> {:?} ({:?})\",\n                var_name(*dest),\n                codegen_value(source),\n                from_domain,\n                to_domain,\n                encoding\n            ))\n        }\n    }\n}\n\nfn codegen_terminator(term: &Terminator) -> Result<String> {\n    match term {\n        Terminator::Return(val) => Ok(format!(\"return {};\", codegen_value(val))),\n        Terminator::ReturnVoid => Ok(\"return;\".to_string()),\n        Terminator::Branch { .. } | Terminator::Jump(_) => {\n            // Control flow should be handled differently in WGSL\n            Ok(\"// branch\".to_string())\n        }\n    }\n}\n\nfn codegen_value(val: &Value) -> String {\n    match val {\n        Value::Var(v) => var_name(*v),\n        Value::Int(n) => format!(\"{}\", n),\n        Value::Float(f) => format!(\"{}\", f),",
      "type": "rust",
      "keywords": [
        "wgsl",
        "codegen_terminator",
        "codegen_value",
        "codegen",
        "orchestrator",
        "function",
        "if"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/backend/wgsl.rs:141-220",
      "filePath": "src/backend/wgsl.rs",
      "fileName": "wgsl.rs",
      "content": "            Ok(\"// branch\".to_string())\n        }\n    }\n}\n\nfn codegen_value(val: &Value) -> String {\n    match val {\n        Value::Var(v) => var_name(*v),\n        Value::Int(n) => format!(\"{}\", n),\n        Value::Float(f) => format!(\"{}\", f),\n        Value::Bool(b) => format!(\"{}\", b),\n        Value::Array(elements) => {\n            let elems_str = elements.iter().map(codegen_value).collect::<Vec<_>>().join(\", \");\n            format!(\"array({})\", elems_str)\n        }\n    }\n}\n\nfn var_name(var: SSAVar) -> String {\n    format!(\"v{}\", var.id)\n}\n\nfn wgsl_type(ty: &IRType) -> String {\n    match ty {\n        IRType::Int => \"i32\".to_string(),\n        IRType::Float => \"f32\".to_string(),\n        IRType::Bool => \"bool\".to_string(),\n        IRType::Array(elem, Some(size)) => format!(\"array<{}, {}>\", wgsl_type(elem), size),\n        IRType::Array(elem, None) => format!(\"array<{}>\", wgsl_type(elem)),\n        IRType::Qubit => \"u32\".to_string(), // Placeholder\n        IRType::Void => \"void\".to_string(),\n    }\n}\n\nfn wgsl_binop(op: BinOp) -> &'static str {\n    match op {\n        BinOp::Add => \"+\",\n        BinOp::Sub => \"-\",\n        BinOp::Mul => \"*\",\n        BinOp::Div => \"/\",\n        BinOp::Mod => \"%\",\n        BinOp::Eq => \"==\",\n        BinOp::Ne => \"!=\",\n        BinOp::Lt => \"<\",\n        BinOp::Le => \"<=\",\n        BinOp::Gt => \">\",\n        BinOp::Ge => \">=\",\n        BinOp::And => \"&&\",\n        BinOp::Or => \"||\",\n    }\n}\n\nfn wgsl_unop(op: UnOp) -> &'static str {\n    match op {\n        UnOp::Neg => \"-\",\n        UnOp::Not => \"!\",\n    }\n}\n\nfn get_dest_var(inst: &Instruction) -> Option<SSAVar> {\n    match inst {\n        Instruction::Assign { dest, .. }\n        | Instruction::BinaryOp { dest, .. }\n        | Instruction::UnaryOp { dest, .. }\n        | Instruction::Load { dest, .. }\n        | Instruction::Phi { dest, .. } => Some(*dest),\n        Instruction::Call { dest, .. } => *dest,\n        _ => None,\n    }\n}\n\nfn infer_var_type(inst: &Instruction) -> String {\n    // Simplified type inference for WGSL variables\n    match inst {\n        Instruction::Assign { value, .. } => match value {\n            Value::Int(_) => \"i32\".to_string(),\n            Value::Float(_) => \"f32\".to_string(),\n            Value::Bool(_) => \"bool\".to_string(),\n            _ => \"i32\".to_string(), // Default\n        },",
      "type": "rust",
      "keywords": [
        "wgsl",
        "codegen_value",
        "var_name",
        "wgsl_type",
        "wgsl_binop",
        "wgsl_unop",
        "get_dest_var",
        "infer_var_type",
        "codegen",
        "type",
        "ir",
        "variable",
        "if",
        "qubit"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "src/backend/wgsl.rs:211-234",
      "filePath": "src/backend/wgsl.rs",
      "fileName": "wgsl.rs",
      "content": "\nfn infer_var_type(inst: &Instruction) -> String {\n    // Simplified type inference for WGSL variables\n    match inst {\n        Instruction::Assign { value, .. } => match value {\n            Value::Int(_) => \"i32\".to_string(),\n            Value::Float(_) => \"f32\".to_string(),\n            Value::Bool(_) => \"bool\".to_string(),\n            _ => \"i32\".to_string(), // Default\n        },\n        Instruction::BinaryOp { op, .. } => match op {\n            BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge | BinOp::And | BinOp::Or => \"bool\".to_string(),\n            _ => \"i32\".to_string(),\n        },\n        Instruction::UnaryOp { op, .. } => match op {\n            UnOp::Not => \"bool\".to_string(),\n            UnOp::Neg => \"i32\".to_string(),\n        },\n        _ => \"i32\".to_string(),\n    }\n}\n\n\n",
      "type": "rust",
      "keywords": [
        "wgsl",
        "infer_var_type",
        "type",
        "variable",
        "if"
      ],
      "startLine": 211,
      "endLine": 234
    },
    {
      "id": "src/cli.rs:1-80",
      "filePath": "src/cli.rs",
      "fileName": "cli.rs",
      "content": "use anyhow::{Context, Result};\nuse clap::{Parser, Subcommand, ValueEnum};\nuse std::path::PathBuf;\n\n#[derive(Parser)]\n#[command(name = \"quarkdsl\")]\n#[command(about = \"QuarkDSL Compiler - Unified compiler for GPU and Quantum backends\")]\n#[command(version)]\npub struct Args {\n    #[command(subcommand)]\n    pub command: Command,\n}\n\n#[derive(Subcommand)]\npub enum Command {\n    /// Compile DSL source to target backend\n    Compile {\n        /// Input DSL file\n        input: PathBuf,\n\n        /// Target backend\n        #[arg(short, long, value_enum)]\n        target: Target,\n\n        /// Output file (optional, defaults to stdout)\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n\n        /// Dump IR before code generation\n        #[arg(long)]\n        dump_ir: bool,\n\n        /// Enable optimizations\n        #[arg(short = 'O', long)]\n        optimize: bool,\n    },\n\n    /// Parse and dump AST\n    Parse {\n        /// Input DSL file\n        input: PathBuf,\n    },\n\n    /// Lower to IR and dump\n    Lower {\n        /// Input DSL file\n        input: PathBuf,\n\n        /// Enable optimizations\n        #[arg(short = 'O', long)]\n        optimize: bool,\n    },\n}\n\n#[derive(Clone, Copy, ValueEnum)]\npub enum Target {\n    /// WebGPU WGSL backend\n    Wgsl,\n    /// Quantum Qiskit backend\n    Quantum,\n    /// Python Orchestrator (Hybrid GPU + Quantum)\n    Orchestrator,\n}\n\npub fn run(args: Args) -> Result<()> {\n    match args.command {\n        Command::Compile {\n            input,\n            target,\n            output,\n            dump_ir,\n            optimize,\n        } => {\n            let source = std::fs::read_to_string(&input)\n                .with_context(|| format!(\"Failed to read input file: {:?}\", input))?;\n\n            // Frontend: Parse\n            let ast = crate::frontend::parse(&source)\n                .with_context(|| \"Failed to parse source\")?;\n",
      "type": "rust",
      "keywords": [
        "cli",
        "run",
        "args",
        "command",
        "target",
        "parser",
        "ast",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "optimize",
        "ir",
        "lower",
        "backend",
        "frontend",
        "orchestrator",
        "if",
        "hybrid"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/cli.rs:71-150",
      "filePath": "src/cli.rs",
      "fileName": "cli.rs",
      "content": "            dump_ir,\n            optimize,\n        } => {\n            let source = std::fs::read_to_string(&input)\n                .with_context(|| format!(\"Failed to read input file: {:?}\", input))?;\n\n            // Frontend: Parse\n            let ast = crate::frontend::parse(&source)\n                .with_context(|| \"Failed to parse source\")?;\n\n            // Frontend: Type check\n            crate::frontend::typecheck(&ast)\n                .with_context(|| \"Type checking failed\")?;\n\n            // Middle-end: Lower to IR\n            let mut ir = crate::middle::lower_to_ir(&ast)\n                .with_context(|| \"Failed to lower to IR\")?;\n\n            // Middle-end: Optimize\n            if optimize {\n                crate::middle::optimize(&mut ir);\n            }\n\n            // Dump IR if requested\n            if dump_ir {\n                eprintln!(\"=== IR ===\");\n                eprintln!(\"{}\", crate::middle::dump_ir(&ir));\n                eprintln!();\n            }\n\n            // Backend: Code generation\n            let code = match target {\n                Target::Wgsl => crate::backend::wgsl::codegen(&ir)?,\n                Target::Quantum => crate::backend::quantum::codegen(&ir)?,\n                Target::Orchestrator => crate::backend::orchestrator::generate_orchestrator(&ir)?,\n            };\n\n            // Output\n            if let Some(output_path) = output {\n                std::fs::write(&output_path, code)\n                    .with_context(|| format!(\"Failed to write output: {:?}\", output_path))?;\n                println!(\"âœ“ Compiled to {:?}\", output_path);\n            } else {\n                println!(\"{}\", code);\n            }\n\n            Ok(())\n        }\n\n        Command::Parse { input } => {\n            let source = std::fs::read_to_string(&input)\n                .with_context(|| format!(\"Failed to read input file: {:?}\", input))?;\n\n            let ast = crate::frontend::parse(&source)\n                .with_context(|| \"Failed to parse source\")?;\n\n            println!(\"{:#?}\", ast);\n            Ok(())\n        }\n\n        Command::Lower { input, optimize } => {\n            let source = std::fs::read_to_string(&input)\n                .with_context(|| format!(\"Failed to read input file: {:?}\", input))?;\n\n            let ast = crate::frontend::parse(&source)\n                .with_context(|| \"Failed to parse source\")?;\n\n            crate::frontend::typecheck(&ast)\n                .with_context(|| \"Type checking failed\")?;\n\n            let mut ir = crate::middle::lower_to_ir(&ast)\n                .with_context(|| \"Failed to lower to IR\")?;\n\n            if optimize {\n                crate::middle::optimize(&mut ir);\n            }\n\n            println!(\"{}\", crate::middle::dump_ir(&ir));\n            Ok(())\n        }",
      "type": "rust",
      "keywords": [
        "cli",
        "ast",
        "compile",
        "codegen",
        "wgsl",
        "quantum",
        "type",
        "check",
        "optimize",
        "ir",
        "lower",
        "backend",
        "frontend",
        "middle",
        "orchestrator",
        "if"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/cli.rs:141-154",
      "filePath": "src/cli.rs",
      "fileName": "cli.rs",
      "content": "            let mut ir = crate::middle::lower_to_ir(&ast)\n                .with_context(|| \"Failed to lower to IR\")?;\n\n            if optimize {\n                crate::middle::optimize(&mut ir);\n            }\n\n            println!(\"{}\", crate::middle::dump_ir(&ir));\n            Ok(())\n        }\n    }\n}\n\n",
      "type": "rust",
      "keywords": [
        "cli",
        "ast",
        "optimize",
        "ir",
        "lower",
        "middle",
        "if"
      ],
      "startLine": 141,
      "endLine": 154
    },
    {
      "id": "src/frontend/ast.rs:1-80",
      "filePath": "src/frontend/ast.rs",
      "fileName": "ast.rs",
      "content": "/// Abstract Syntax Tree definitions for QuarkDSL\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Program {\n    pub functions: Vec<Function>,\n}\n\n/// Execution domain for functions\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum Domain {\n    Classical,  // CPU execution (default)\n    Gpu,        // GPU execution (@gpu)\n    Quantum,    // Quantum execution (@quantum)\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Function {\n    pub name: String,\n    pub params: Vec<Param>,\n    pub return_type: Type,\n    pub body: Vec<Statement>,\n    pub domain: Domain,  // NEW: execution domain\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Param {\n    pub name: String,\n    pub ty: Type,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Type {\n    Int,\n    Float,\n    Bool,\n    Array(Box<Type>, Option<usize>), // element type, optional size\n    Qubit,\n    Void,\n    Tensor(Box<Type>),  // NEW: GPU tensor type, e.g., tensor<float>\n    QState,             // NEW: Quantum state type\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Statement {\n    Let {\n        name: String,\n        ty: Option<Type>,\n        value: Expression,\n    },\n    Assign {\n        target: String,\n        index: Option<Box<Expression>>,\n        value: Expression,\n    },\n    Return(Expression),\n    Expression(Expression),\n    For {\n        var: String,\n        start: Expression,\n        end: Expression,\n        body: Vec<Statement>,\n    },\n    If {\n        condition: Expression,\n        then_body: Vec<Statement>,\n        else_body: Option<Vec<Statement>>,\n    },\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Expression {\n    IntLiteral(i64),\n    FloatLiteral(f64),\n    BoolLiteral(bool),\n    Variable(String),\n    ArrayLiteral(Vec<Expression>),\n    Index {\n        array: Box<Expression>,",
      "type": "rust",
      "keywords": [
        "ast",
        "program",
        "function",
        "param",
        "domain",
        "type",
        "statement",
        "expression",
        "quantum",
        "gpu",
        "variable",
        "if",
        "qubit"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/frontend/ast.rs:71-141",
      "filePath": "src/frontend/ast.rs",
      "fileName": "ast.rs",
      "content": "\n#[derive(Debug, Clone, PartialEq)]\npub enum Expression {\n    IntLiteral(i64),\n    FloatLiteral(f64),\n    BoolLiteral(bool),\n    Variable(String),\n    ArrayLiteral(Vec<Expression>),\n    Index {\n        array: Box<Expression>,\n        index: Box<Expression>,\n    },\n    Binary {\n        op: BinaryOp,\n        left: Box<Expression>,\n        right: Box<Expression>,\n    },\n    Unary {\n        op: UnaryOp,\n        operand: Box<Expression>,\n    },\n    Call {\n        function: String,\n        args: Vec<Expression>,\n    },\n    Map {\n        function: String,\n        array: Box<Expression>,\n    },\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum BinaryOp {\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n    Eq,\n    Ne,\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    And,\n    Or,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum UnaryOp {\n    Neg,\n    Not,\n}\n\nimpl std::fmt::Display for Type {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            Type::Int => write!(f, \"int\"),\n            Type::Float => write!(f, \"float\"),\n            Type::Bool => write!(f, \"bool\"),\n            Type::Array(elem, Some(size)) => write!(f, \"[{}; {}]\", elem, size),\n            Type::Array(elem, None) => write!(f, \"[{}]\", elem),\n            Type::Qubit => write!(f, \"qubit\"),\n            Type::Void => write!(f, \"void\"),\n            Type::Tensor(elem) => write!(f, \"tensor<{}>\", elem),\n            Type::QState => write!(f, \"qstate\"),\n        }\n    }\n}\n\n",
      "type": "rust",
      "keywords": [
        "ast",
        "fmt",
        "expression",
        "binaryop",
        "unaryop",
        "std",
        "type",
        "function",
        "variable",
        "qubit"
      ],
      "startLine": 71,
      "endLine": 141
    },
    {
      "id": "src/frontend/lexer.rs:1-80",
      "filePath": "src/frontend/lexer.rs",
      "fileName": "lexer.rs",
      "content": "use logos::Logos;\n\n// Lexical Analysis: DFA-based tokenization using Logos library\n// Logos automatically generates DFA from regex patterns (Regex to DFA conversion)\n// Thompson's Construction: Regex â†’ Îµ-NFA â†’ NFA â†’ DFA (done internally by Logos)\n// DFA Minimization: Logos optimizes the generated DFA\n\n#[derive(Logos, Debug, Clone, PartialEq)]\n#[logos(skip r\"[ \\t\\n\\f]+\")]      // Skip whitespace (regex pattern)\n#[logos(skip r\"//[^\\n]*\")]        // Skip single-line comments (regex pattern)\npub enum Token {\n    // Keywords (exact string matching in DFA)\n    #[token(\"fn\")]\n    Fn,\n    #[token(\"let\")]\n    Let,\n    #[token(\"return\")]\n    Return,\n    #[token(\"if\")]\n    If,\n    #[token(\"else\")]\n    Else,\n    #[token(\"for\")]\n    For,\n    #[token(\"in\")]\n    In,\n    #[token(\"map\")]\n    Map,\n\n    // Annotations (domain-specific keywords)\n    #[token(\"@gpu\")]\n    GpuAnnotation,\n    #[token(\"@quantum\")]\n    QuantumAnnotation,\n\n    // Types (keywords for type system)\n    #[token(\"int\")]\n    Int,\n    #[token(\"float\")]\n    Float,\n    #[token(\"bool\")]\n    Bool,\n    #[token(\"qubit\")]\n    Qubit,\n    #[token(\"void\")]\n    Void,\n    #[token(\"tensor\")]\n    Tensor,\n    #[token(\"qstate\")]\n    QState,\n\n    // Literals (constant values)\n    #[token(\"true\")]\n    True,\n    #[token(\"false\")]\n    False,\n\n    // Regex to DFA: Integer literal pattern\n    #[regex(r\"[0-9]+\", |lex| lex.slice().parse().ok())]\n    IntLiteral(i64),\n\n    // Regex to DFA: Float literal pattern (digits.digits)\n    #[regex(r\"[0-9]+\\.[0-9]+\", |lex| lex.slice().parse().ok())]\n    FloatLiteral(f64),\n\n    // Regex to DFA: Identifier pattern (letter/underscore followed by alphanumeric)\n    // Maximal Munch: Longest match principle\n    #[regex(r\"[a-zA-Z_][a-zA-Z0-9_]*\", |lex| lex.slice().to_string())]\n    Identifier(String),\n\n    // Operators\n    #[token(\"+\")]\n    Plus,\n    #[token(\"-\")]\n    Minus,\n    #[token(\"*\")]\n    Star,\n    #[token(\"/\")]\n    Slash,\n    #[token(\"%\")]",
      "type": "rust",
      "keywords": [
        "lexer",
        "token",
        "quantum",
        "gpu",
        "type",
        "optimize",
        "if",
        "qubit"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/frontend/lexer.rs:71-150",
      "filePath": "src/frontend/lexer.rs",
      "fileName": "lexer.rs",
      "content": "    // Operators\n    #[token(\"+\")]\n    Plus,\n    #[token(\"-\")]\n    Minus,\n    #[token(\"*\")]\n    Star,\n    #[token(\"/\")]\n    Slash,\n    #[token(\"%\")]\n    Percent,\n\n    #[token(\"==\")]\n    EqEq,\n    #[token(\"!=\")]\n    Ne,\n    #[token(\"<\")]\n    Lt,\n    #[token(\"<=\")]\n    Le,\n    #[token(\">\")]\n    Gt,\n    #[token(\">=\")]\n    Ge,\n\n    #[token(\"&&\")]\n    AndAnd,\n    #[token(\"||\")]\n    OrOr,\n    #[token(\"!\")]\n    Bang,\n\n    #[token(\"=\")]\n    Eq,\n\n    // Delimiters\n    #[token(\"(\")]\n    LParen,\n    #[token(\")\")]\n    RParen,\n    #[token(\"{\")]\n    LBrace,\n    #[token(\"}\")]\n    RBrace,\n    #[token(\"[\")]\n    LBracket,\n    #[token(\"]\")]\n    RBracket,\n\n    #[token(\",\")]\n    Comma,\n    #[token(\";\")]\n    Semicolon,\n    #[token(\":\")]\n    Colon,\n    #[token(\"->\")]\n    Arrow,\n    #[token(\"..\")]\n    DotDot,\n}\n\nimpl std::fmt::Display for Token {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            Token::Fn => write!(f, \"fn\"),\n            Token::Let => write!(f, \"let\"),\n            Token::Return => write!(f, \"return\"),\n            Token::If => write!(f, \"if\"),\n            Token::Else => write!(f, \"else\"),\n            Token::For => write!(f, \"for\"),\n            Token::In => write!(f, \"in\"),\n            Token::Map => write!(f, \"map\"),\n            Token::GpuAnnotation => write!(f, \"@gpu\"),\n            Token::QuantumAnnotation => write!(f, \"@quantum\"),\n            Token::Int => write!(f, \"int\"),\n            Token::Float => write!(f, \"float\"),\n            Token::Bool => write!(f, \"bool\"),\n            Token::Qubit => write!(f, \"qubit\"),\n            Token::Void => write!(f, \"void\"),\n            Token::Tensor => write!(f, \"tensor\"),",
      "type": "rust",
      "keywords": [
        "lexer",
        "fmt",
        "std",
        "token",
        "quantum",
        "gpu",
        "if",
        "qubit"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/frontend/lexer.rs:141-187",
      "filePath": "src/frontend/lexer.rs",
      "fileName": "lexer.rs",
      "content": "            Token::In => write!(f, \"in\"),\n            Token::Map => write!(f, \"map\"),\n            Token::GpuAnnotation => write!(f, \"@gpu\"),\n            Token::QuantumAnnotation => write!(f, \"@quantum\"),\n            Token::Int => write!(f, \"int\"),\n            Token::Float => write!(f, \"float\"),\n            Token::Bool => write!(f, \"bool\"),\n            Token::Qubit => write!(f, \"qubit\"),\n            Token::Void => write!(f, \"void\"),\n            Token::Tensor => write!(f, \"tensor\"),\n            Token::QState => write!(f, \"qstate\"),\n            Token::True => write!(f, \"true\"),\n            Token::False => write!(f, \"false\"),\n            Token::IntLiteral(n) => write!(f, \"{}\", n),\n            Token::FloatLiteral(n) => write!(f, \"{}\", n),\n            Token::Identifier(s) => write!(f, \"{}\", s),\n            Token::Plus => write!(f, \"+\"),\n            Token::Minus => write!(f, \"-\"),\n            Token::Star => write!(f, \"*\"),\n            Token::Slash => write!(f, \"/\"),\n            Token::Percent => write!(f, \"%\"),\n            Token::EqEq => write!(f, \"==\"),\n            Token::Ne => write!(f, \"!=\"),\n            Token::Lt => write!(f, \"<\"),\n            Token::Le => write!(f, \"<=\"),\n            Token::Gt => write!(f, \">\"),\n            Token::Ge => write!(f, \">=\"),\n            Token::AndAnd => write!(f, \"&&\"),\n            Token::OrOr => write!(f, \"||\"),\n            Token::Bang => write!(f, \"!\"),\n            Token::Eq => write!(f, \"=\"),\n            Token::LParen => write!(f, \"(\"),\n            Token::RParen => write!(f, \")\"),\n            Token::LBrace => write!(f, \"{{\"),\n            Token::RBrace => write!(f, \"}}\"),\n            Token::LBracket => write!(f, \"[\"),\n            Token::RBracket => write!(f, \"]\"),\n            Token::Comma => write!(f, \",\"),\n            Token::Semicolon => write!(f, \";\"),\n            Token::Colon => write!(f, \":\"),\n            Token::Arrow => write!(f, \"->\"),\n            Token::DotDot => write!(f, \"..\"),\n        }\n    }\n}\n\n",
      "type": "rust",
      "keywords": [
        "lexer",
        "token",
        "quantum",
        "gpu",
        "if",
        "qubit"
      ],
      "startLine": 141,
      "endLine": 187
    },
    {
      "id": "src/frontend/mod.rs:1-9",
      "filePath": "src/frontend/mod.rs",
      "fileName": "mod.rs",
      "content": "pub mod ast;\nmod lexer;\nmod parser;\nmod typecheck;\n\npub use parser::parse;\npub use typecheck::typecheck;\n\n",
      "type": "rust",
      "keywords": [
        "mod",
        "lexer",
        "parser",
        "ast",
        "type",
        "check"
      ],
      "startLine": 1,
      "endLine": 9
    },
    {
      "id": "src/frontend/parser.rs:1-80",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "use super::ast::*;\nuse super::lexer::Token;\nuse anyhow::{anyhow, bail, Result};\nuse logos::Logos;\n\n// Syntax Analysis: Recursive Descent Parser (RDP)\n// Top-Down Parsing: Start from root (Program) and expand to leaves\n// LL(1) Grammar: Left-to-right scan, Leftmost derivation, 1 lookahead token\n// Each grammar production rule is implemented as a recursive function\n\npub struct Parser {\n    tokens: Vec<Token>,  // Token stream from lexer\n    pos: usize,          // Current position (lookahead pointer)\n}\n\nimpl Parser {\n    fn new(tokens: Vec<Token>) -> Self {\n        Self { tokens, pos: 0 }\n    }\n\n    // Lookahead: Peek at current token without consuming\n    fn current(&self) -> Option<&Token> {\n        self.tokens.get(self.pos)\n    }\n\n    // Consume current token and advance position\n    fn advance(&mut self) -> Option<Token> {\n        let token = self.tokens.get(self.pos).cloned();\n        self.pos += 1;\n        token\n    }\n\n    // Predictive Parsing: Expect specific token based on grammar\n    fn expect(&mut self, expected: Token) -> Result<()> {\n        let current = self.current().ok_or_else(|| anyhow!(\"Unexpected EOF\"))?;\n        if std::mem::discriminant(current) != std::mem::discriminant(&expected) {\n            bail!(\"Expected {:?}, found {:?}\", expected, current);\n        }\n        self.advance();\n        Ok(())\n    }\n\n    // Grammar Rule: Program â†’ Function*\n    // Top-Down Parsing: Start from root production\n    fn parse_program(&mut self) -> Result<Program> {\n        let mut functions = Vec::new();\n        while self.current().is_some() {\n            functions.push(self.parse_function()?);  // Recursive call\n        }\n        Ok(Program { functions })\n    }\n\n    // Grammar Rule: Function â†’ Domain? \"fn\" Identifier \"(\" Parameters \")\" \"->\" Type Block\n    // Recursive Descent: Each grammar rule is a function\n    fn parse_function(&mut self) -> Result<Function> {\n        // Parse optional domain annotation (Domain?)\n        // First Set: {@gpu, @quantum, fn}\n        let domain = match self.current() {\n            Some(Token::GpuAnnotation) => {\n                self.advance();\n                Domain::Gpu\n            }\n            Some(Token::QuantumAnnotation) => {\n                self.advance();\n                Domain::Quantum\n            }\n            _ => Domain::Classical,\n        };\n\n        self.expect(Token::Fn)?;\n\n        let name = match self.advance() {\n            Some(Token::Identifier(s)) => s,\n            _ => bail!(\"Expected function name\"),\n        };\n\n        self.expect(Token::LParen)?;\n        let params = self.parse_params()?;\n        self.expect(Token::RParen)?;\n",
      "type": "rust",
      "keywords": [
        "parser",
        "new",
        "current",
        "advance",
        "expect",
        "parse_program",
        "parse_function",
        "lexer",
        "ast",
        "token",
        "quantum",
        "gpu",
        "type",
        "ir",
        "function",
        "if"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/frontend/parser.rs:71-150",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "\n        let name = match self.advance() {\n            Some(Token::Identifier(s)) => s,\n            _ => bail!(\"Expected function name\"),\n        };\n\n        self.expect(Token::LParen)?;\n        let params = self.parse_params()?;\n        self.expect(Token::RParen)?;\n\n        self.expect(Token::Arrow)?;\n        let return_type = self.parse_type()?;\n\n        self.expect(Token::LBrace)?;\n        let body = self.parse_statements()?;\n        self.expect(Token::RBrace)?;\n\n        Ok(Function {\n            name,\n            params,\n            return_type,\n            body,\n            domain,  // NEW: include domain\n        })\n    }\n\n    fn parse_params(&mut self) -> Result<Vec<Param>> {\n        let mut params = Vec::new();\n\n        if matches!(self.current(), Some(Token::RParen)) {\n            return Ok(params);\n        }\n\n        loop {\n            let name = match self.advance() {\n                Some(Token::Identifier(s)) => s,\n                _ => bail!(\"Expected parameter name\"),\n            };\n\n            self.expect(Token::Colon)?;\n            let ty = self.parse_type()?;\n\n            params.push(Param { name, ty });\n\n            if !matches!(self.current(), Some(Token::Comma)) {\n                break;\n            }\n            self.advance();\n        }\n\n        Ok(params)\n    }\n\n    fn parse_type(&mut self) -> Result<Type> {\n        match self.advance() {\n            Some(Token::Int) => Ok(Type::Int),\n            Some(Token::Float) => Ok(Type::Float),\n            Some(Token::Bool) => Ok(Type::Bool),\n            Some(Token::Qubit) => Ok(Type::Qubit),\n            Some(Token::Void) => Ok(Type::Void),\n            Some(Token::QState) => Ok(Type::QState),  // NEW: qstate type\n            Some(Token::Tensor) => {\n                // NEW: tensor<T> type\n                self.expect(Token::Lt)?;\n                let elem_type = self.parse_type()?;\n                self.expect(Token::Gt)?;\n                Ok(Type::Tensor(Box::new(elem_type)))\n            }\n            Some(Token::LBracket) => {\n                let elem_type = self.parse_type()?;\n                let size = if matches!(self.current(), Some(Token::Semicolon)) {\n                    self.advance();\n                    match self.advance() {\n                        Some(Token::IntLiteral(n)) => Some(n as usize),\n                        _ => bail!(\"Expected array size\"),\n                    }\n                } else {\n                    None\n                };\n                self.expect(Token::RBracket)?;",
      "type": "rust",
      "keywords": [
        "parser",
        "parse_params",
        "parse_type",
        "token",
        "type",
        "statement",
        "function",
        "loop",
        "if",
        "qubit"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/frontend/parser.rs:141-220",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "                let size = if matches!(self.current(), Some(Token::Semicolon)) {\n                    self.advance();\n                    match self.advance() {\n                        Some(Token::IntLiteral(n)) => Some(n as usize),\n                        _ => bail!(\"Expected array size\"),\n                    }\n                } else {\n                    None\n                };\n                self.expect(Token::RBracket)?;\n                Ok(Type::Array(Box::new(elem_type), size))\n            }\n            _ => bail!(\"Expected type\"),\n        }\n    }\n\n    fn parse_statements(&mut self) -> Result<Vec<Statement>> {\n        let mut statements = Vec::new();\n\n        while !matches!(self.current(), Some(Token::RBrace) | None) {\n            statements.push(self.parse_statement()?);\n        }\n\n        Ok(statements)\n    }\n\n    fn parse_statement(&mut self) -> Result<Statement> {\n        match self.current() {\n            Some(Token::Let) => self.parse_let(),\n            Some(Token::Return) => self.parse_return(),\n            Some(Token::For) => self.parse_for(),\n            Some(Token::If) => self.parse_if(),\n            Some(Token::Identifier(_)) => {\n                // Could be assignment or expression statement\n                let checkpoint = self.pos;\n                if let Ok(name) = self.try_parse_identifier() {\n                    if matches!(self.current(), Some(Token::Eq | Token::LBracket)) {\n                        return self.parse_assignment(name);\n                    }\n                }\n                self.pos = checkpoint;\n                let expr = self.parse_expression()?;\n                self.expect(Token::Semicolon)?;\n                Ok(Statement::Expression(expr))\n            }\n            _ => {\n                let expr = self.parse_expression()?;\n                self.expect(Token::Semicolon)?;\n                Ok(Statement::Expression(expr))\n            }\n        }\n    }\n\n    fn try_parse_identifier(&mut self) -> Result<String> {\n        match self.advance() {\n            Some(Token::Identifier(s)) => Ok(s),\n            _ => bail!(\"Expected identifier\"),\n        }\n    }\n\n    fn parse_let(&mut self) -> Result<Statement> {\n        self.expect(Token::Let)?;\n        let name = self.try_parse_identifier()?;\n\n        let ty = if matches!(self.current(), Some(Token::Colon)) {\n            self.advance();\n            Some(self.parse_type()?)\n        } else {\n            None\n        };\n\n        self.expect(Token::Eq)?;\n        let value = self.parse_expression()?;\n        self.expect(Token::Semicolon)?;\n\n        Ok(Statement::Let { name, ty, value })\n    }\n\n    fn parse_assignment(&mut self, name: String) -> Result<Statement> {\n        let index = if matches!(self.current(), Some(Token::LBracket)) {",
      "type": "rust",
      "keywords": [
        "parser",
        "parse_statements",
        "parse_statement",
        "try_parse_identifier",
        "parse_let",
        "parse_assignment",
        "token",
        "type",
        "check",
        "expression",
        "statement",
        "if"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "src/frontend/parser.rs:211-290",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "\n        self.expect(Token::Eq)?;\n        let value = self.parse_expression()?;\n        self.expect(Token::Semicolon)?;\n\n        Ok(Statement::Let { name, ty, value })\n    }\n\n    fn parse_assignment(&mut self, name: String) -> Result<Statement> {\n        let index = if matches!(self.current(), Some(Token::LBracket)) {\n            self.advance();\n            let idx = self.parse_expression()?;\n            self.expect(Token::RBracket)?;\n            Some(Box::new(idx))\n        } else {\n            None\n        };\n\n        self.expect(Token::Eq)?;\n        let value = self.parse_expression()?;\n        self.expect(Token::Semicolon)?;\n\n        Ok(Statement::Assign {\n            target: name,\n            index,\n            value,\n        })\n    }\n\n    fn parse_return(&mut self) -> Result<Statement> {\n        self.expect(Token::Return)?;\n\n        // Check if this is a void return (return;)\n        if matches!(self.current(), Some(Token::Semicolon)) {\n            self.advance();\n            // Return a unit/void value - we'll use IntLiteral(0) as placeholder\n            return Ok(Statement::Return(Expression::IntLiteral(0)));\n        }\n\n        let expr = self.parse_expression()?;\n        self.expect(Token::Semicolon)?;\n        Ok(Statement::Return(expr))\n    }\n\n    fn parse_for(&mut self) -> Result<Statement> {\n        self.expect(Token::For)?;\n        let var = self.try_parse_identifier()?;\n        self.expect(Token::In)?;\n        let start = self.parse_expression()?;\n        self.expect(Token::DotDot)?;\n        let end = self.parse_expression()?;\n        self.expect(Token::LBrace)?;\n        let body = self.parse_statements()?;\n        self.expect(Token::RBrace)?;\n\n        Ok(Statement::For {\n            var,\n            start,\n            end,\n            body,\n        })\n    }\n\n    fn parse_if(&mut self) -> Result<Statement> {\n        self.expect(Token::If)?;\n        let condition = self.parse_expression()?;\n        self.expect(Token::LBrace)?;\n        let then_body = self.parse_statements()?;\n        self.expect(Token::RBrace)?;\n\n        let else_body = if matches!(self.current(), Some(Token::Else)) {\n            self.advance();\n            self.expect(Token::LBrace)?;\n            let body = self.parse_statements()?;\n            self.expect(Token::RBrace)?;\n            Some(body)\n        } else {\n            None\n        };\n",
      "type": "rust",
      "keywords": [
        "parser",
        "parse_assignment",
        "parse_return",
        "parse_for",
        "parse_if",
        "token",
        "check",
        "expression",
        "statement",
        "if"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "src/frontend/parser.rs:281-360",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "        let else_body = if matches!(self.current(), Some(Token::Else)) {\n            self.advance();\n            self.expect(Token::LBrace)?;\n            let body = self.parse_statements()?;\n            self.expect(Token::RBrace)?;\n            Some(body)\n        } else {\n            None\n        };\n\n        Ok(Statement::If {\n            condition,\n            then_body,\n            else_body,\n        })\n    }\n\n    // Grammar Rule: Expression â†’ LogicalOr\n    // Precedence Climbing: Parse expressions by precedence levels\n    fn parse_expression(&mut self) -> Result<Expression> {\n        self.parse_or()\n    }\n\n    // Grammar Rule: LogicalOr â†’ LogicalAnd (\"||\" LogicalAnd)*\n    // Left Recursion Elimination: Transformed to iteration\n    // Original (left-recursive): LogicalOr â†’ LogicalOr \"||\" LogicalAnd\n    // Transformed: LogicalOr â†’ LogicalAnd (\"||\" LogicalAnd)*\n    fn parse_or(&mut self) -> Result<Expression> {\n        let mut left = self.parse_and()?;\n\n        // Iteration instead of left recursion\n        while matches!(self.current(), Some(Token::OrOr)) {\n            self.advance();\n            let right = self.parse_and()?;\n            left = Expression::Binary {\n                op: BinaryOp::Or,\n                left: Box::new(left),\n                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }\n\n    fn parse_and(&mut self) -> Result<Expression> {\n        let mut left = self.parse_equality()?;\n\n        while matches!(self.current(), Some(Token::AndAnd)) {\n            self.advance();\n            let right = self.parse_equality()?;\n            left = Expression::Binary {\n                op: BinaryOp::And,\n                left: Box::new(left),\n                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }\n\n    fn parse_equality(&mut self) -> Result<Expression> {\n        let mut left = self.parse_comparison()?;\n\n        while let Some(op) = self.current() {\n            let binary_op = match op {\n                Token::EqEq => BinaryOp::Eq,\n                Token::Ne => BinaryOp::Ne,\n                _ => break,\n            };\n            self.advance();\n            let right = self.parse_comparison()?;\n            left = Expression::Binary {\n                op: binary_op,\n                left: Box::new(left),\n                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }",
      "type": "rust",
      "keywords": [
        "parser",
        "parse_expression",
        "parse_or",
        "parse_and",
        "parse_equality",
        "token",
        "expression",
        "statement",
        "if"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "src/frontend/parser.rs:351-430",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "            let right = self.parse_comparison()?;\n            left = Expression::Binary {\n                op: binary_op,\n                left: Box::new(left),\n                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }\n\n    fn parse_comparison(&mut self) -> Result<Expression> {\n        let mut left = self.parse_term()?;\n\n        while let Some(op) = self.current() {\n            let binary_op = match op {\n                Token::Lt => BinaryOp::Lt,\n                Token::Le => BinaryOp::Le,\n                Token::Gt => BinaryOp::Gt,\n                Token::Ge => BinaryOp::Ge,\n                _ => break,\n            };\n            self.advance();\n            let right = self.parse_term()?;\n            left = Expression::Binary {\n                op: binary_op,\n                left: Box::new(left),\n                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }\n\n    fn parse_term(&mut self) -> Result<Expression> {\n        let mut left = self.parse_factor()?;\n\n        while let Some(op) = self.current() {\n            let binary_op = match op {\n                Token::Plus => BinaryOp::Add,\n                Token::Minus => BinaryOp::Sub,\n                _ => break,\n            };\n            self.advance();\n            let right = self.parse_factor()?;\n            left = Expression::Binary {\n                op: binary_op,\n                left: Box::new(left),\n                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }\n\n    fn parse_factor(&mut self) -> Result<Expression> {\n        let mut left = self.parse_unary()?;\n\n        while let Some(op) = self.current() {\n            let binary_op = match op {\n                Token::Star => BinaryOp::Mul,\n                Token::Slash => BinaryOp::Div,\n                Token::Percent => BinaryOp::Mod,\n                _ => break,\n            };\n            self.advance();\n            let right = self.parse_unary()?;\n            left = Expression::Binary {\n                op: binary_op,\n                left: Box::new(left),\n                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }\n\n    fn parse_unary(&mut self) -> Result<Expression> {\n        match self.current() {\n            Some(Token::Minus) => {",
      "type": "rust",
      "keywords": [
        "parser",
        "parse_comparison",
        "parse_term",
        "parse_factor",
        "parse_unary",
        "token",
        "expression"
      ],
      "startLine": 351,
      "endLine": 430
    },
    {
      "id": "src/frontend/parser.rs:421-500",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "                right: Box::new(right),\n            };\n        }\n\n        Ok(left)\n    }\n\n    fn parse_unary(&mut self) -> Result<Expression> {\n        match self.current() {\n            Some(Token::Minus) => {\n                self.advance();\n                let operand = self.parse_unary()?;\n                Ok(Expression::Unary {\n                    op: UnaryOp::Neg,\n                    operand: Box::new(operand),\n                })\n            }\n            Some(Token::Bang) => {\n                self.advance();\n                let operand = self.parse_unary()?;\n                Ok(Expression::Unary {\n                    op: UnaryOp::Not,\n                    operand: Box::new(operand),\n                })\n            }\n            _ => self.parse_postfix(),\n        }\n    }\n\n    fn parse_postfix(&mut self) -> Result<Expression> {\n        let mut expr = self.parse_primary()?;\n\n        loop {\n            match self.current() {\n                Some(Token::LBracket) => {\n                    self.advance();\n                    let index = self.parse_expression()?;\n                    self.expect(Token::RBracket)?;\n                    expr = Expression::Index {\n                        array: Box::new(expr),\n                        index: Box::new(index),\n                    };\n                }\n                Some(Token::LParen) => {\n                    // Function call\n                    if let Expression::Variable(name) = expr {\n                        self.advance();\n                        let args = self.parse_args()?;\n                        self.expect(Token::RParen)?;\n                        expr = Expression::Call {\n                            function: name,\n                            args,\n                        };\n                    } else {\n                        break;\n                    }\n                }\n                _ => break,\n            }\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_primary(&mut self) -> Result<Expression> {\n        match self.advance() {\n            Some(Token::IntLiteral(n)) => Ok(Expression::IntLiteral(n)),\n            Some(Token::FloatLiteral(f)) => Ok(Expression::FloatLiteral(f)),\n            Some(Token::True) => Ok(Expression::BoolLiteral(true)),\n            Some(Token::False) => Ok(Expression::BoolLiteral(false)),\n            Some(Token::Identifier(name)) => Ok(Expression::Variable(name)),\n            Some(Token::LBracket) => {\n                let elements = self.parse_array_elements()?;\n                self.expect(Token::RBracket)?;\n                Ok(Expression::ArrayLiteral(elements))\n            }\n            Some(Token::LParen) => {\n                let expr = self.parse_expression()?;\n                self.expect(Token::RParen)?;\n                Ok(expr)",
      "type": "rust",
      "keywords": [
        "parser",
        "parse_unary",
        "parse_postfix",
        "parse_primary",
        "token",
        "expression",
        "function",
        "variable",
        "loop",
        "if"
      ],
      "startLine": 421,
      "endLine": 500
    },
    {
      "id": "src/frontend/parser.rs:491-565",
      "filePath": "src/frontend/parser.rs",
      "fileName": "parser.rs",
      "content": "            Some(Token::Identifier(name)) => Ok(Expression::Variable(name)),\n            Some(Token::LBracket) => {\n                let elements = self.parse_array_elements()?;\n                self.expect(Token::RBracket)?;\n                Ok(Expression::ArrayLiteral(elements))\n            }\n            Some(Token::LParen) => {\n                let expr = self.parse_expression()?;\n                self.expect(Token::RParen)?;\n                Ok(expr)\n            }\n            Some(Token::Map) => {\n                self.expect(Token::LParen)?;\n                let function = self.try_parse_identifier()?;\n                self.expect(Token::Comma)?;\n                let array = self.parse_expression()?;\n                self.expect(Token::RParen)?;\n                Ok(Expression::Map {\n                    function,\n                    array: Box::new(array),\n                })\n            }\n            _ => bail!(\"Unexpected token in expression\"),\n        }\n    }\n\n    fn parse_args(&mut self) -> Result<Vec<Expression>> {\n        let mut args = Vec::new();\n\n        if matches!(self.current(), Some(Token::RParen)) {\n            return Ok(args);\n        }\n\n        loop {\n            args.push(self.parse_expression()?);\n            if !matches!(self.current(), Some(Token::Comma)) {\n                break;\n            }\n            self.advance();\n        }\n\n        Ok(args)\n    }\n\n    fn parse_array_elements(&mut self) -> Result<Vec<Expression>> {\n        let mut elements = Vec::new();\n\n        if matches!(self.current(), Some(Token::RBracket)) {\n            return Ok(elements);\n        }\n\n        loop {\n            elements.push(self.parse_expression()?);\n            if !matches!(self.current(), Some(Token::Comma)) {\n                break;\n            }\n            self.advance();\n        }\n\n        Ok(elements)\n    }\n}\n\npub fn parse(source: &str) -> Result<Program> {\n    let tokens: Vec<Token> = Token::lexer(source)\n        .filter_map(|result| result.ok())\n        .collect();\n\n    let mut parser = Parser::new(tokens);\n    parser.parse_program()\n}\n\n\n\n",
      "type": "rust",
      "keywords": [
        "parser",
        "parse_args",
        "parse_array_elements",
        "parse",
        "lexer",
        "token",
        "expression",
        "function",
        "variable",
        "loop",
        "if"
      ],
      "startLine": 491,
      "endLine": 565
    },
    {
      "id": "src/frontend/typecheck.rs:1-80",
      "filePath": "src/frontend/typecheck.rs",
      "fileName": "typecheck.rs",
      "content": "use super::ast::*;\nuse anyhow::{bail, Result};\nuse std::collections::HashMap;\n\npub struct TypeChecker {\n    variables: HashMap<String, Type>,\n    functions: HashMap<String, (Vec<Type>, Type, Domain)>, // (param_types, return_type, domain)\n    current_domain: Domain, // Track current function's domain\n}\n\nimpl TypeChecker {\n    fn new() -> Self {\n        let mut checker = Self {\n            variables: HashMap::new(),\n            functions: HashMap::new(),\n            current_domain: Domain::Classical,\n        };\n\n        // Register built-in quantum functions\n        checker.register_builtin_functions();\n\n        checker\n    }\n\n    fn register_builtin_functions(&mut self) {\n        // I/O functions (Classical domain)\n        self.functions.insert(\n            \"print\".to_string(),\n            (vec![Type::Int], Type::Void, Domain::Classical),\n        );\n        self.functions.insert(\n            \"print_float\".to_string(),\n            (vec![Type::Float], Type::Void, Domain::Classical),\n        );\n        self.functions.insert(\n            \"print_array\".to_string(),\n            (vec![Type::Array(Box::new(Type::Float), None)], Type::Void, Domain::Classical),\n        );\n\n        // Quantum gates (single qubit)\n        self.functions.insert(\n            \"h\".to_string(),\n            (vec![Type::Int], Type::Int, Domain::Quantum),\n        );\n        self.functions.insert(\n            \"x\".to_string(),\n            (vec![Type::Int], Type::Int, Domain::Quantum),\n        );\n        self.functions.insert(\n            \"y\".to_string(),\n            (vec![Type::Int], Type::Int, Domain::Quantum),\n        );\n        self.functions.insert(\n            \"z\".to_string(),\n            (vec![Type::Int], Type::Int, Domain::Quantum),\n        );\n        self.functions.insert(\n            \"ry\".to_string(),\n            (vec![Type::Int, Type::Float], Type::Int, Domain::Quantum),\n        );\n        self.functions.insert(\n            \"rz\".to_string(),\n            (vec![Type::Int, Type::Float], Type::Int, Domain::Quantum),\n        );\n\n        // Quantum gates (two qubit)\n        self.functions.insert(\n            \"cx\".to_string(),\n            (vec![Type::Int, Type::Int], Type::Int, Domain::Quantum),\n        );\n        self.functions.insert(\n            \"cnot\".to_string(),\n            (vec![Type::Int, Type::Int], Type::Int, Domain::Quantum),\n        );\n\n        // Measurement\n        self.functions.insert(\n            \"measure\".to_string(),\n            (vec![Type::Int], Type::Int, Domain::Quantum),\n        );",
      "type": "rust",
      "keywords": [
        "typecheck",
        "new",
        "register_builtin_functions",
        "typechecker",
        "ast",
        "quantum",
        "type",
        "check",
        "function",
        "variable",
        "qubit",
        "gate",
        "measure"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/frontend/typecheck.rs:71-150",
      "filePath": "src/frontend/typecheck.rs",
      "fileName": "typecheck.rs",
      "content": "        self.functions.insert(\n            \"cnot\".to_string(),\n            (vec![Type::Int, Type::Int], Type::Int, Domain::Quantum),\n        );\n\n        // Measurement\n        self.functions.insert(\n            \"measure\".to_string(),\n            (vec![Type::Int], Type::Int, Domain::Quantum),\n        );\n    }\n\n    fn check_program(&mut self, program: &Program) -> Result<()> {\n        // First pass: collect function signatures with domains\n        for func in &program.functions {\n            let param_types = func.params.iter().map(|p| p.ty.clone()).collect();\n            self.functions.insert(\n                func.name.clone(),\n                (param_types, func.return_type.clone(), func.domain.clone()),\n            );\n        }\n\n        // Second pass: type check function bodies\n        for func in &program.functions {\n            self.check_function(func)?;\n        }\n\n        Ok(())\n    }\n\n    fn check_function(&mut self, func: &Function) -> Result<()> {\n        // Clear variables for new function scope\n        self.variables.clear();\n\n        // Set current domain\n        self.current_domain = func.domain.clone();\n\n        // Add parameters to scope\n        for param in &func.params {\n            self.variables.insert(param.name.clone(), param.ty.clone());\n        }\n\n        // Check statements\n        for stmt in &func.body {\n            self.check_statement(stmt)?;\n        }\n\n        Ok(())\n    }\n\n    fn check_statement(&mut self, stmt: &Statement) -> Result<()> {\n        match stmt {\n            Statement::Let { name, ty, value } => {\n                let value_type = self.infer_expression(value)?;\n                if let Some(declared_ty) = ty {\n                    if !self.types_compatible(declared_ty, &value_type) {\n                        bail!(\n                            \"Type mismatch: expected {}, got {}\",\n                            declared_ty,\n                            value_type\n                        );\n                    }\n                    self.variables.insert(name.clone(), declared_ty.clone());\n                } else {\n                    self.variables.insert(name.clone(), value_type);\n                }\n                Ok(())\n            }\n            Statement::Assign {\n                target,\n                index,\n                value,\n            } => {\n                let var_type = self\n                    .variables\n                    .get(target)\n                    .ok_or_else(|| anyhow::anyhow!(\"Undefined variable: {}\", target))?\n                    .clone();\n\n                let value_type = self.infer_expression(value)?;",
      "type": "rust",
      "keywords": [
        "typecheck",
        "check_program",
        "check_function",
        "check_statement",
        "quantum",
        "type",
        "check",
        "ir",
        "expression",
        "statement",
        "function",
        "variable",
        "if",
        "measure"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/frontend/typecheck.rs:141-220",
      "filePath": "src/frontend/typecheck.rs",
      "fileName": "typecheck.rs",
      "content": "                index,\n                value,\n            } => {\n                let var_type = self\n                    .variables\n                    .get(target)\n                    .ok_or_else(|| anyhow::anyhow!(\"Undefined variable: {}\", target))?\n                    .clone();\n\n                let value_type = self.infer_expression(value)?;\n\n                if let Some(idx_expr) = index {\n                    // Array assignment\n                    let idx_type = self.infer_expression(idx_expr)?;\n                    if idx_type != Type::Int {\n                        bail!(\"Array index must be int, got {}\", idx_type);\n                    }\n                    if let Type::Array(elem_type, _) = var_type {\n                        if !self.types_compatible(&elem_type, &value_type) {\n                            bail!(\n                                \"Type mismatch in array assignment: expected {}, got {}\",\n                                elem_type,\n                                value_type\n                            );\n                        }\n                    } else {\n                        bail!(\"Cannot index non-array type {}\", var_type);\n                    }\n                } else {\n                    if !self.types_compatible(&var_type, &value_type) {\n                        bail!(\n                            \"Type mismatch in assignment: expected {}, got {}\",\n                            var_type,\n                            value_type\n                        );\n                    }\n                }\n                Ok(())\n            }\n            Statement::Return(expr) => {\n                self.infer_expression(expr)?;\n                Ok(())\n            }\n            Statement::Expression(expr) => {\n                self.infer_expression(expr)?;\n                Ok(())\n            }\n            Statement::For {\n                var,\n                start,\n                end,\n                body,\n            } => {\n                let start_type = self.infer_expression(start)?;\n                let end_type = self.infer_expression(end)?;\n                if start_type != Type::Int || end_type != Type::Int {\n                    bail!(\"For loop bounds must be int\");\n                }\n                self.variables.insert(var.clone(), Type::Int);\n                for stmt in body {\n                    self.check_statement(stmt)?;\n                }\n                Ok(())\n            }\n            Statement::If {\n                condition,\n                then_body,\n                else_body,\n            } => {\n                let cond_type = self.infer_expression(condition)?;\n                if cond_type != Type::Bool {\n                    bail!(\"If condition must be bool, got {}\", cond_type);\n                }\n                for stmt in then_body {\n                    self.check_statement(stmt)?;\n                }\n                if let Some(else_stmts) = else_body {\n                    for stmt in else_stmts {\n                        self.check_statement(stmt)?;\n                    }",
      "type": "rust",
      "keywords": [
        "typecheck",
        "type",
        "check",
        "expression",
        "statement",
        "variable",
        "loop",
        "if"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "src/frontend/typecheck.rs:211-290",
      "filePath": "src/frontend/typecheck.rs",
      "fileName": "typecheck.rs",
      "content": "                if cond_type != Type::Bool {\n                    bail!(\"If condition must be bool, got {}\", cond_type);\n                }\n                for stmt in then_body {\n                    self.check_statement(stmt)?;\n                }\n                if let Some(else_stmts) = else_body {\n                    for stmt in else_stmts {\n                        self.check_statement(stmt)?;\n                    }\n                }\n                Ok(())\n            }\n        }\n    }\n\n    fn infer_expression(&self, expr: &Expression) -> Result<Type> {\n        match expr {\n            Expression::IntLiteral(_) => Ok(Type::Int),\n            Expression::FloatLiteral(_) => Ok(Type::Float),\n            Expression::BoolLiteral(_) => Ok(Type::Bool),\n            Expression::Variable(name) => self\n                .variables\n                .get(name)\n                .cloned()\n                .ok_or_else(|| anyhow::anyhow!(\"Undefined variable: {}\", name)),\n            Expression::ArrayLiteral(elements) => {\n                if elements.is_empty() {\n                    bail!(\"Cannot infer type of empty array\");\n                }\n                let first_type = self.infer_expression(&elements[0])?;\n                for elem in &elements[1..] {\n                    let elem_type = self.infer_expression(elem)?;\n                    if !self.types_compatible(&first_type, &elem_type) {\n                        bail!(\"Array elements must have same type\");\n                    }\n                }\n                Ok(Type::Array(Box::new(first_type), Some(elements.len())))\n            }\n            Expression::Index { array, index } => {\n                let array_type = self.infer_expression(array)?;\n                let index_type = self.infer_expression(index)?;\n                if index_type != Type::Int {\n                    bail!(\"Array index must be int\");\n                }\n                match array_type {\n                    Type::Array(elem_type, _) => Ok(*elem_type),\n                    _ => bail!(\"Cannot index non-array type\"),\n                }\n            }\n            Expression::Binary { op, left, right } => {\n                let left_type = self.infer_expression(left)?;\n                let right_type = self.infer_expression(right)?;\n\n                use BinaryOp::*;\n                match op {\n                    Add | Sub | Mul | Div | Mod => {\n                        if left_type == Type::Int && right_type == Type::Int {\n                            Ok(Type::Int)\n                        } else if left_type == Type::Float && right_type == Type::Float {\n                            Ok(Type::Float)\n                        } else {\n                            bail!(\"Type mismatch in arithmetic operation\");\n                        }\n                    }\n                    Eq | Ne | Lt | Le | Gt | Ge => {\n                        if !self.types_compatible(&left_type, &right_type) {\n                            bail!(\"Type mismatch in comparison\");\n                        }\n                        Ok(Type::Bool)\n                    }\n                    And | Or => {\n                        if left_type != Type::Bool || right_type != Type::Bool {\n                            bail!(\"Logical operators require bool operands\");\n                        }\n                        Ok(Type::Bool)\n                    }\n                }\n            }\n            Expression::Unary { op, operand } => {",
      "type": "rust",
      "keywords": [
        "typecheck",
        "infer_expression",
        "type",
        "check",
        "ir",
        "expression",
        "statement",
        "variable",
        "if"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "src/frontend/typecheck.rs:281-360",
      "filePath": "src/frontend/typecheck.rs",
      "fileName": "typecheck.rs",
      "content": "                    }\n                    And | Or => {\n                        if left_type != Type::Bool || right_type != Type::Bool {\n                            bail!(\"Logical operators require bool operands\");\n                        }\n                        Ok(Type::Bool)\n                    }\n                }\n            }\n            Expression::Unary { op, operand } => {\n                let operand_type = self.infer_expression(operand)?;\n                match op {\n                    UnaryOp::Neg => {\n                        if operand_type == Type::Int || operand_type == Type::Float {\n                            Ok(operand_type)\n                        } else {\n                            bail!(\"Negation requires numeric type\");\n                        }\n                    }\n                    UnaryOp::Not => {\n                        if operand_type == Type::Bool {\n                            Ok(Type::Bool)\n                        } else {\n                            bail!(\"Logical not requires bool\");\n                        }\n                    }\n                }\n            }\n            Expression::Call { function, args } => {\n                let (param_types, return_type, target_domain) = self\n                    .functions\n                    .get(function)\n                    .ok_or_else(|| anyhow::anyhow!(\"Undefined function: {}\", function))?\n                    .clone();\n\n                // Check for cross-domain calls (hybrid feature)\n                if self.current_domain != target_domain {\n                    // Cross-domain call detected\n                    // For now, we allow it (automatic conversion will be inserted later)\n                    // In the future, we can add warnings or restrictions here\n                    eprintln!(\n                        \"INFO: Cross-domain call from {:?} to {:?} function '{}'\",\n                        self.current_domain, target_domain, function\n                    );\n                }\n\n                if args.len() != param_types.len() {\n                    bail!(\n                        \"Function {} expects {} arguments, got {}\",\n                        function,\n                        param_types.len(),\n                        args.len()\n                    );\n                }\n\n                for (arg, param_type) in args.iter().zip(param_types.iter()) {\n                    let arg_type = self.infer_expression(arg)?;\n                    if !self.types_compatible(param_type, &arg_type) {\n                        bail!(\"Argument type mismatch: expected {}, got {}\", param_type, arg_type);\n                    }\n                }\n\n                Ok(return_type)\n            }\n            Expression::Map { function, array } => {\n                let array_type = self.infer_expression(array)?;\n                let (param_types, return_type, _domain) = self\n                    .functions\n                    .get(function)\n                    .ok_or_else(|| anyhow::anyhow!(\"Undefined function: {}\", function))?\n                    .clone();\n\n                if param_types.len() != 1 {\n                    bail!(\"Map function must take exactly one argument\");\n                }\n\n                match array_type {\n                    Type::Array(elem_type, size) => {\n                        if !self.types_compatible(&param_types[0], &elem_type) {\n                            bail!(\"Map function parameter type mismatch\");",
      "type": "rust",
      "keywords": [
        "typecheck",
        "type",
        "check",
        "ir",
        "expression",
        "function",
        "if",
        "hybrid"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "src/frontend/typecheck.rs:351-388",
      "filePath": "src/frontend/typecheck.rs",
      "fileName": "typecheck.rs",
      "content": "                    .clone();\n\n                if param_types.len() != 1 {\n                    bail!(\"Map function must take exactly one argument\");\n                }\n\n                match array_type {\n                    Type::Array(elem_type, size) => {\n                        if !self.types_compatible(&param_types[0], &elem_type) {\n                            bail!(\"Map function parameter type mismatch\");\n                        }\n                        Ok(Type::Array(Box::new(return_type), size))\n                    }\n                    _ => bail!(\"Map requires array argument\"),\n                }\n            }\n        }\n    }\n\n    fn types_compatible(&self, expected: &Type, actual: &Type) -> bool {\n        match (expected, actual) {\n            (Type::Array(e1, _), Type::Array(e2, _)) => self.types_compatible(e1, e2),\n            (Type::Tensor(e1), Type::Tensor(e2)) => self.types_compatible(e1, e2),\n            // Allow implicit conversion: Array â†’ Tensor (for hybrid workflows)\n            (Type::Tensor(e1), Type::Array(e2, _)) => self.types_compatible(e1, e2),\n            (Type::Array(e1, _), Type::Tensor(e2)) => self.types_compatible(e1, e2),\n            _ => expected == actual,\n        }\n    }\n}\n\npub fn typecheck(program: &Program) -> Result<()> {\n    let mut checker = TypeChecker::new();\n    checker.check_program(program)\n}\n\n\n",
      "type": "rust",
      "keywords": [
        "typecheck",
        "types_compatible",
        "type",
        "check",
        "ir",
        "function",
        "if",
        "hybrid"
      ],
      "startLine": 351,
      "endLine": 388
    },
    {
      "id": "src/main.rs:1-13",
      "filePath": "src/main.rs",
      "fileName": "main.rs",
      "content": "mod frontend;\nmod middle;\nmod backend;\nmod cli;\n\nuse anyhow::Result;\nuse clap::Parser;\n\nfn main() -> Result<()> {\n    let args = cli::Args::parse();\n    cli::run(args)\n}\n",
      "type": "rust",
      "keywords": [
        "main",
        "parser",
        "backend",
        "frontend",
        "middle"
      ],
      "startLine": 1,
      "endLine": 13
    },
    {
      "id": "src/middle/dump.rs:1-80",
      "filePath": "src/middle/dump.rs",
      "fileName": "dump.rs",
      "content": "use super::ir::*;\n\npub fn dump_ir(module: &Module) -> String {\n    let mut output = String::new();\n\n    for func in &module.functions {\n        output.push_str(&dump_function(func));\n        output.push('\\n');\n    }\n\n    output\n}\n\nfn dump_function(func: &IRFunction) -> String {\n    let mut output = String::new();\n\n    // Domain annotation (if not Classical)\n    match func.domain {\n        crate::frontend::ast::Domain::Gpu => output.push_str(\"@gpu\\n\"),\n        crate::frontend::ast::Domain::Quantum => output.push_str(\"@quantum\\n\"),\n        crate::frontend::ast::Domain::Classical => {},\n    }\n\n    // Function signature\n    output.push_str(&format!(\"fn {}(\", func.name));\n    for (i, (name, ty)) in func.params.iter().enumerate() {\n        if i > 0 {\n            output.push_str(\", \");\n        }\n        output.push_str(&format!(\"{}: {}\", name, ty));\n    }\n    output.push_str(&format!(\") -> {} {{\\n\", func.return_type));\n\n    // Blocks\n    for block in &func.blocks {\n        output.push_str(&dump_block(block));\n    }\n\n    output.push_str(\"}\\n\");\n    output\n}\n\nfn dump_block(block: &BasicBlock) -> String {\n    let mut output = String::new();\n\n    output.push_str(&format!(\"  {}:\\n\", block.label));\n\n    for inst in &block.instructions {\n        output.push_str(&format!(\"    {}\\n\", dump_instruction(inst)));\n    }\n\n    output.push_str(&format!(\"    {}\\n\", dump_terminator(&block.terminator)));\n\n    output\n}\n\nfn dump_instruction(inst: &Instruction) -> String {\n    match inst {\n        Instruction::Assign { dest, value } => {\n            format!(\"{} = {}\", dest, dump_value(value))\n        }\n        Instruction::BinaryOp {\n            dest,\n            op,\n            left,\n            right,\n        } => {\n            format!(\n                \"{} = {} {} {}\",\n                dest,\n                dump_binop(*op),\n                dump_value(left),\n                dump_value(right)\n            )\n        }\n        Instruction::UnaryOp { dest, op, operand } => {\n            format!(\"{} = {} {}\", dest, dump_unop(*op), dump_value(operand))\n        }\n        Instruction::Load { dest, array, index } => {\n            format!(\"{} = load {}[{}]\", dest, array, dump_value(index))",
      "type": "rust",
      "keywords": [
        "dump",
        "dump_ir",
        "dump_function",
        "dump_block",
        "dump_instruction",
        "ast",
        "quantum",
        "gpu",
        "type",
        "ir",
        "frontend",
        "function",
        "if"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/middle/dump.rs:71-150",
      "filePath": "src/middle/dump.rs",
      "fileName": "dump.rs",
      "content": "                dump_binop(*op),\n                dump_value(left),\n                dump_value(right)\n            )\n        }\n        Instruction::UnaryOp { dest, op, operand } => {\n            format!(\"{} = {} {}\", dest, dump_unop(*op), dump_value(operand))\n        }\n        Instruction::Load { dest, array, index } => {\n            format!(\"{} = load {}[{}]\", dest, array, dump_value(index))\n        }\n        Instruction::Store {\n            array,\n            index,\n            value,\n        } => {\n            format!(\n                \"store {}[{}] = {}\",\n                array,\n                dump_value(index),\n                dump_value(value)\n            )\n        }\n        Instruction::Call {\n            dest,\n            function,\n            args,\n        } => {\n            let args_str = args\n                .iter()\n                .map(dump_value)\n                .collect::<Vec<_>>()\n                .join(\", \");\n            if let Some(d) = dest {\n                format!(\"{} = call {}({})\", d, function, args_str)\n            } else {\n                format!(\"call {}({})\", function, args_str)\n            }\n        }\n        Instruction::Phi { dest, incoming } => {\n            let incoming_str = incoming\n                .iter()\n                .map(|(val, label)| format!(\"[{}, {}]\", dump_value(val), label))\n                .collect::<Vec<_>>()\n                .join(\", \");\n            format!(\"{} = phi {}\", dest, incoming_str)\n        }\n        Instruction::DomainConversion {\n            dest,\n            source,\n            from_domain,\n            to_domain,\n            encoding,\n        } => {\n            format!(\n                \"{} = convert_{:?}_to_{:?}({}, {:?})\",\n                dest,\n                from_domain,\n                to_domain,\n                dump_value(source),\n                encoding\n            )\n        }\n    }\n}\n\nfn dump_terminator(term: &Terminator) -> String {\n    match term {\n        Terminator::Return(val) => format!(\"return {}\", dump_value(val)),\n        Terminator::ReturnVoid => \"return void\".to_string(),\n        Terminator::Branch {\n            condition,\n            true_label,\n            false_label,\n        } => format!(\n            \"br {}, {}, {}\",\n            dump_value(condition),\n            true_label,\n            false_label\n        ),",
      "type": "rust",
      "keywords": [
        "dump",
        "dump_terminator",
        "function",
        "if"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/middle/dump.rs:141-197",
      "filePath": "src/middle/dump.rs",
      "fileName": "dump.rs",
      "content": "        Terminator::Branch {\n            condition,\n            true_label,\n            false_label,\n        } => format!(\n            \"br {}, {}, {}\",\n            dump_value(condition),\n            true_label,\n            false_label\n        ),\n        Terminator::Jump(label) => format!(\"jump {}\", label),\n    }\n}\n\nfn dump_value(val: &Value) -> String {\n    match val {\n        Value::Var(v) => format!(\"{}\", v),\n        Value::Int(n) => format!(\"{}\", n),\n        Value::Float(f) => format!(\"{}\", f),\n        Value::Bool(b) => format!(\"{}\", b),\n        Value::Array(elements) => {\n            let elems_str = elements\n                .iter()\n                .map(dump_value)\n                .collect::<Vec<_>>()\n                .join(\", \");\n            format!(\"[{}]\", elems_str)\n        }\n    }\n}\n\nfn dump_binop(op: BinOp) -> &'static str {\n    match op {\n        BinOp::Add => \"add\",\n        BinOp::Sub => \"sub\",\n        BinOp::Mul => \"mul\",\n        BinOp::Div => \"div\",\n        BinOp::Mod => \"mod\",\n        BinOp::Eq => \"eq\",\n        BinOp::Ne => \"ne\",\n        BinOp::Lt => \"lt\",\n        BinOp::Le => \"le\",\n        BinOp::Gt => \"gt\",\n        BinOp::Ge => \"ge\",\n        BinOp::And => \"and\",\n        BinOp::Or => \"or\",\n    }\n}\n\nfn dump_unop(op: UnOp) -> &'static str {\n    match op {\n        UnOp::Neg => \"neg\",\n        UnOp::Not => \"not\",\n    }\n}\n\n",
      "type": "rust",
      "keywords": [
        "dump",
        "dump_value",
        "dump_binop",
        "dump_unop"
      ],
      "startLine": 141,
      "endLine": 197
    },
    {
      "id": "src/middle/ir.rs:1-80",
      "filePath": "src/middle/ir.rs",
      "fileName": "ir.rs",
      "content": "/// SSA-based Intermediate Representation\n///\n/// Static Single Assignment (SSA): Each variable is assigned exactly once\n/// Three-Address Code: Instructions have at most three operands\n/// Basic Blocks: Sequences of instructions with single entry and exit\n/// Control Flow Graph (CFG): Graph of basic blocks connected by terminators\n\nuse serde::{Deserialize, Serialize};\nuse crate::frontend::ast::Domain;\n\n// IR Module: Collection of functions (compilation unit)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Module {\n    pub functions: Vec<IRFunction>,\n}\n\n// IR Function: SSA form with basic blocks\n// Control Flow Graph: Represented as vector of basic blocks\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IRFunction {\n    pub name: String,\n    pub params: Vec<(String, IRType)>,\n    pub return_type: IRType,\n    pub blocks: Vec<BasicBlock>,           // CFG nodes\n    pub next_var_id: usize,                // SSA variable counter\n    pub domain: Domain,                    // Execution domain (GPU/Quantum)\n}\n\n// Basic Block: Sequence of instructions with single entry and exit\n// Entry: Only first instruction can be reached from outside\n// Exit: Only terminator transfers control outside\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BasicBlock {\n    pub label: String,                     // Block identifier\n    pub instructions: Vec<Instruction>,    // Straight-line code\n    pub terminator: Terminator,            // Control flow transfer\n}\n\n// Three-Address Code Instructions\n// Format: dest = operand1 op operand2\n// SSA Property: Each dest is assigned exactly once\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum Instruction {\n    // dest = value (simple assignment)\n    Assign {\n        dest: SSAVar,                      // SSA variable (assigned once)\n        value: Value,\n    },\n    // dest = left op right (binary operation)\n    // Three-address code: result, operand1, operand2\n    BinaryOp {\n        dest: SSAVar,                      // SSA variable\n        op: BinOp,\n        left: Value,\n        right: Value,\n    },\n    UnaryOp {\n        dest: SSAVar,\n        op: UnOp,\n        operand: Value,\n    },\n    Load {\n        dest: SSAVar,\n        array: SSAVar,\n        index: Value,\n    },\n    Store {\n        array: SSAVar,\n        index: Value,\n        value: Value,\n    },\n    Call {\n        dest: Option<SSAVar>,\n        function: String,\n        args: Vec<Value>,\n    },\n    Phi {\n        dest: SSAVar,\n        incoming: Vec<(Value, String)>, // (value, block_label)\n    },",
      "type": "rust",
      "keywords": [
        "ir",
        "module",
        "irfunction",
        "basicblock",
        "instruction",
        "ast",
        "quantum",
        "gpu",
        "type",
        "frontend",
        "function",
        "variable",
        "if"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/middle/ir.rs:71-150",
      "filePath": "src/middle/ir.rs",
      "fileName": "ir.rs",
      "content": "    },\n    Call {\n        dest: Option<SSAVar>,\n        function: String,\n        args: Vec<Value>,\n    },\n    Phi {\n        dest: SSAVar,\n        incoming: Vec<(Value, String)>, // (value, block_label)\n    },\n    /// Domain conversion: GPU â†” Quantum\n    DomainConversion {\n        dest: SSAVar,\n        source: Value,\n        from_domain: Domain,\n        to_domain: Domain,\n        encoding: ConversionEncoding,\n    },\n}\n\n/// Encoding method for domain conversions\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ConversionEncoding {\n    AngleEncoding,      // GPU â†’ Quantum: ry(qubit, angle)\n    AmplitudeEncoding,  // GPU â†’ Quantum: initialize(statevector)\n    MeasurementExtract, // Quantum â†’ GPU: measure + extract counts\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum Terminator {\n    Return(Value),\n    ReturnVoid,\n    Branch {\n        condition: Value,\n        true_label: String,\n        false_label: String,\n    },\n    Jump(String),\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct SSAVar {\n    pub id: usize,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum Value {\n    Var(SSAVar),\n    Int(i64),\n    Float(f64),\n    Bool(bool),\n    Array(Vec<Value>),\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum BinOp {\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n    Eq,\n    Ne,\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    And,\n    Or,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum UnOp {\n    Neg,\n    Not,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum IRType {\n    Int,",
      "type": "rust",
      "keywords": [
        "ir",
        "ssavar",
        "conversionencoding",
        "terminator",
        "value",
        "binop",
        "unop",
        "irtype",
        "quantum",
        "gpu",
        "type",
        "function",
        "qubit",
        "measure"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/middle/ir.rs:141-184",
      "filePath": "src/middle/ir.rs",
      "fileName": "ir.rs",
      "content": "\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum UnOp {\n    Neg,\n    Not,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum IRType {\n    Int,\n    Float,\n    Bool,\n    Array(Box<IRType>, Option<usize>),\n    Qubit,\n    Void,\n}\n\nimpl SSAVar {\n    pub fn new(id: usize) -> Self {\n        Self { id }\n    }\n}\n\nimpl std::fmt::Display for SSAVar {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"%{}\", self.id)\n    }\n}\n\nimpl std::fmt::Display for IRType {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            IRType::Int => write!(f, \"int\"),\n            IRType::Float => write!(f, \"float\"),\n            IRType::Bool => write!(f, \"bool\"),\n            IRType::Array(elem, Some(size)) => write!(f, \"[{}; {}]\", elem, size),\n            IRType::Array(elem, None) => write!(f, \"[{}]\", elem),\n            IRType::Qubit => write!(f, \"qubit\"),\n            IRType::Void => write!(f, \"void\"),\n        }\n    }\n}\n\n",
      "type": "rust",
      "keywords": [
        "ir",
        "new",
        "fmt",
        "unop",
        "irtype",
        "ssavar",
        "std",
        "type",
        "qubit"
      ],
      "startLine": 141,
      "endLine": 184
    },
    {
      "id": "src/middle/lower.rs:1-80",
      "filePath": "src/middle/lower.rs",
      "fileName": "lower.rs",
      "content": "use super::ir::*;\nuse crate::frontend::ast;\nuse anyhow::Result;\nuse std::collections::HashMap;\n\npub struct Lowerer {\n    current_block: Option<BasicBlock>,\n    var_counter: usize,\n    var_map: HashMap<String, SSAVar>,\n    function_domains: HashMap<String, ast::Domain>, // Track function domains\n    current_domain: ast::Domain, // Current function's domain\n}\n\nimpl Lowerer {\n    fn new() -> Self {\n        Self {\n            current_block: None,\n            var_counter: 0,\n            var_map: HashMap::new(),\n            function_domains: HashMap::new(),\n            current_domain: ast::Domain::Classical,\n        }\n    }\n\n    fn fresh_var(&mut self) -> SSAVar {\n        let id = self.var_counter;\n        self.var_counter += 1;\n        SSAVar::new(id)\n    }\n\n    fn lower_module(&mut self, program: &ast::Program) -> Result<Module> {\n        let mut functions = Vec::new();\n\n        // First pass: collect function domains\n        for func in &program.functions {\n            self.function_domains.insert(func.name.clone(), func.domain.clone());\n        }\n\n        // Second pass: lower functions\n        for func in &program.functions {\n            functions.push(self.lower_function(func)?);\n        }\n\n        Ok(Module { functions })\n    }\n\n    fn lower_function(&mut self, func: &ast::Function) -> Result<IRFunction> {\n        self.var_counter = 0;\n        self.var_map.clear();\n        self.current_domain = func.domain.clone(); // Set current domain\n\n        let params: Vec<(String, IRType)> = func\n            .params\n            .iter()\n            .map(|p| (p.name.clone(), self.convert_type(&p.ty)))\n            .collect();\n\n        // Add parameters to var_map\n        for (name, _) in &params {\n            let var = self.fresh_var();\n            self.var_map.insert(name.clone(), var);\n        }\n\n        let return_type = self.convert_type(&func.return_type);\n\n        // Create entry block\n        self.current_block = Some(BasicBlock {\n            label: \"entry\".to_string(),\n            instructions: Vec::new(),\n            terminator: Terminator::ReturnVoid,\n        });\n\n        let mut blocks = Vec::new();\n\n        // Lower statements\n        for stmt in &func.body {\n            self.lower_statement(stmt)?;\n        }\n\n        // Finalize current block",
      "type": "rust",
      "keywords": [
        "lower",
        "new",
        "fresh_var",
        "lower_module",
        "lower_function",
        "lowerer",
        "ast",
        "type",
        "ir",
        "frontend",
        "statement",
        "function"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/middle/lower.rs:71-150",
      "filePath": "src/middle/lower.rs",
      "fileName": "lower.rs",
      "content": "        });\n\n        let mut blocks = Vec::new();\n\n        // Lower statements\n        for stmt in &func.body {\n            self.lower_statement(stmt)?;\n        }\n\n        // Finalize current block\n        if let Some(block) = self.current_block.take() {\n            blocks.push(block);\n        }\n\n        Ok(IRFunction {\n            name: func.name.clone(),\n            params,\n            return_type,\n            blocks,\n            next_var_id: self.var_counter,\n            domain: func.domain.clone(), // Pass domain to IR\n        })\n    }\n\n    fn lower_statement(&mut self, stmt: &ast::Statement) -> Result<()> {\n        match stmt {\n            ast::Statement::Let { name, value, .. } => {\n                let val = self.lower_expression(value)?;\n                let dest = self.fresh_var();\n                self.var_map.insert(name.clone(), dest);\n\n                self.emit_instruction(Instruction::Assign {\n                    dest,\n                    value: val,\n                });\n                Ok(())\n            }\n            ast::Statement::Assign {\n                target,\n                index,\n                value,\n            } => {\n                let val = self.lower_expression(value)?;\n                let var = *self\n                    .var_map\n                    .get(target)\n                    .ok_or_else(|| anyhow::anyhow!(\"Undefined variable: {}\", target))?;\n\n                if let Some(idx_expr) = index {\n                    let idx = self.lower_expression(idx_expr)?;\n                    self.emit_instruction(Instruction::Store {\n                        array: var,\n                        index: idx,\n                        value: val,\n                    });\n                } else {\n                    self.emit_instruction(Instruction::Assign { dest: var, value: val });\n                }\n                Ok(())\n            }\n            ast::Statement::Return(expr) => {\n                let val = self.lower_expression(expr)?;\n                if let Some(block) = &mut self.current_block {\n                    block.terminator = Terminator::Return(val);\n                }\n                Ok(())\n            }\n            ast::Statement::Expression(expr) => {\n                self.lower_expression(expr)?;\n                Ok(())\n            }\n            ast::Statement::For {\n                var,\n                start,\n                end,\n                body,\n            } => {\n                // Loop unrolling: evaluate start and end as constants\n                let start_val = self.lower_expression(start)?;\n                let end_val = self.lower_expression(end)?;",
      "type": "rust",
      "keywords": [
        "lower",
        "lower_statement",
        "ast",
        "type",
        "ir",
        "expression",
        "statement",
        "function",
        "variable",
        "loop",
        "if"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/middle/lower.rs:141-220",
      "filePath": "src/middle/lower.rs",
      "fileName": "lower.rs",
      "content": "            }\n            ast::Statement::For {\n                var,\n                start,\n                end,\n                body,\n            } => {\n                // Loop unrolling: evaluate start and end as constants\n                let start_val = self.lower_expression(start)?;\n                let end_val = self.lower_expression(end)?;\n\n                // Extract constant values for unrolling\n                if let (Value::Int(start_int), Value::Int(end_int)) = (&start_val, &end_val) {\n                    // Unroll loop iterations\n                    for i in *start_int..*end_int {\n                        // Create new loop variable for this iteration\n                        let loop_var = self.fresh_var();\n                        self.var_map.insert(var.clone(), loop_var);\n                        self.emit_instruction(Instruction::Assign {\n                            dest: loop_var,\n                            value: Value::Int(i),\n                        });\n\n                        // Lower body for this iteration\n                        for stmt in body {\n                            self.lower_statement(stmt)?;\n                        }\n                    }\n                } else {\n                    // Fallback: single iteration with start value\n                    let loop_var = self.fresh_var();\n                    self.var_map.insert(var.clone(), loop_var);\n                    self.emit_instruction(Instruction::Assign {\n                        dest: loop_var,\n                        value: start_val,\n                    });\n\n                    for stmt in body {\n                        self.lower_statement(stmt)?;\n                    }\n                }\n\n                Ok(())\n            }\n            ast::Statement::If {\n                condition,\n                then_body,\n                else_body,\n            } => {\n                let _cond = self.lower_expression(condition)?;\n\n                // For now, simplified (not creating separate blocks)\n                for stmt in then_body {\n                    self.lower_statement(stmt)?;\n                }\n\n                if let Some(else_stmts) = else_body {\n                    for stmt in else_stmts {\n                        self.lower_statement(stmt)?;\n                    }\n                }\n\n                Ok(())\n            }\n        }\n    }\n\n    fn lower_expression(&mut self, expr: &ast::Expression) -> Result<Value> {\n        match expr {\n            ast::Expression::IntLiteral(n) => Ok(Value::Int(*n)),\n            ast::Expression::FloatLiteral(f) => Ok(Value::Float(*f)),\n            ast::Expression::BoolLiteral(b) => Ok(Value::Bool(*b)),\n            ast::Expression::Variable(name) => {\n                let var = *self\n                    .var_map\n                    .get(name)\n                    .ok_or_else(|| anyhow::anyhow!(\"Undefined variable: {}\", name))?;\n                Ok(Value::Var(var))\n            }\n            ast::Expression::ArrayLiteral(elements) => {",
      "type": "rust",
      "keywords": [
        "lower",
        "lower_expression",
        "ast",
        "expression",
        "statement",
        "variable",
        "loop",
        "if"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "src/middle/lower.rs:211-290",
      "filePath": "src/middle/lower.rs",
      "fileName": "lower.rs",
      "content": "            ast::Expression::FloatLiteral(f) => Ok(Value::Float(*f)),\n            ast::Expression::BoolLiteral(b) => Ok(Value::Bool(*b)),\n            ast::Expression::Variable(name) => {\n                let var = *self\n                    .var_map\n                    .get(name)\n                    .ok_or_else(|| anyhow::anyhow!(\"Undefined variable: {}\", name))?;\n                Ok(Value::Var(var))\n            }\n            ast::Expression::ArrayLiteral(elements) => {\n                let values: Result<Vec<Value>> =\n                    elements.iter().map(|e| self.lower_expression(e)).collect();\n                Ok(Value::Array(values?))\n            }\n            ast::Expression::Index { array, index } => {\n                let arr_val = self.lower_expression(array)?;\n                let idx_val = self.lower_expression(index)?;\n\n                // Extract the SSAVar from array\n                if let Value::Var(arr_var) = arr_val {\n                    let dest = self.fresh_var();\n                    self.emit_instruction(Instruction::Load {\n                        dest,\n                        array: arr_var,\n                        index: idx_val,\n                    });\n                    Ok(Value::Var(dest))\n                } else {\n                    anyhow::bail!(\"Array indexing requires variable\")\n                }\n            }\n            ast::Expression::Binary { op, left, right } => {\n                let left_val = self.lower_expression(left)?;\n                let right_val = self.lower_expression(right)?;\n                let dest = self.fresh_var();\n\n                let ir_op = self.convert_binop(*op);\n                self.emit_instruction(Instruction::BinaryOp {\n                    dest,\n                    op: ir_op,\n                    left: left_val,\n                    right: right_val,\n                });\n\n                Ok(Value::Var(dest))\n            }\n            ast::Expression::Unary { op, operand } => {\n                let operand_val = self.lower_expression(operand)?;\n                let dest = self.fresh_var();\n\n                let ir_op = self.convert_unop(*op);\n                self.emit_instruction(Instruction::UnaryOp {\n                    dest,\n                    op: ir_op,\n                    operand: operand_val,\n                });\n\n                Ok(Value::Var(dest))\n            }\n            ast::Expression::Call { function, args } => {\n                let arg_vals: Result<Vec<Value>> =\n                    args.iter().map(|a| self.lower_expression(a)).collect();\n                let arg_vals = arg_vals?;\n\n                // Built-in functions - don't convert\n                let builtin_quantum_fns = [\n                    \"h\", \"x\", \"y\", \"z\", \"rx\", \"ry\", \"rz\",\n                    \"cx\", \"cnot\", \"cz\", \"measure\"\n                ];\n                let builtin_io_fns = [\"print\", \"print_float\", \"print_array\"];\n                let is_builtin = builtin_quantum_fns.contains(&function.as_str())\n                    || builtin_io_fns.contains(&function.as_str());\n\n                // Check if this is a cross-domain call\n                let target_domain = self.function_domains.get(function)\n                    .cloned()\n                    .unwrap_or(ast::Domain::Classical);\n\n                // If cross-domain (and not builtin), convert arguments\n                let converted_args = if !is_builtin && self.current_domain != target_domain {",
      "type": "rust",
      "keywords": [
        "lower",
        "ast",
        "quantum",
        "check",
        "ir",
        "expression",
        "function",
        "variable",
        "if",
        "measure"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "src/middle/lower.rs:281-360",
      "filePath": "src/middle/lower.rs",
      "fileName": "lower.rs",
      "content": "                let is_builtin = builtin_quantum_fns.contains(&function.as_str())\n                    || builtin_io_fns.contains(&function.as_str());\n\n                // Check if this is a cross-domain call\n                let target_domain = self.function_domains.get(function)\n                    .cloned()\n                    .unwrap_or(ast::Domain::Classical);\n\n                // If cross-domain (and not builtin), convert arguments\n                let converted_args = if !is_builtin && self.current_domain != target_domain {\n                    eprintln!(\n                        \"INFO: Inserting conversion for {:?} â†’ {:?} call to '{}'\",\n                        self.current_domain, target_domain, function\n                    );\n\n                    // Convert each argument\n                    arg_vals.iter().map(|arg| {\n                        let conv_dest = self.fresh_var();\n                        let encoding = match (&self.current_domain, &target_domain) {\n                            (ast::Domain::Gpu, ast::Domain::Quantum) |\n                            (ast::Domain::Classical, ast::Domain::Quantum) => {\n                                ConversionEncoding::AngleEncoding\n                            }\n                            (ast::Domain::Quantum, ast::Domain::Gpu) |\n                            (ast::Domain::Quantum, ast::Domain::Classical) => {\n                                ConversionEncoding::MeasurementExtract\n                            }\n                            _ => ConversionEncoding::AngleEncoding, // Default\n                        };\n\n                        self.emit_instruction(Instruction::DomainConversion {\n                            dest: conv_dest,\n                            source: arg.clone(),\n                            from_domain: self.current_domain.clone(),\n                            to_domain: target_domain.clone(),\n                            encoding,\n                        });\n\n                        Value::Var(conv_dest)\n                    }).collect()\n                } else {\n                    arg_vals\n                };\n\n                let dest = self.fresh_var();\n                self.emit_instruction(Instruction::Call {\n                    dest: Some(dest),\n                    function: function.clone(),\n                    args: converted_args,\n                });\n\n                Ok(Value::Var(dest))\n            }\n            ast::Expression::Map { function, array } => {\n                // Map is a higher-level construct that will be optimized/expanded later\n                // For now, treat it as a call\n                let arr_val = self.lower_expression(array)?;\n                let dest = self.fresh_var();\n                self.emit_instruction(Instruction::Call {\n                    dest: Some(dest),\n                    function: format!(\"map_{}\", function),\n                    args: vec![arr_val],\n                });\n                Ok(Value::Var(dest))\n            }\n        }\n    }\n\n    fn emit_instruction(&mut self, inst: Instruction) {\n        if let Some(block) = &mut self.current_block {\n            block.instructions.push(inst);\n        }\n    }\n\n    fn convert_type(&self, ty: &ast::Type) -> IRType {\n        match ty {\n            ast::Type::Int => IRType::Int,\n            ast::Type::Float => IRType::Float,\n            ast::Type::Bool => IRType::Bool,\n            ast::Type::Array(elem, size) => {",
      "type": "rust",
      "keywords": [
        "lower",
        "emit_instruction",
        "convert_type",
        "that",
        "ast",
        "quantum",
        "gpu",
        "type",
        "check",
        "optimize",
        "ir",
        "expression",
        "function",
        "if",
        "measure"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "src/middle/lower.rs:351-410",
      "filePath": "src/middle/lower.rs",
      "fileName": "lower.rs",
      "content": "            block.instructions.push(inst);\n        }\n    }\n\n    fn convert_type(&self, ty: &ast::Type) -> IRType {\n        match ty {\n            ast::Type::Int => IRType::Int,\n            ast::Type::Float => IRType::Float,\n            ast::Type::Bool => IRType::Bool,\n            ast::Type::Array(elem, size) => {\n                IRType::Array(Box::new(self.convert_type(elem)), *size)\n            }\n            ast::Type::Qubit => IRType::Qubit,\n            ast::Type::Void => IRType::Void,\n            ast::Type::Tensor(elem) => {\n                // For now, treat tensor<T> as array<T> in IR\n                // Later we'll add proper IR support for tensors\n                IRType::Array(Box::new(self.convert_type(elem)), None)\n            }\n            ast::Type::QState => {\n                // For now, treat qstate as opaque type\n                // Later we'll add proper IR support\n                IRType::Qubit  // Placeholder\n            }\n        }\n    }\n\n    fn convert_binop(&self, op: ast::BinaryOp) -> BinOp {\n        match op {\n            ast::BinaryOp::Add => BinOp::Add,\n            ast::BinaryOp::Sub => BinOp::Sub,\n            ast::BinaryOp::Mul => BinOp::Mul,\n            ast::BinaryOp::Div => BinOp::Div,\n            ast::BinaryOp::Mod => BinOp::Mod,\n            ast::BinaryOp::Eq => BinOp::Eq,\n            ast::BinaryOp::Ne => BinOp::Ne,\n            ast::BinaryOp::Lt => BinOp::Lt,\n            ast::BinaryOp::Le => BinOp::Le,\n            ast::BinaryOp::Gt => BinOp::Gt,\n            ast::BinaryOp::Ge => BinOp::Ge,\n            ast::BinaryOp::And => BinOp::And,\n            ast::BinaryOp::Or => BinOp::Or,\n        }\n    }\n\n    fn convert_unop(&self, op: ast::UnaryOp) -> UnOp {\n        match op {\n            ast::UnaryOp::Neg => UnOp::Neg,\n            ast::UnaryOp::Not => UnOp::Not,\n        }\n    }\n}\n\npub fn lower_to_ir(program: &ast::Program) -> Result<Module> {\n    let mut lowerer = Lowerer::new();\n    lowerer.lower_module(program)\n}\n\n\n",
      "type": "rust",
      "keywords": [
        "lower",
        "convert_type",
        "convert_binop",
        "convert_unop",
        "lower_to_ir",
        "ast",
        "type",
        "ir",
        "qubit"
      ],
      "startLine": 351,
      "endLine": 410
    },
    {
      "id": "src/middle/mod.rs:1-10",
      "filePath": "src/middle/mod.rs",
      "fileName": "mod.rs",
      "content": "pub mod ir;\nmod lower;\nmod optimize;\nmod dump;\n\npub use lower::lower_to_ir;\npub use optimize::optimize;\npub use dump::dump_ir;\n\n",
      "type": "rust",
      "keywords": [
        "mod",
        "optimize",
        "ir",
        "lower"
      ],
      "startLine": 1,
      "endLine": 10
    },
    {
      "id": "src/middle/optimize.rs:1-80",
      "filePath": "src/middle/optimize.rs",
      "fileName": "optimize.rs",
      "content": "// Optimization: Improve program performance without changing semantics\n// Dataflow Analysis: Analyze how data flows through the program\n// SSA Form: Simplifies optimization by making def-use chains explicit\n\nuse super::ir::*;\nuse std::collections::{HashMap, HashSet};\n\n// Optimization Pipeline: Multiple passes for better results\npub fn optimize(module: &mut Module) {\n    eprintln!(\"INFO: Running optimization passes...\");\n    for func in &mut module.functions {\n        eprintln!(\"INFO: Optimizing function '{}'\", func.name);\n        optimize_function(func);\n    }\n    eprintln!(\"INFO: Optimization complete\");\n}\n\n// Function-level optimization: Apply multiple passes iteratively\n// Iterative Dataflow Analysis: Repeat until fixed point\nfn optimize_function(func: &mut IRFunction) {\n    // Run optimization passes in order (multiple iterations for better results)\n    for _ in 0..3 {\n        copy_propagation(func);                    // Replace copies with originals\n        constant_folding(func);                    // Evaluate constants at compile time\n        inline_single_use_vars(func);              // Inline single-use expressions\n        common_subexpression_elimination(func);    // CSE: Reuse computed values\n        dead_code_elimination(func);               // DCE: Remove unused code\n    }\n    // TODO: map_fusion, LICM (Loop-Invariant Code Motion)\n}\n\n/// Copy Propagation: Replace variable uses with their assigned values\n/// Dataflow Analysis: Forward propagation of copy assignments\n/// Example: x = y; z = x + 1; â†’ z = y + 1;\nfn copy_propagation(func: &mut IRFunction) {\n    let mut copy_map: HashMap<SSAVar, Value> = HashMap::new();\n\n    // Build copy map: v = x -> replace all uses of v with x\n    // Reaching Definitions: Track which assignments reach each use\n    for block in &func.blocks {\n        for inst in &block.instructions {\n            if let Instruction::Assign { dest, value } = inst {\n                // Propagate constants and variable copies\n                match value {\n                    Value::Var(_) | Value::Int(_) | Value::Float(_) | Value::Bool(_) => {\n                        copy_map.insert(*dest, value.clone());\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n\n    // Replace uses with propagated values\n    // Def-Use Chain: Follow uses of each definition\n    for block in &mut func.blocks {\n        for inst in &mut block.instructions {\n            replace_value_uses(inst, &copy_map);\n        }\n        replace_terminator_uses(&mut block.terminator, &copy_map);\n    }\n}\n\n/// Inline Single-Use Variables - replace variables used only once with their values\nfn inline_single_use_vars(func: &mut IRFunction) {\n    // This optimization is complex and can break code if not done carefully\n    // For now, copy propagation + DCE already handles most cases\n    // TODO: Implement safe expression inlining for Load and BinaryOp\n}\n\n/// Constant Folding: Evaluate constant expressions at compile time\n/// Optimization: Reduce runtime computation by computing at compile time\n/// Example: x = 2 + 3; â†’ x = 5;\nfn constant_folding(func: &mut IRFunction) {\n    for block in &mut func.blocks {\n        for inst in &mut block.instructions {\n            if let Instruction::BinaryOp { dest, op, left, right } = inst {\n                // Try to fold if both operands are constants\n                // Constant Propagation: Use known constant values\n                if let (Value::Int(l), Value::Int(r)) = (&*left, &*right) {",
      "type": "rust",
      "keywords": [
        "optimize",
        "optimize_function",
        "copy_propagation",
        "inline_single_use_vars",
        "constant_folding",
        "compile",
        "ir",
        "expression",
        "function",
        "variable",
        "loop",
        "if",
        "gate"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "src/middle/optimize.rs:71-150",
      "filePath": "src/middle/optimize.rs",
      "fileName": "optimize.rs",
      "content": "/// Constant Folding: Evaluate constant expressions at compile time\n/// Optimization: Reduce runtime computation by computing at compile time\n/// Example: x = 2 + 3; â†’ x = 5;\nfn constant_folding(func: &mut IRFunction) {\n    for block in &mut func.blocks {\n        for inst in &mut block.instructions {\n            if let Instruction::BinaryOp { dest, op, left, right } = inst {\n                // Try to fold if both operands are constants\n                // Constant Propagation: Use known constant values\n                if let (Value::Int(l), Value::Int(r)) = (&*left, &*right) {\n                    let result = match op {\n                        BinOp::Add => Some(*l + *r),\n                        BinOp::Sub => Some(*l - *r),\n                        BinOp::Mul => Some(*l * *r),\n                        BinOp::Div if *r != 0 => Some(*l / *r),\n                        _ => None,\n                    };\n                    if let Some(val) = result {\n                        *inst = Instruction::Assign {\n                            dest: *dest,\n                            value: Value::Int(val),\n                        };\n                    }\n                } else if let (Value::Float(l), Value::Float(r)) = (&*left, &*right) {\n                    let result = match op {\n                        BinOp::Add => Some(*l + *r),\n                        BinOp::Sub => Some(*l - *r),\n                        BinOp::Mul => Some(*l * *r),\n                        BinOp::Div if *r != 0.0 => Some(*l / *r),\n                        _ => None,\n                    };\n                    if let Some(val) = result {\n                        *inst = Instruction::Assign {\n                            dest: *dest,\n                            value: Value::Float(val),\n                        };\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Dead Code Elimination (DCE): Remove instructions whose results are never used\n/// Liveness Analysis: Determine which variables are live at each program point\n/// Example: x = 5; y = 3; return y; â†’ y = 3; return y; (x is dead)\nfn dead_code_elimination(func: &mut IRFunction) {\n    let mut used_vars = HashSet::new();\n\n    // Liveness Analysis: Mark variables that are live (used)\n    // Backward analysis: Start from uses and work back to definitions\n    for block in &func.blocks {\n        // Mark variables in terminator (always live)\n        match &block.terminator {\n            Terminator::Return(val) => mark_value_used(val, &mut used_vars),\n            Terminator::Branch { condition, .. } => mark_value_used(condition, &mut used_vars),\n            _ => {}\n        }\n\n        // Mark variables in side-effecting instructions\n        for inst in &block.instructions {\n            match inst {\n                Instruction::Store { array, index, value } => {\n                    // Store is side-effecting - mark array and all operands as used\n                    used_vars.insert(*array);\n                    mark_value_used(index, &mut used_vars);\n                    mark_value_used(value, &mut used_vars);\n                }\n                Instruction::Call { args, .. } => {\n                    for arg in args {\n                        mark_value_used(arg, &mut used_vars);\n                    }\n                }\n                Instruction::DomainConversion { source, .. } => {\n                    mark_value_used(source, &mut used_vars);\n                }\n                _ => {}\n            }\n        }\n    }",
      "type": "rust",
      "keywords": [
        "optimize",
        "constant_folding",
        "dead_code_elimination",
        "compile",
        "ir",
        "expression",
        "function",
        "variable",
        "if"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "src/middle/optimize.rs:141-220",
      "filePath": "src/middle/optimize.rs",
      "fileName": "optimize.rs",
      "content": "                        mark_value_used(arg, &mut used_vars);\n                    }\n                }\n                Instruction::DomainConversion { source, .. } => {\n                    mark_value_used(source, &mut used_vars);\n                }\n                _ => {}\n            }\n        }\n    }\n\n    // Iteratively mark variables that are used\n    let mut changed = true;\n    while changed {\n        changed = false;\n        for block in &func.blocks {\n            for inst in &block.instructions {\n                if let Some(dest) = get_dest(inst) {\n                    if used_vars.contains(&dest) {\n                        // Mark operands as used\n                        for operand in get_operands(inst) {\n                            if let Value::Var(v) = operand {\n                                if used_vars.insert(*v) {\n                                    changed = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Remove unused instructions\n    for block in &mut func.blocks {\n        block.instructions.retain(|inst| {\n            if let Some(dest) = get_dest(inst) {\n                used_vars.contains(&dest) || is_side_effecting(inst)\n            } else {\n                true\n            }\n        });\n    }\n}\n\n/// Common Subexpression Elimination (CSE): Reuse previously computed values\n/// Available Expressions: Track which expressions have been computed\n/// Example: a = b + c; d = b + c; â†’ a = b + c; d = a;\nfn common_subexpression_elimination(func: &mut IRFunction) {\n    let mut expr_map: HashMap<String, SSAVar> = HashMap::new();\n\n    // Available Expressions Analysis: Track computed expressions\n    for block in &mut func.blocks {\n        for inst in &mut block.instructions {\n            match inst {\n                Instruction::BinaryOp {\n                    dest,\n                    op,\n                    left,\n                    right,\n                } => {\n                    // Hash expression for lookup\n                    let expr_key = format!(\"{:?} {:?} {:?}\", op, left, right);\n                    if let Some(&existing_var) = expr_map.get(&expr_key) {\n                        // Expression already computed, reuse result\n                        // Replace computation with copy\n                        *inst = Instruction::Assign {\n                            dest: *dest,\n                            value: Value::Var(existing_var),\n                        };\n                    } else {\n                        // First occurrence, record it\n                        expr_map.insert(expr_key, *dest);\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n}",
      "type": "rust",
      "keywords": [
        "optimize",
        "common_subexpression_elimination",
        "ir",
        "expression",
        "function",
        "variable",
        "if"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "src/middle/optimize.rs:211-290",
      "filePath": "src/middle/optimize.rs",
      "fileName": "optimize.rs",
      "content": "                    } else {\n                        // First occurrence, record it\n                        expr_map.insert(expr_key, *dest);\n                    }\n                }\n                _ => {}\n            }\n        }\n    }\n}\n\nfn mark_value_used(val: &Value, used: &mut HashSet<SSAVar>) {\n    if let Value::Var(v) = val {\n        used.insert(*v);\n    } else if let Value::Array(elements) = val {\n        for elem in elements {\n            mark_value_used(elem, used);\n        }\n    }\n}\n\nfn get_dest(inst: &Instruction) -> Option<SSAVar> {\n    match inst {\n        Instruction::Assign { dest, .. }\n        | Instruction::BinaryOp { dest, .. }\n        | Instruction::UnaryOp { dest, .. }\n        | Instruction::Load { dest, .. }\n        | Instruction::Phi { dest, .. } => Some(*dest),\n        Instruction::Call { dest, .. } => *dest,\n        _ => None,\n    }\n}\n\nfn get_operands(inst: &Instruction) -> Vec<&Value> {\n    match inst {\n        Instruction::Assign { value, .. } => vec![value],\n        Instruction::BinaryOp { left, right, .. } => vec![left, right],\n        Instruction::UnaryOp { operand, .. } => vec![operand],\n        Instruction::Load { index, .. } => vec![index],\n        Instruction::Store { index, value, .. } => vec![index, value],\n        Instruction::Call { args, .. } => args.iter().collect(),\n        Instruction::Phi { incoming, .. } => incoming.iter().map(|(v, _)| v).collect(),\n        Instruction::DomainConversion { source, .. } => vec![source],\n    }\n}\n\nfn get_operands_mut(inst: &mut Instruction) -> Vec<&mut Value> {\n    match inst {\n        Instruction::Assign { value, .. } => vec![value],\n        Instruction::BinaryOp { left, right, .. } => vec![left, right],\n        Instruction::UnaryOp { operand, .. } => vec![operand],\n        Instruction::Load { index, .. } => vec![index],\n        Instruction::Store { index, value, .. } => vec![index, value],\n        Instruction::Call { args, .. } => args.iter_mut().collect(),\n        Instruction::Phi { incoming, .. } => incoming.iter_mut().map(|(v, _)| v).collect(),\n        Instruction::DomainConversion { source, .. } => vec![source],\n    }\n}\n\nfn is_side_effecting(inst: &Instruction) -> bool {\n    matches!(\n        inst,\n        Instruction::Store { .. } | Instruction::Call { .. } | Instruction::DomainConversion { .. }\n    )\n}\n\nfn replace_value_uses(inst: &mut Instruction, copy_map: &HashMap<SSAVar, Value>) {\n    match inst {\n        Instruction::Assign { value, .. } => replace_value(value, copy_map),\n        Instruction::BinaryOp { left, right, .. } => {\n            replace_value(left, copy_map);\n            replace_value(right, copy_map);\n        }\n        Instruction::UnaryOp { operand, .. } => replace_value(operand, copy_map),\n        Instruction::Load { index, .. } => replace_value(index, copy_map),\n        Instruction::Store { index, value, .. } => {\n            replace_value(index, copy_map);\n            replace_value(value, copy_map);\n        }\n        Instruction::Call { args, .. } => {",
      "type": "rust",
      "keywords": [
        "optimize",
        "mark_value_used",
        "get_dest",
        "get_operands",
        "get_operands_mut",
        "is_side_effecting",
        "replace_value_uses",
        "ir",
        "if"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "src/middle/optimize.rs:281-360",
      "filePath": "src/middle/optimize.rs",
      "fileName": "optimize.rs",
      "content": "            replace_value(left, copy_map);\n            replace_value(right, copy_map);\n        }\n        Instruction::UnaryOp { operand, .. } => replace_value(operand, copy_map),\n        Instruction::Load { index, .. } => replace_value(index, copy_map),\n        Instruction::Store { index, value, .. } => {\n            replace_value(index, copy_map);\n            replace_value(value, copy_map);\n        }\n        Instruction::Call { args, .. } => {\n            for arg in args {\n                replace_value(arg, copy_map);\n            }\n        }\n        Instruction::DomainConversion { source, .. } => replace_value(source, copy_map),\n        _ => {}\n    }\n}\n\nfn replace_value(value: &mut Value, copy_map: &HashMap<SSAVar, Value>) {\n    if let Value::Var(v) = value {\n        if let Some(replacement) = copy_map.get(v) {\n            *value = replacement.clone();\n        }\n    } else if let Value::Array(elements) = value {\n        for elem in elements {\n            replace_value(elem, copy_map);\n        }\n    }\n}\n\nfn replace_terminator_uses(term: &mut Terminator, copy_map: &HashMap<SSAVar, Value>) {\n    match term {\n        Terminator::Return(val) => replace_value(val, copy_map),\n        Terminator::Branch { condition, .. } => replace_value(condition, copy_map),\n        _ => {}\n    }\n}\n\nfn count_value_uses(inst: &Instruction, use_count: &mut HashMap<SSAVar, usize>) {\n    for operand in get_operands(inst) {\n        count_value_in_value(operand, use_count);\n    }\n}\n\nfn count_value_in_value(value: &Value, use_count: &mut HashMap<SSAVar, usize>) {\n    match value {\n        Value::Var(v) => *use_count.entry(*v).or_insert(0) += 1,\n        Value::Array(elements) => {\n            for elem in elements {\n                count_value_in_value(elem, use_count);\n            }\n        }\n        _ => {}\n    }\n}\n\nfn count_terminator_uses(term: &Terminator, use_count: &mut HashMap<SSAVar, usize>) {\n    match term {\n        Terminator::Return(val) => count_value_in_value(val, use_count),\n        Terminator::Branch { condition, .. } => count_value_in_value(condition, use_count),\n        _ => {}\n    }\n}\n\nfn inline_instruction_uses(inst: &mut Instruction, inline_map: &HashMap<SSAVar, Instruction>) {\n    match inst {\n        Instruction::Assign { value, .. } => inline_value_uses(value, inline_map),\n        Instruction::BinaryOp { left, right, .. } => {\n            inline_value_uses(left, inline_map);\n            inline_value_uses(right, inline_map);\n        }\n        Instruction::UnaryOp { operand, .. } => inline_value_uses(operand, inline_map),\n        Instruction::Load { index, .. } => inline_value_uses(index, inline_map),\n        Instruction::Store { index, value, .. } => {\n            inline_value_uses(index, inline_map);\n            inline_value_uses(value, inline_map);\n        }\n        Instruction::Call { args, .. } => {\n            for arg in args {",
      "type": "rust",
      "keywords": [
        "optimize",
        "replace_value",
        "replace_terminator_uses",
        "count_value_uses",
        "count_value_in_value",
        "count_terminator_uses",
        "inline_instruction_uses",
        "if"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "src/middle/optimize.rs:351-399",
      "filePath": "src/middle/optimize.rs",
      "fileName": "optimize.rs",
      "content": "            inline_value_uses(right, inline_map);\n        }\n        Instruction::UnaryOp { operand, .. } => inline_value_uses(operand, inline_map),\n        Instruction::Load { index, .. } => inline_value_uses(index, inline_map),\n        Instruction::Store { index, value, .. } => {\n            inline_value_uses(index, inline_map);\n            inline_value_uses(value, inline_map);\n        }\n        Instruction::Call { args, .. } => {\n            for arg in args {\n                inline_value_uses(arg, inline_map);\n            }\n        }\n        Instruction::DomainConversion { source, .. } => inline_value_uses(source, inline_map),\n        _ => {}\n    }\n}\n\nfn inline_value_uses(value: &mut Value, inline_map: &HashMap<SSAVar, Instruction>) {\n    if let Value::Var(v) = value {\n        if let Some(inst) = inline_map.get(v) {\n            // Replace with the value from the inlined instruction\n            match inst {\n                Instruction::Assign { value: val, .. } => {\n                    *value = val.clone();\n                }\n                Instruction::Load { array, index, .. } => {\n                    // Can't inline complex expressions into Value - keep as is\n                    // This will be handled by backend\n                }\n                _ => {}\n            }\n        }\n    } else if let Value::Array(elements) = value {\n        for elem in elements {\n            inline_value_uses(elem, inline_map);\n        }\n    }\n}\n\nfn inline_terminator_instruction_uses(term: &mut Terminator, inline_map: &HashMap<SSAVar, Instruction>) {\n    match term {\n        Terminator::Return(val) => inline_value_uses(val, inline_map),\n        Terminator::Branch { condition, .. } => inline_value_uses(condition, inline_map),\n        _ => {}\n    }\n}\n\n",
      "type": "rust",
      "keywords": [
        "optimize",
        "inline_value_uses",
        "inline_terminator_instruction_uses",
        "backend",
        "expression",
        "if"
      ],
      "startLine": 351,
      "endLine": 399
    },
    {
      "id": "THEORY.md:1-80",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "# QuarkDSL Compiler Theory Documentation\n\nThis document maps the QuarkDSL compiler implementation to formal compiler theory concepts and compilation techniques.\n\n## Table of Contents\n\n1. [Lexical Analysis](#1-lexical-analysis)\n2. [Syntax Analysis](#2-syntax-analysis)\n3. [Semantic Analysis](#3-semantic-analysis)\n4. [Intermediate Representation](#4-intermediate-representation)\n5. [Optimization](#5-optimization)\n6. [Code Generation](#6-code-generation)\n7. [Runtime Systems](#7-runtime-systems)\n\n---\n\n## 1. Lexical Analysis\n\n### Theory\n\nLexical analysis is the first phase of compilation that converts a stream of characters into a stream of tokens.\n\n**Key Concepts:**\n\n- Regular Expressions: Patterns that describe token structure\n- DFA (Deterministic Finite Automaton): State machine for token recognition\n- Thompson's Construction: Algorithm to convert regex to epsilon-NFA\n- Subset Construction: Algorithm to convert NFA to DFA\n- DFA Minimization: Reduce number of states in DFA\n- Maximal Munch: Always take the longest matching token\n\n**Process:**\n\n```\nSource Code â†’ Regex Patterns â†’ Îµ-NFA â†’ NFA â†’ DFA â†’ Minimized DFA â†’ Tokens\n```\n\n### Implementation\n\n**File:** `src/frontend/lexer.rs`\n\n**Technology:** Logos library (automatic DFA generation from regex)\n\n**Token Categories:**\n\n1. Keywords: `fn`, `let`, `return`, `if`, `else`, `for`, `in`, `map`\n2. Annotations: `@gpu`, `@quantum`\n3. Types: `int`, `float`, `bool`, `qubit`, `void`, `tensor`, `qstate`\n4. Literals: Integer, Float, String, Boolean\n5. Identifiers: Variable and function names\n6. Operators: `+`, `-`, `*`, `/`, `==`, `!=`, `<`, `>`, `<=`, `>=`\n7. Delimiters: `(`, `)`, `{`, `}`, `[`, `]`, `;`, `,`, `:`\n\n**Regex Examples:**\n\n- Identifier: `[a-zA-Z_][a-zA-Z0-9_]*`\n- Integer: `[0-9]+`\n- Float: `[0-9]+\\.[0-9]+`\n- Whitespace (skip): `[ \\t\\n\\f]+`\n- Comments (skip): `//[^\\n]*`\n\n**DFA State Machine:**\nThe Logos library automatically generates a DFA from regex patterns. For example, the identifier regex creates states:\n\n```\nState 0 (start) --[a-zA-Z_]--> State 1 (accepting)\nState 1 --[a-zA-Z0-9_]--> State 1 (loop)\nState 1 --[other]--> State 0 (reject)\n```\n\n---\n\n## 2. Syntax Analysis\n\n### Theory\n\nSyntax analysis (parsing) verifies that tokens form valid grammatical structures according to a Context-Free Grammar (CFG).\n\n**Key Concepts:**\n",
      "type": "markdown",
      "keywords": [
        "theory",
        "lexer",
        "token",
        "compile",
        "quantum",
        "gpu",
        "type",
        "ir",
        "frontend",
        "expression",
        "function",
        "variable",
        "loop",
        "if",
        "qubit"
      ],
      "startLine": 1,
      "endLine": 80
    },
    {
      "id": "THEORY.md:71-150",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "---\n\n## 2. Syntax Analysis\n\n### Theory\n\nSyntax analysis (parsing) verifies that tokens form valid grammatical structures according to a Context-Free Grammar (CFG).\n\n**Key Concepts:**\n\n- Context-Free Grammar (CFG): Formal grammar with production rules\n- Derivation: Process of generating strings from grammar\n- Parse Tree: Tree showing derivation steps\n- Abstract Syntax Tree (AST): Simplified parse tree\n- Top-Down Parsing: Start from root, expand to leaves\n- Recursive Descent Parser (RDP): Top-down parser where each rule is a function\n- LL(1) Grammar: Left-to-right scan, Leftmost derivation, 1 lookahead token\n- Left Recursion: Grammar rule that references itself on the left (must be eliminated for RDP)\n- Left Factoring: Extracting common prefixes to enable predictive parsing\n- First Set: Set of terminals that can start a production\n- Follow Set: Set of terminals that can follow a non-terminal\n\n**Grammar Classification:**\n\n- Type 0: Unrestricted Grammar\n- Type 1: Context-Sensitive Grammar\n- Type 2: Context-Free Grammar (CFG) - Used in QuarkDSL\n- Type 3: Regular Grammar (used in lexical analysis)\n\n**QuarkDSL Grammar (Simplified CFG):**\n\n```\nProgram    â†’ Function*\nFunction   â†’ Domain? \"fn\" Identifier \"(\" Parameters \")\" \"->\" Type Block\nDomain     â†’ \"@gpu\" | \"@quantum\"\nParameters â†’ (Parameter (\",\" Parameter)*)?\nParameter  â†’ Identifier \":\" Type\nType       â†’ \"int\" | \"float\" | \"bool\" | \"qubit\" | \"void\" | \"[\" Type \"]\"\nBlock      â†’ \"{\" Statement* \"}\"\nStatement  â†’ LetStmt | ReturnStmt | IfStmt | ForStmt | AssignStmt | ExprStmt\nLetStmt    â†’ \"let\" Identifier (\":\" Type)? \"=\" Expression \";\"\nReturnStmt â†’ \"return\" Expression \";\"\nIfStmt     â†’ \"if\" Expression Block (\"else\" Block)?\nForStmt    â†’ \"for\" Identifier \"in\" Range Block\nAssignStmt â†’ Identifier \"[\" Expression \"]\" \"=\" Expression \";\"\nExprStmt   â†’ Expression \";\"\nExpression â†’ LogicalOr\nLogicalOr  â†’ LogicalAnd (\"||\" LogicalAnd)*\nLogicalAnd â†’ Equality (\"&&\" Equality)*\nEquality   â†’ Comparison ((\"==\" | \"!=\") Comparison)*\nComparison â†’ Term ((\"<\" | \">\" | \"<=\" | \">=\") Term)*\nTerm       â†’ Factor ((\"+\" | \"-\") Factor)*\nFactor     â†’ Unary ((\"*\" | \"/\") Unary)*\nUnary      â†’ (\"!\" | \"-\") Unary | Primary\nPrimary    â†’ Literal | Identifier | Call | Index | \"(\" Expression \")\"\nCall       â†’ Identifier \"(\" Arguments \")\"\nIndex      â†’ Identifier \"[\" Expression \"]\"\nRange      â†’ Expression \"..\" Expression\n```\n\n**Left Recursion Elimination Example:**\n\nOriginal (left-recursive, bad for RDP):\n\n```\nExpression â†’ Expression \"+\" Term\n           | Term\n```\n\nTransformed (right-recursive, good for RDP):\n\n```\nExpression â†’ Term Expression'\nExpression' â†’ \"+\" Term Expression'\n            | Îµ\n```\n\nImplemented as iteration:\n\n```",
      "type": "markdown",
      "keywords": [
        "theory",
        "parser",
        "ast",
        "token",
        "quantum",
        "gpu",
        "type",
        "ir",
        "expression",
        "statement",
        "function",
        "if",
        "qubit"
      ],
      "startLine": 71,
      "endLine": 150
    },
    {
      "id": "THEORY.md:141-220",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "\n```\nExpression â†’ Term Expression'\nExpression' â†’ \"+\" Term Expression'\n            | Îµ\n```\n\nImplemented as iteration:\n\n```\nExpression â†’ Term (\"+\" Term)*\n```\n\n**Left Factoring Example:**\n\nOriginal (ambiguous):\n\n```\nStatement â†’ \"if\" Expression Block\n          | \"if\" Expression Block \"else\" Block\n```\n\nFactored (unambiguous):\n\n```\nStatement â†’ \"if\" Expression Block (\"else\" Block)?\n```\n\n### Implementation\n\n**File:** `src/frontend/parser.rs`\n\n**Technique:** Recursive Descent Parser (RDP)\n\n**Parser Structure:**\n\n- Each grammar rule is implemented as a function\n- Functions call each other recursively\n- One token lookahead for decision making\n- Returns AST nodes\n\n**Key Functions:**\n\n- `parse_program()` - Entry point, parses entire program\n- `parse_function()` - Parses function definition\n- `parse_statement()` - Parses statements\n- `parse_expression()` - Parses expressions with precedence\n- `parse_term()` - Parses multiplication/division\n- `parse_factor()` - Parses unary operations\n- `parse_primary()` - Parses literals, identifiers, calls\n\n**Precedence Levels (lowest to highest):**\n\n1. Logical OR (`||`)\n2. Logical AND (`&&`)\n3. Equality (`==`, `!=`)\n4. Comparison (`<`, `>`, `<=`, `>=`)\n5. Addition/Subtraction (`+`, `-`)\n6. Multiplication/Division (`*`, `/`)\n7. Unary (`!`, `-`)\n8. Primary (literals, identifiers, calls, indexing)\n\n**AST Node Types:**\n\n- `Program` - Root node containing functions\n- `Function` - Function definition with domain, parameters, body\n- `Statement` - Let, Return, If, For, Assignment, Expression\n- `Expression` - Binary operations, unary operations, literals, calls\n- `Type` - Type annotations\n\n---\n\n## 3. Semantic Analysis\n\n### Theory\n\nSemantic analysis verifies that the program is meaningful beyond just syntactic correctness.\n\n**Key Concepts:**\n",
      "type": "markdown",
      "keywords": [
        "theory",
        "parser",
        "ast",
        "token",
        "type",
        "ir",
        "frontend",
        "expression",
        "statement",
        "function",
        "if"
      ],
      "startLine": 141,
      "endLine": 220
    },
    {
      "id": "THEORY.md:211-290",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "---\n\n## 3. Semantic Analysis\n\n### Theory\n\nSemantic analysis verifies that the program is meaningful beyond just syntactic correctness.\n\n**Key Concepts:**\n\n- Type Checking: Verify operations are type-safe\n- Symbol Table: Data structure tracking identifiers and their attributes\n- Scope: Region where an identifier is visible\n- Type System: Rules for assigning types to expressions\n- Type Inference: Automatically deduce types\n- Semantic Errors: Type mismatches, undefined variables, duplicate declarations\n\n**Type Checking Rules:**\n\n- Binary operations: Both operands must have compatible types\n- Function calls: Argument types must match parameter types\n- Assignments: Right-hand side type must match left-hand side type\n- Return statements: Return type must match function signature\n- Array indexing: Index must be integer type\n\n**Symbol Table Operations:**\n\n- Insert: Add new identifier to table\n- Lookup: Find identifier and retrieve attributes\n- Enter Scope: Create new scope level\n- Exit Scope: Remove scope level and its identifiers\n\n### Implementation\n\n**Files:** `src/frontend/parser.rs`, `src/middle/lower.rs`\n\n**Type System:**\n\n- Primitive types: `int`, `float`, `bool`, `qubit`, `void`\n- Composite types: Arrays `[T]`, Tensors `tensor<T>`, Quantum states `qstate`\n- Domain-specific types: GPU types, Quantum types\n\n**Type Checking:**\nType checking is performed during AST construction and IR lowering. The compiler maintains type information for all variables and expressions.\n\n**Scope Management:**\nScopes are managed implicitly through the parser's recursive structure. Each function has its own scope, and nested blocks create nested scopes.\n\n---\n\n## 4. Intermediate Representation\n\n### Theory\n\nIntermediate Representation (IR) is a language-independent representation between source code and target code.\n\n**Key Concepts:**\n\n- Three-Address Code: Instructions with at most three operands\n- Static Single Assignment (SSA): Each variable assigned exactly once\n- Basic Block: Sequence of instructions with single entry and exit\n- Control Flow Graph (CFG): Graph of basic blocks\n- Dominance: Block A dominates B if all paths to B go through A\n- Phi Function: Merge values from different control flow paths\n- Def-Use Chain: Link between variable definition and uses\n- Use-Def Chain: Link between variable use and definitions\n\n**SSA Form Benefits:**\n\n- Simplifies optimization algorithms\n- Makes dataflow explicit\n- Eliminates need for complex dataflow analysis\n- Each variable has single definition point\n- Enables efficient constant propagation and dead code elimination\n\n**Three-Address Code Format:**\n\n```\nresult = operand1 operator operand2\n```",
      "type": "markdown",
      "keywords": [
        "theory",
        "parser",
        "ast",
        "compile",
        "quantum",
        "gpu",
        "type",
        "check",
        "error",
        "ir",
        "lower",
        "frontend",
        "middle",
        "expression",
        "statement",
        "function",
        "variable",
        "if",
        "qubit"
      ],
      "startLine": 211,
      "endLine": 290
    },
    {
      "id": "THEORY.md:281-360",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "- Makes dataflow explicit\n- Eliminates need for complex dataflow analysis\n- Each variable has single definition point\n- Enables efficient constant propagation and dead code elimination\n\n**Three-Address Code Format:**\n\n```\nresult = operand1 operator operand2\n```\n\nExamples:\n\n```\nt1 = a + b\nt2 = t1 * c\nt3 = -t2\nx = t3\n```\n\n**Phi Function:**\nUsed to merge values from different control flow paths in SSA form.\n\n```\nif (condition) {\n    x1 = 5;\n} else {\n    x2 = 10;\n}\nx3 = Ï†(x1, x2);  // x3 gets x1 or x2 depending on which path was taken\n```\n\n### Implementation\n\n**File:** `src/middle/ir.rs`\n\n**IR Structure:**\n\n- `Module` - Collection of functions\n- `IRFunction` - Function with parameters, return type, basic blocks\n- `BasicBlock` - Label, instructions, terminator\n- `Instruction` - SSA instructions (Assign, BinaryOp, UnaryOp, Load, Store, Call, etc.)\n- `Terminator` - Control flow (Jump, Branch, Return)\n- `Value` - SSA variable, constant, or parameter\n- `SSAVar` - Unique variable identifier\n\n**Instruction Types:**\n\n- `Assign` - Variable assignment\n- `BinaryOp` - Binary operations (add, sub, mul, div, etc.)\n- `UnaryOp` - Unary operations (neg, not)\n- `Load` - Array element load\n- `Store` - Array element store\n- `Call` - Function call\n- `QuantumGate` - Quantum gate application\n- `Measure` - Quantum measurement\n- `DomainConversion` - Cross-domain data transfer\n\n**SSA Variable Naming:**\nVariables are numbered sequentially: `%0`, `%1`, `%2`, etc.\nEach assignment creates a new SSA variable.\n\n**Lowering Process:**\n\n```\nAST â†’ IR Lowering â†’ SSA Form\n```\n\nThe lowering pass converts AST to IR by:\n\n1. Analyzing domains of all functions\n2. Converting expressions to three-address code\n3. Generating SSA variables for each assignment\n4. Creating basic blocks for control flow\n5. Inserting terminators at block ends\n\n---\n\n## 5. Optimization\n",
      "type": "markdown",
      "keywords": [
        "theory",
        "ast",
        "quantum",
        "type",
        "ir",
        "lower",
        "middle",
        "expression",
        "function",
        "variable",
        "if",
        "gate",
        "measure"
      ],
      "startLine": 281,
      "endLine": 360
    },
    {
      "id": "THEORY.md:351-430",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "1. Analyzing domains of all functions\n2. Converting expressions to three-address code\n3. Generating SSA variables for each assignment\n4. Creating basic blocks for control flow\n5. Inserting terminators at block ends\n\n---\n\n## 5. Optimization\n\n### Theory\n\nOptimization improves program performance without changing semantics.\n\n**Key Concepts:**\n\n- Dataflow Analysis: Analyze how data flows through program\n- Liveness Analysis: Determine which variables are live at each point\n- Reaching Definitions: Which assignments reach a program point\n- Available Expressions: Which expressions are already computed\n- Dead Code Elimination (DCE): Remove code that doesn't affect output\n- Common Subexpression Elimination (CSE): Reuse computed values\n- Constant Folding: Evaluate constant expressions at compile time\n- Constant Propagation: Replace variables with their constant values\n- Copy Propagation: Replace copies with original values\n- Loop Optimization: Improve loop performance\n\n**Dead Code Elimination:**\nRemove instructions whose results are never used.\n\n```\nx = 5;      // Dead if x is never used\ny = x + 3;  // Dead if y is never used\nreturn 10;\n```\n\n**Common Subexpression Elimination:**\nReuse previously computed values.\n\n```\n// Before CSE:\na = b + c;\nd = b + c;  // Redundant computation\n\n// After CSE:\na = b + c;\nd = a;      // Reuse result\n```\n\n**Constant Folding:**\nEvaluate constant expressions at compile time.\n\n```\n// Before:\nx = 2 + 3;\ny = x * 4;\n\n// After:\nx = 5;\ny = 20;\n```\n\n### Implementation\n\n**File:** `src/middle/optimize.rs`\n\n**Optimization Passes:**\n\n1. Dead Code Elimination (DCE)\n\n   - Build use-count map for all SSA variables\n   - Mark instructions whose results are used\n   - Remove unmarked instructions\n   - Leverages SSA form's explicit def-use chains\n\n2. Common Subexpression Elimination (CSE)\n   - Track computed expressions\n   - Detect duplicate computations\n   - Replace duplicates with references to first computation\n   - Uses expression hashing for efficient lookup",
      "type": "markdown",
      "keywords": [
        "theory",
        "compile",
        "optimize",
        "ir",
        "middle",
        "expression",
        "function",
        "variable",
        "loop",
        "if"
      ],
      "startLine": 351,
      "endLine": 430
    },
    {
      "id": "THEORY.md:421-500",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "   - Build use-count map for all SSA variables\n   - Mark instructions whose results are used\n   - Remove unmarked instructions\n   - Leverages SSA form's explicit def-use chains\n\n2. Common Subexpression Elimination (CSE)\n   - Track computed expressions\n   - Detect duplicate computations\n   - Replace duplicates with references to first computation\n   - Uses expression hashing for efficient lookup\n\n**Optimization Pipeline:**\n\n```\nIR â†’ DCE â†’ CSE â†’ Optimized IR\n```\n\nThe optimizer can be enabled with the `--optimize` flag.\n\n---\n\n## 6. Code Generation\n\n### Theory\n\nCode generation translates IR to target machine or language code.\n\n**Key Concepts:**\n\n- Instruction Selection: Choose target instructions for IR operations\n- Register Allocation: Assign variables to registers or memory\n- Instruction Scheduling: Reorder instructions for performance\n- Peephole Optimization: Local optimizations on small code windows\n- Code Templates: Patterns for translating IR to target code\n\n**Instruction Selection:**\nMap IR instructions to target instructions.\n\n```\nIR: t1 = a + b\nTarget (x86): ADD eax, ebx\nTarget (WGSL): let t1 = a + b;\n```\n\n**Register Allocation:**\nAssign unlimited SSA variables to limited physical registers.\nTechniques: Graph coloring, linear scan\n\n### Implementation\n\n**Files:** `src/backend/wgsl.rs`, `src/backend/quantum.rs`, `src/backend/orchestrator.rs`\n\n**Multi-Backend Architecture:**\n\nQuarkDSL supports three code generation backends:\n\n1. WGSL Backend (`wgsl.rs`)\n\n   - Target: WebGPU Shading Language\n   - Domain: GPU functions\n   - Output: `.wgsl` shader files\n   - Features: Parallel computation, array operations\n\n2. Quantum Backend (`quantum.rs`)\n\n   - Target: Qiskit Python\n   - Domain: Quantum functions\n   - Output: `.py` quantum circuit files\n   - Features: Quantum gates, measurement, state preparation\n\n3. Orchestrator Backend (`orchestrator.rs`)\n   - Target: Python\n   - Domain: Hybrid quantum-classical workflows\n   - Output: `.py` orchestration scripts\n   - Features: Cross-domain calls, data marshalling, IBM Quantum integration\n\n**Code Generation Process:**\n\n```\nIR â†’ Pattern Matching â†’ Target Code Emission â†’ Output File",
      "type": "markdown",
      "keywords": [
        "theory",
        "wgsl",
        "quantum",
        "gpu",
        "shader",
        "optimize",
        "ir",
        "backend",
        "orchestrator",
        "expression",
        "function",
        "variable",
        "gate",
        "measure",
        "hybrid"
      ],
      "startLine": 421,
      "endLine": 500
    },
    {
      "id": "THEORY.md:491-570",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "3. Orchestrator Backend (`orchestrator.rs`)\n   - Target: Python\n   - Domain: Hybrid quantum-classical workflows\n   - Output: `.py` orchestration scripts\n   - Features: Cross-domain calls, data marshalling, IBM Quantum integration\n\n**Code Generation Process:**\n\n```\nIR â†’ Pattern Matching â†’ Target Code Emission â†’ Output File\n```\n\nEach backend:\n\n1. Traverses IR basic blocks\n2. Pattern matches on instruction types\n3. Emits corresponding target code\n4. Handles domain-specific features\n\n**Domain-Specific Code Generation:**\n\n- GPU functions generate parallel array operations\n- Quantum functions generate quantum circuits\n- Hybrid functions generate orchestration code with domain transitions\n\n---\n\n## 7. Runtime Systems\n\n### Theory\n\nRuntime systems provide execution environment for compiled programs.\n\n**Key Concepts:**\n\n- Virtual Machine (VM): Software that executes bytecode\n- Interpreter: Directly executes source or IR without compilation\n- Stack-Based VM: Uses operand stack for computation\n- Register-Based VM: Uses virtual registers\n- Bytecode: Compact instruction encoding\n- Fetch-Decode-Execute Cycle: VM execution loop\n- Stack Frame: Activation record for function calls\n- Heap: Dynamic memory allocation\n- Garbage Collection: Automatic memory management\n\n**Stack-Based VM:**\n\n```\nBytecode: PUSH 5, PUSH 3, ADD\n\nExecution:\nStack: []\nPUSH 5 â†’ Stack: [5]\nPUSH 3 â†’ Stack: [5, 3]\nADD    â†’ Stack: [8]\n```\n\n**Register-Based VM:**\n\n```\nBytecode: LOAD R1, 5; LOAD R2, 3; ADD R3, R1, R2\n\nExecution:\nRegisters: R1=0, R2=0, R3=0\nLOAD R1, 5  â†’ R1=5\nLOAD R2, 3  â†’ R2=3\nADD R3, R1, R2 â†’ R3=8\n```\n\n**Fetch-Decode-Execute Cycle:**\n\n```\nwhile (pc < bytecode.length) {\n    instruction = fetch(bytecode[pc]);\n    decode(instruction);\n    execute(instruction);\n    pc++;\n}\n```\n",
      "type": "markdown",
      "keywords": [
        "theory",
        "compile",
        "quantum",
        "gpu",
        "type",
        "ir",
        "backend",
        "orchestrator",
        "function",
        "loop",
        "if",
        "hybrid"
      ],
      "startLine": 491,
      "endLine": 570
    },
    {
      "id": "THEORY.md:561-640",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "\n```\nwhile (pc < bytecode.length) {\n    instruction = fetch(bytecode[pc]);\n    decode(instruction);\n    execute(instruction);\n    pc++;\n}\n```\n\n### Implementation\n\n**Status:** Complete (TypeScript VM)\n\n**Files:** `quarkdsl-web/lib/vm/`\n\n**Architecture:**\n\n- Stack-based VM for simplicity and portability\n- Custom bytecode format (not SSA IR)\n- Full quantum state vector simulation\n- Browser and Node.js compatible\n\n**VM Components:**\n\n| Component         | File                   | Description                      |\n| ----------------- | ---------------------- | -------------------------------- |\n| Lexer             | `lexer.ts`             | DFA-based tokenizer              |\n| Parser            | `parser.ts`            | Recursive descent parser         |\n| Compiler          | `compiler.ts`          | AST to bytecode compiler         |\n| VM                | `vm.ts`                | Stack-based bytecode interpreter |\n| Quantum Simulator | `quantum-simulator.ts` | 8-qubit state vector simulator   |\n| Quantum Gates     | `quantum-gates.ts`     | Gate implementations             |\n\n**Bytecode Opcodes:**\n\n```typescript\nenum Opcode {\n  // Stack operations\n  PUSH,\n  POP,\n  DUP,\n  // Arithmetic\n  ADD,\n  SUB,\n  MUL,\n  DIV,\n  MOD,\n  NEG,\n  // Comparison\n  EQ,\n  NE,\n  LT,\n  LE,\n  GT,\n  GE,\n  // Logic\n  AND,\n  OR,\n  NOT,\n  // Variables\n  LOAD,\n  STORE,\n  LOAD_GLOBAL,\n  STORE_GLOBAL,\n  // Control flow\n  JUMP,\n  JUMP_IF_FALSE,\n  CALL,\n  RETURN,\n  // Arrays\n  ARRAY_NEW,\n  ARRAY_GET,\n  ARRAY_SET,\n  ARRAY_LEN,\n  // Quantum operations\n  QUANTUM_H,\n  QUANTUM_X,\n  QUANTUM_Y,\n  QUANTUM_Z,",
      "type": "markdown",
      "keywords": [
        "theory",
        "opcode",
        "lexer",
        "parser",
        "ast",
        "token",
        "compile",
        "quantum",
        "type",
        "ir",
        "variable",
        "if",
        "qubit",
        "gate"
      ],
      "startLine": 561,
      "endLine": 640
    },
    {
      "id": "THEORY.md:631-710",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "  // Arrays\n  ARRAY_NEW,\n  ARRAY_GET,\n  ARRAY_SET,\n  ARRAY_LEN,\n  // Quantum operations\n  QUANTUM_H,\n  QUANTUM_X,\n  QUANTUM_Y,\n  QUANTUM_Z,\n  QUANTUM_RX,\n  QUANTUM_RY,\n  QUANTUM_RZ,\n  QUANTUM_CNOT,\n  QUANTUM_SWAP,\n  QUANTUM_TOFFOLI,\n  QUANTUM_MEASURE,\n  QUANTUM_RESET,\n}\n```\n\n**Quantum Simulator:**\n\nThe quantum simulator maintains a full state vector for up to 8 qubits (256 complex amplitudes):\n\n```typescript\nclass QuantumSimulator {\n  private stateVector: Complex[]; // 2^n amplitudes\n  private numQubits: number; // Max 8 qubits\n\n  applyGate(gate: QuantumGate, targets: number[]): void;\n  measure(qubit: number): number; // Returns 0 or 1\n  reset(): void;\n}\n```\n\n**Quantum Gates Implemented:**\n\n| Gate      | Matrix         | Description                           |\n| --------- | -------------- | ------------------------------------- |\n| H         | Hadamard       | Creates superposition                 |\n| X         | Pauli-X        | Bit flip (NOT)                        |\n| Y         | Pauli-Y        | Bit and phase flip                    |\n| Z         | Pauli-Z        | Phase flip                            |\n| RX(theta) | X-rotation     | Rotation around X-axis                |\n| RY(theta) | Y-rotation     | Rotation around Y-axis                |\n| RZ(theta) | Z-rotation     | Rotation around Z-axis                |\n| CNOT      | Controlled-NOT | Two-qubit entangling gate             |\n| SWAP      | Swap           | Exchanges two qubits                  |\n| Toffoli   | CCX            | Three-qubit controlled-controlled-NOT |\n\n**Execution Model:**\n\n```\nQuarkDSL Source\n    â†“\nLexer â†’ Tokens\n    â†“\nParser â†’ AST\n    â†“\nCompiler â†’ Bytecode\n    â†“\nVM Execution\n    â”œâ”€â”€ Classical: Stack-based computation\n    â”œâ”€â”€ GPU: Array operations (JavaScript simulation)\n    â””â”€â”€ Quantum: State vector simulation\n```\n\n**Example Execution:**\n\n```typescript\n// QuarkDSL code\n@quantum\nfn bell_state() -> int {\n    h(0);\n    cx(0, 1);\n    return measure(0);\n}\n\n// Compiled bytecode",
      "type": "markdown",
      "keywords": [
        "theory",
        "bell_state",
        "lexer",
        "parser",
        "ast",
        "token",
        "compile",
        "quantum",
        "gpu",
        "type",
        "qubit",
        "gate",
        "measure"
      ],
      "startLine": 631,
      "endLine": 710
    },
    {
      "id": "THEORY.md:701-780",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "```typescript\n// QuarkDSL code\n@quantum\nfn bell_state() -> int {\n    h(0);\n    cx(0, 1);\n    return measure(0);\n}\n\n// Compiled bytecode\n[\n  QUANTUM_H, 0,        // Apply H to qubit 0\n  QUANTUM_CNOT, 0, 1,  // Apply CNOT with control=0, target=1\n  QUANTUM_MEASURE, 0,  // Measure qubit 0\n  RETURN               // Return measurement result\n]\n\n// VM execution\n// 1. Initialize |00> state\n// 2. H gate: |00> -> (|00> + |10>)/sqrt(2)\n// 3. CNOT: (|00> + |10>)/sqrt(2) -> (|00> + |11>)/sqrt(2)\n// 4. Measure: Returns 0 or 1 with 50% probability each\n```\n\n---\n\n## Compiler Pipeline Summary\n\n### Native Compiler (Rust)\n\n```\nSource Code (.tgpu)\n    â†“\n[1. Lexical Analysis]\n    Regex â†’ DFA â†’ Tokens\n    â†“\n[2. Syntax Analysis]\n    Tokens â†’ RDP â†’ AST\n    â†“\n[3. Semantic Analysis]\n    Type Checking â†’ Validated AST\n    â†“\n[4. IR Generation]\n    AST â†’ Lowering â†’ SSA IR\n    â†“\n[5. Optimization]\n    DCE, CSE â†’ Optimized IR\n    â†“\n[6. Code Generation]\n    â”œâ”€â†’ WGSL Backend â†’ .wgsl (GPU)\n    â”œâ”€â†’ Quantum Backend â†’ .py (Qiskit)\n    â””â”€â†’ Orchestrator Backend â†’ .py (Hybrid)\n```\n\n### TypeScript VM\n\n```\nSource Code (.tgpu)\n    â†“\n[1. Lexical Analysis]\n    DFA Lexer â†’ Tokens\n    â†“\n[2. Syntax Analysis]\n    RDP Parser â†’ AST\n    â†“\n[3. Compilation]\n    AST â†’ Bytecode\n    â†“\n[4. Execution]\n    Stack-based VM\n    â”œâ”€â†’ Classical operations\n    â”œâ”€â†’ GPU simulation (arrays)\n    â””â”€â†’ Quantum simulation (state vector)\n```\n\n---\n\n## Theoretical Foundations\n\n### Chomsky Hierarchy",
      "type": "markdown",
      "keywords": [
        "theory",
        "bell_state",
        "lexer",
        "parser",
        "ast",
        "token",
        "compile",
        "wgsl",
        "quantum",
        "gpu",
        "type",
        "check",
        "optimize",
        "ir",
        "lower",
        "backend",
        "orchestrator",
        "qubit",
        "gate",
        "measure",
        "hybrid"
      ],
      "startLine": 701,
      "endLine": 780
    },
    {
      "id": "THEORY.md:771-822",
      "filePath": "THEORY.md",
      "fileName": "THEORY.md",
      "content": "    â”œâ”€â†’ Classical operations\n    â”œâ”€â†’ GPU simulation (arrays)\n    â””â”€â†’ Quantum simulation (state vector)\n```\n\n---\n\n## Theoretical Foundations\n\n### Chomsky Hierarchy\n\nQuarkDSL uses different grammar types at different stages:\n\n| Level  | Grammar Type      | Used In           | Example                          |\n| ------ | ----------------- | ----------------- | -------------------------------- |\n| Type 3 | Regular           | Lexical Analysis  | `[a-zA-Z_][a-zA-Z0-9_]*`         |\n| Type 2 | Context-Free      | Syntax Analysis   | `Expression â†’ Term + Expression` |\n| Type 1 | Context-Sensitive | Semantic Analysis | Type checking rules              |\n| Type 0 | Unrestricted      | Not used          | N/A                              |\n\n### Parsing Techniques Comparison\n\n| Technique         | Type      | Lookahead | Grammar | Used in QuarkDSL |\n| ----------------- | --------- | --------- | ------- | ---------------- |\n| Recursive Descent | Top-Down  | 1         | LL(1)   | Yes              |\n| LL Parser         | Top-Down  | k         | LL(k)   | No               |\n| LR Parser         | Bottom-Up | 1         | LR(1)   | No               |\n| LALR Parser       | Bottom-Up | 1         | LALR(1) | No               |\n\n### Optimization Classification\n\n| Type            | Scope         | Examples                                   | Implemented    |\n| --------------- | ------------- | ------------------------------------------ | -------------- |\n| Local           | Basic Block   | Constant folding, algebraic simplification | Partial        |\n| Global          | Function      | DCE, CSE, constant propagation             | Yes (DCE, CSE) |\n| Interprocedural | Whole Program | Inlining, dead function elimination        | No             |\n| Loop            | Loops         | Loop unrolling, invariant code motion      | Partial        |\n\n---\n\n## References\n\n1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools (2nd ed.). Addison-Wesley.\n\n2. Appel, A. W. (2004). Modern Compiler Implementation in ML. Cambridge University Press.\n\n3. Cooper, K. D., & Torczon, L. (2011). Engineering a Compiler (2nd ed.). Morgan Kaufmann.\n\n4. Cytron, R., Ferrante, J., Rosen, B. K., Wegman, M. N., & Zadeck, F. K. (1991). Efficiently computing static single assignment form and the control dependence graph. ACM Transactions on Programming Languages and Systems, 13(4), 451-490.\n\n5. Muchnick, S. S. (1997). Advanced Compiler Design and Implementation. Morgan Kaufmann.\n",
      "type": "markdown",
      "keywords": [
        "theory",
        "parser",
        "compile",
        "quantum",
        "gpu",
        "type",
        "check",
        "expression",
        "function",
        "loop",
        "if"
      ],
      "startLine": 771,
      "endLine": 822
    }
  ],
  "fileList": [
    "docs/data-marshalling-design.md",
    "docs/hybrid-design.md",
    "docs/IBM_QUANTUM_INTEGRATION.md",
    "docs/PROJECT_PROPOSAL.md",
    "examples/bell_state.tgpu",
    "examples/bell_state_quantum.tgpu",
    "examples/bell_state_unix.tgpu",
    "examples/hybrid_simple.tgpu",
    "examples/hybrid_vqe.tgpu",
    "examples/quantum_test.tgpu",
    "examples/simple_array.tgpu",
    "examples/simple_gpu.tgpu",
    "examples/test_loop.tgpu",
    "examples/with_print.tgpu",
    "project-requirements.md",
    "README.md",
    "src/backend/mod.rs",
    "src/backend/orchestrator.rs",
    "src/backend/quantum.rs",
    "src/backend/wgsl.rs",
    "src/cli.rs",
    "src/frontend/ast.rs",
    "src/frontend/lexer.rs",
    "src/frontend/mod.rs",
    "src/frontend/parser.rs",
    "src/frontend/typecheck.rs",
    "src/main.rs",
    "src/middle/dump.rs",
    "src/middle/ir.rs",
    "src/middle/lower.rs",
    "src/middle/mod.rs",
    "src/middle/optimize.rs",
    "THEORY.md"
  ]
}